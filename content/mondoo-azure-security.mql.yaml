# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-azure-security
    name: Mondoo Microsoft Azure Security
    version: 4.0.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: azure,cloud
    require:
      - provider: azure
      - provider: terraform
    authors:
      - name: Mondoo, Inc.
        email: hello@mondoo.com
    summary: Secure Azure VMs, storage, networking, and IAM
    docs:
      desc: |
        The Mondoo Azure Security policy is designed to identify critical misconfigurations that could leave your Azure infrastructure vulnerable to attackers. This policy helps organizations detect and remediate security risks before they can be exploited, reducing the likelihood of unauthorized access, data breaches, privilege escalation, and operational disruptions.

        This policy provides security checks across key Azure services, uncovering misconfigurations that could put critical resources at risk, particularly those exposed to the public internet:

        - App Service
        - Azure Batch
        - Azure Cache for Redis
        - Azure Cosmos DB
        - Azure Firewall
        - Azure Kubernetes Service (AKS)
        - Compute (virtual machines and disks)
        - Key Vault (keys, secrets, and certificates)
        - Microsoft Defender for Cloud
        - Network (security groups, watchers, virtual networks, and subnets)
        - SQL Database, PostgreSQL, and MySQL
        - Storage (accounts and data protection)
        - Subscription (diagnostic settings and activity log alerts)

        Have suggestions for new checks in this policy? Visit our [cnspec repository](https://github.com/mondoohq/cnspec).
    groups:
      - title: Azure Storage
        checks:
          - uid: mondoo-azure-security-public-access-level-private-blob-containers
          - uid: mondoo-azure-security-trusted-microsoft-services-enabled-for-storage-account-access
          - uid: mondoo-azure-security-secure-transfer-required-enabled
          - uid: mondoo-azure-security-default-network-access-rule-storage-accounts-deny
          - uid: mondoo-azure-security-storage-blob-soft-delete-enabled
          - uid: mondoo-azure-security-storage-container-soft-delete-enabled
          - uid: mondoo-azure-security-storage-min-tls-version
          - uid: mondoo-azure-security-storage-cross-tenant-replication-disabled
          - uid: mondoo-azure-security-storage-sftp-disabled
          - uid: mondoo-azure-security-storage-shared-key-access-disabled
      - title: Azure SQL
        checks:
          - uid: mondoo-azure-security-sql-server-audit-on
          - uid: mondoo-azure-security-sql-server-tde-on
          - uid: mondoo-azure-security-ensure-that-ssl-enabled-latest-version-mysql
          - uid: mondoo-azure-security-ensure-that-ssl-enabled-postgresql
          - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0
          - uid: mondoo-azure-security-ensure-disabled-public-access-sql
          - uid: mondoo-azure-security-ensure-auditing-retention-greater-than-30-days
          - uid: mondoo-azure-security-sql-threat-detection-enabled
          - uid: mondoo-azure-security-sql-ad-admin-configured
      - title: Azure Key Vault
        checks:
          - uid: mondoo-azure-security-ensure-the-expiration-date-is-set-for-all-keys-and-secrets-in-kv
          - uid: mondoo-azure-security-ensure-the-kv-is-recoverable
          - uid: mondoo-azure-security-ensure-logging-enabled-kv
          - uid: mondoo-azure-security-keyvault-public-access-disabled
          - uid: mondoo-azure-security-keyvault-rbac-enabled
          - uid: mondoo-azure-security-keyvault-key-auto-rotation
      - title: Azure Compute
        checks:
          - uid: mondoo-azure-security-ensure-os-disk-are-encrypted
          - uid: mondoo-azure-security-compute-data-disks-encrypted
          - uid: mondoo-azure-security-compute-vm-no-public-ip
          - uid: mondoo-azure-security-compute-managed-disks-only
          - uid: mondoo-azure-security-compute-unattached-disks-encrypted
      - title: Azure Network
        checks:
          - uid: mondoo-azure-security-ssh-access-restricted-from-internet
          - uid: mondoo-azure-security-rdp-access-restricted-from-internet
          - uid: mondoo-azure-security-vnc-access-restricted-from-internet
          - uid: mondoo-azure-security-disable-udp-virtualmachines
          - uid: mondoo-azure-security-ensure-activity-log-alert-exists-for-create-update-delete-network-security-group
          - uid: mondoo-azure-security-network-watcher-flow-logs-enabled
          - uid: mondoo-azure-security-network-ddos-protection-enabled
          - uid: mondoo-azure-security-network-subnet-default-outbound-disabled
          - uid: mondoo-azure-security-network-database-ports-restricted
      - title: Azure Subscription
        checks:
          - uid: mondoo-azure-security-diagnostic-settings-essential-categories
          - uid: mondoo-azure-security-diagnostic-settings-exist
          - uid: mondoo-azure-security-ensure-that-notify-about-alerts-with-high-severity-is-on
      - title: Microsoft Defender for Cloud
        checks:
          - uid: mondoo-azure-security-defender-for-servers-enabled
          - uid: mondoo-azure-security-defender-for-app-services-enabled
          - uid: mondoo-azure-security-defender-for-sql-databases-enabled
          - uid: mondoo-azure-security-defender-for-storage-enabled
          - uid: mondoo-azure-security-defender-for-keyvault-enabled
          - uid: mondoo-azure-security-defender-for-containers-enabled
          - uid: mondoo-azure-security-defender-for-resource-manager-enabled
          - uid: mondoo-azure-security-defender-auto-provisioning-enabled
          - uid: mondoo-azure-security-defender-for-cosmosdb-enabled
          - uid: mondoo-azure-security-defender-for-open-source-databases-enabled
          - uid: mondoo-azure-security-defender-cspm-enabled
      - title: Azure Kubernetes Service (AKS)
        checks:
          - uid: mondoo-azure-security-aks-rbac-enabled
          - uid: mondoo-azure-security-aks-api-server-authorized-ip-ranges
          - uid: mondoo-azure-security-aks-network-policy-enabled
          - uid: mondoo-azure-security-aks-private-cluster-enabled
          - uid: mondoo-azure-security-aks-run-command-disabled
          - uid: mondoo-azure-security-aks-azure-policy-addon-enabled
          - uid: mondoo-azure-security-aks-private-cluster-public-fqdn-disabled
      - title: App Service
        checks:
          - uid: mondoo-azure-security-app-service-https-only
          - uid: mondoo-azure-security-app-service-ftp-disabled
          - uid: mondoo-azure-security-app-service-scm-disabled
          - uid: mondoo-azure-security-ensure-register-with-ad-is-enabled-on-app-service
          - uid: mondoo-azure-security-ensure-web-app-is-using-the-latest-tls
          - uid: mondoo-azure-security-app-service-client-cert-enabled
          - uid: mondoo-azure-security-app-service-remote-debugging-disabled
          - uid: mondoo-azure-security-app-service-http20-enabled
          - uid: mondoo-azure-security-app-service-ftps-required
          - uid: mondoo-azure-security-app-service-cors-no-wildcard
          - uid: mondoo-azure-security-function-app-authentication-enabled
          - uid: mondoo-azure-security-function-app-private-endpoints
      - title: Azure Cache for Redis
        checks:
          - uid: mondoo-azure-security-redis-ssl-only
          - uid: mondoo-azure-security-redis-public-access-disabled
          - uid: mondoo-azure-security-redis-min-tls-version
          - uid: mondoo-azure-security-redis-latest-version
      - title: Azure Cosmos DB
        checks:
          - uid: mondoo-azure-security-cosmosdb-public-access-disabled
          - uid: mondoo-azure-security-cosmosdb-local-auth-disabled
          - uid: mondoo-azure-security-cosmosdb-vnet-filter-enabled
          - uid: mondoo-azure-security-cosmosdb-key-based-metadata-write-disabled
          - uid: mondoo-azure-security-cosmosdb-automatic-failover-enabled
          - uid: mondoo-azure-security-cosmosdb-min-tls-version
          - uid: mondoo-azure-security-cosmosdb-network-acl-bypass-none
          - uid: mondoo-azure-security-cosmosdb-cmk-encryption
      - title: Azure Firewall
        checks:
          - uid: mondoo-azure-security-firewall-threat-intel-deny
          - uid: mondoo-azure-security-firewall-premium-sku
          - uid: mondoo-azure-security-firewall-policy-configured
          - uid: mondoo-azure-security-firewall-idps-enabled
      - title: Azure Batch
        checks:
          - uid: mondoo-azure-security-batch-public-access-disabled
          - uid: mondoo-azure-security-batch-aad-auth-only
          - uid: mondoo-azure-security-batch-encryption-configured
          - uid: mondoo-azure-security-batch-diagnostic-settings-enabled
    scoring_system: highest impact
queries:
  - uid: mondoo-azure-security-ensure-os-disk-are-encrypted
    title: Ensure OS Disks in Azure virtual machines are encrypted with Customer Managed Keys (CMK)
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-10
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-compute-vm-api"
    mql: |
      azure.subscription.compute.vm.osDisk.properties.encryption.type == "EncryptionAtRestWithCustomerKey"
    docs:
      desc: |
        This check ensures that OS disks for Azure virtual machines are encrypted, which is critical for securing boot volumes from unauthorized access and data breaches. The use of Customer Managed Keys (CMK) offers enhanced control over the encryption and decryption processes, allowing organizations to manage their own keys via Azure Key Vault. This approach not only meets compliance requirements but also provides a higher level of security by enabling key rotation and revocation capabilities. Encrypting OS disks ensures that the data is unreadable to unauthorized users, protecting it from both external attacks and insider threats. Customer managed keys can be either Azure Disk Encryption (ADE) or server-side encryption (SSE).

        **Why this matters**

        Encrypting OS disks with Customer Managed Keys provides several critical security benefits:

        - **Data protection**: Encryption ensures that data on the OS disk is unreadable to unauthorized users, protecting it from both external attacks and insider threats.
        - **Enhanced control**: Using CMK allows organizations to manage their own encryption keys via Azure Key Vault, enabling key rotation and revocation capabilities.
        - **Compliance alignment**: Many regulatory standards and security frameworks require encryption of data at rest, and CMK provides additional control to meet stringent compliance requirements.
        - **Risk mitigation**: Encrypting boot volumes prevents unauthorized access to sensitive system data in scenarios such as disk theft or improper decommissioning.

        By ensuring OS disks are encrypted with Customer Managed Keys, this check helps to protect sensitive data, meet compliance requirements, and enhance the overall security posture of Azure virtual machines.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Virtual machines** in the Azure Portal.
        2. Select a virtual machine and access **Disks** under the Settings menu.
        3. Verify the encryption settings for the OS disk to ensure it uses CMK.

        **Automated Audit with Azure CLI:**

        List and check the encryption settings for all disks in a specific resource group:

        ```bash
        az disk list --resource-group "yourResourceGroupName" --query "[].{Name:name, ResourceGroupName:resourceGroup, EncryptionSettings:encryptionSettingsCollection}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzDisk -ResourceGroupName "yourResourceGroupName" | Select-Object Name, ResourceGroupName, EncryptionSettingsCollection
        ```

        Ensure the EncryptionType is set to EncryptionAtRestWithCustomerKey for OS disks.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To update using Microsoft Azure Portal:

            1. Log into the Azure Portal and navigate to **Disks**.
            2. Select the OS disk you wish to encrypt.
            3. In the **Encryption** section, set **Encryption type** to **Customer-managed keys**.
            4. Specify the Azure Key Vault and select the appropriate key.
            5. Save the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az vm encryption enable --resource-group <ResourceGroupName> --name <VMName> --disk-encryption-keyvault <KeyVaultName> --key-encryption-key <KeyName> --volume-type OS
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzVMDiskEncryptionExtension -ResourceGroupName <ResourceGroupName> -VMName <VMName> -KeyVaultUrl <KeyVaultUrl> -VolumeType OS
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            __Encrypt disks Linux VM__

            ```hcl
            # Encrypt Linux OS disk with Terraform
            resource "azurerm_linux_virtual_machine" "example" {
              name                = "example-linux-machine"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location

              ...

              encryption_at_host_enabled = true

              ...
            }
            ```

            __Encrypt disks Windows VM__

            ```hcl
            resource "azurerm_windows_virtual_machine" "example" {
              name                = "example-windows-machine"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location

              ...

              encryption_at_host_enabled = true

              ...
            }
            ```

            __Encrypt managed disks__

            ```hcl
            resource "azurerm_managed_disk" "example" {
              name                 = var.disk_name
              location             = var.location
              resource_group_name  = var.resource_group_name
              ...

              encryption_settings {
                enabled = true
              }

              ...
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/virtual-machines/disk-encryption-overview
        title: Overview of managed disk encryption options
  - uid: mondoo-azure-security-ssh-access-restricted-from-internet
    title: Ensure that SSH access is restricted from the internet
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-network-security-group"
    props:
      - uid: mondooAzureSecurityDisallowedPortsSSH
        title: A list of disallowed TCP ports, by default SSH listens only on TCP port 22. Add more ports as needed.
        mql: |
          return [
            22,
          ]
    mql: |
      allNsgTCP = azure.subscription.network.securityGroup.securityRules
        .where(
          properties.access == 'Allow'
            && direction == 'Inbound'
            && properties.protocol == /TCP|\*/i
            && properties.sourceAddressPrefix == /\*|0\.0\.0\.0|<nw>\/0|\/0|internet|any/
        )
      allNsgTCP.all(properties.destinationPortRange != "*")
      props.mondooAzureSecurityDisallowedPortsSSH {
        disallowedPortSSH = _
        disallowedPortSSH
        allNsgTCP.none(destinationPortRange.any(fromPort <= disallowedPortSSH && toPort >= disallowedPortSSH))
      }
    docs:
      desc: |
        This check ensures that SSH access (port 22) is restricted from the internet to minimize security risks.

        **Why this matters**

        Exposing SSH access to the internet can lead to significant security risks:

        - **Unauthorized access**: SSH is a common target for brute force and other unauthorized access attempts.
        - **Increased attack surface**: Allowing unrestricted SSH access expands the attack surface, making it easier for attackers to exploit vulnerabilities.
        - **Compliance risks**: Many security standards and best practices recommend restricting SSH access to reduce potential threats.
        - **Operational risks**: Misconfigured or exposed SSH access can lead to unintended access, service disruptions, or data breaches.

        By ensuring SSH access is restricted to known, secure sources, this check helps to minimize security vulnerabilities, align with best practices, and enhance the overall security posture of Azure resources.
      audit: |
        **Manual Audit via Azure Portal:**

          **Checking via Network Security Groups (NSGs) for All Resources:**
          1. From the main Azure Portal menu, navigate to **Network security groups**.
          2. Select an NSG associated with the resources you want to check.
          3. Go to the **Inbound security rules** section.
          4. Review all the rules to ensure none allow SSH access (port 22, TCP) from broadly defined sources such as 'Any', '0.0.0.0', or 'Internet'.
          5. Confirm that rules configured to permit SSH access are scoped to specific, known IP addresses or ranges to minimize exposure.

          **Checking Specific Virtual Machines:**
          1. Log into the Azure Portal.
          2. Navigate to **Virtual machines**.
          3. Select a specific virtual machine to review.
          4. Within the virtual machine's blade, select **Networking** under the settings menu.
          5. Access the **Networking** blade of the selected VM, then review the **Inbound port rules**.
          6. Ensure there are no rules allowing SSH access (port 22, TCP) from 'Any' or 'Internet' source address prefixes. Only secure, specified IP ranges should be allowed, if necessary.

        **Automated Audit with Azure CLI:**

        List NSGs and check for SSH access rules:

        ```bash
        az network nsg list --query "[].{NSG: name, Rules: securityRules[?access=='Allow' && protocol=='Tcp' && direction=='Inbound' && (destinationPortRange=='22' || destinationPortRanges.contains('22')) && (sourceAddressPrefix=='*' || sourceAddressPrefix=='0.0.0.0' || sourceAddressPrefix=='<nw>/0' || sourceAddressPrefix=='/0' || sourceAddressPrefix=='internet' || sourceAddressPrefix=='any')]}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. In the Azure Portal, navigate to **Network Security Groups (NSG)** associated with your VMs.
            2. Review or modify the inbound security rules:
              - Set `source_address_prefix` to a specific IP range or a VPN gateway rather than 'Any' or 'Internet'.
              - Ensure that the `destination_port_range` does not include TCP port 22 unless absolutely necessary and from a secure source.
        - id: cli
          desc: |
            **Using Azure CLI**

            Update or create a new NSG rule to restrict SSH access:

            ```bash
            az network nsg rule create --resource-group <ResourceGroupName> --nsg-name <NSGName> --name RestrictSSH --priority 1001 --direction Inbound --access Deny --protocol Tcp --source-address-prefixes <YourSecureIPRange> --destination-port-ranges 22
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            New-AzNetworkSecurityRuleConfig -Name RestrictSSH -Protocol Tcp -Direction Inbound -Priority 1001 -SourceAddressPrefix <YourSecureIPRange> -SourcePortRange * -DestinationAddressPrefix * -DestinationPortRange 22 -Access Allow
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Ensure the `source_address_prefix` is configured to a restrictive CIDR address

            resource "azurerm_network_security_group" "my_terraform_nsg" {
              name                = "myNetworkSecurityGroup"
              location            = azurerm_resource_group.rg.location
              resource_group_name = azurerm_resource_group.rg.name

              security_rule {
                name                       = "SSH"
                priority                   = 1001
                direction                  = "Inbound"
                access                     = "Allow"
                protocol                   = "Tcp"
                source_port_range          = "*"
                destination_port_range     = "22"
                source_address_prefix      = "192.168.22.5/24"
                destination_address_prefix = "*"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-rdp-access-restricted-from-internet
    title: Ensure that RDP access is restricted from the internet
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-network-security-group"
    props:
      - uid: mondooAzureSecurityDisallowedPortsRDP
        title: a list of disallowed TCP ports, by default RDP listens only on TCP port 3389. Add more ports as needed.
        mql: |
          return [
            3389,
          ]
    mql: |
      allNsgTCP = azure.subscription.network.securityGroup.securityRules
        .where(
          properties.access == 'Allow'
            && direction == 'Inbound'
            && properties.protocol == /TCP|\*/i
            && properties.sourceAddressPrefix == /\*|0\.0\.0\.0|<nw>\/0|\/0|internet|any/
        )
      allNsgTCP.all(properties.destinationPortRange != "*")
      props.mondooAzureSecurityDisallowedPortsRDP {
        disallowedPortRDP = _
        disallowedPortRDP
        allNsgTCP.none(destinationPortRange.any(fromPort <= disallowedPortRDP && toPort >= disallowedPortRDP))
      }
    docs:
      desc: |
        This check ensures that RDP access (port 3389) is restricted from the internet to minimize security risks.

        **Why this matters**

        Exposing RDP access to the internet can lead to significant security risks:

        - **Unauthorized access**: RDP is a common target for brute force and other unauthorized access attempts.
        - **Increased attack surface**: Allowing unrestricted RDP access expands the attack surface, making it easier for attackers to exploit vulnerabilities.
        - **Compliance risks**: Many security standards and best practices recommend restricting RDP access to reduce potential threats.
        - **Operational risks**: Misconfigured or exposed RDP access can lead to unintended access, service disruptions, or data breaches.

        By ensuring RDP access is restricted to known, secure sources, this check helps to minimize security vulnerabilities, align with best practices, and enhance the overall security posture of Azure resources.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log into the Azure Portal.
        2. Navigate to **Network security groups** under the Networking or directly through the search bar.
        3. For each NSG, access the **Inbound security rules**.
        4. Carefully review each rule to identify any that allow inbound RDP traffic (TCP port 3389):
          - Check for rules where the protocol is set to `TCP`.
          - The destination port or port range includes `3389`.
          - The source address prefix is too broad, such as 'Any', '0.0.0.0', '<nw>/0', '/0', 'internet', or 'any'.
        5. Note down any NSG rules that do not comply with your organization's security policy regarding restricted access to RDP. These rules should ideally allow access only from trusted, secure networks, and not from the open internet.

        1. Navigate to **Virtual Machines** in the Azure Portal.
        2. For each VM, select the **Networking** blade to review network configurations.
        3. Check the **Inbound port rules** under the associated Network Security Group (NSG).
        4. Verify that there are no rules allowing RDP access (TCP port 3389) from 'Any' or 'Internet'. Only secure, specified IP ranges should be allowed if necessary.

        **Automated Audit with Azure CLI:**

        List NSGs and verify RDP access rules:

        ```bash
        az network nsg list --query "[].{NSG: name, Rules: securityRules[?access=='Allow' && protocol=='Tcp' && direction=='Inbound' && (destinationPortRange=='3389' || destinationPortRanges.contains('3389')) && (sourceAddressPrefix=='*' || sourceAddressPrefix=='0.0.0.0' || sourceAddressPrefix=='<nw>/0' || sourceAddressPrefix=='/0' || sourceAddressPrefix=='internet' || sourceAddressPrefix=='any')]}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log into the Azure Portal and navigate to **Network Security Groups**.
            2. Select the NSG associated with your VM.
            3. Review the **Inbound security rules** and modify or delete any rules that allow internet access to port 3389.
            4. Preferably, change the `source_address_prefix` to more restrictive settings, such as a specific IP range or a secure VPN gateway.
        - id: cli
          desc: |
            **Using Azure CLI**

            Update or create a new NSG rule to restrict RDP access:

            ```bash
            az network nsg rule create --resource-group <ResourceGroupName> --nsg-name <NSGName> --name RestrictRDP --priority 1001 --direction Inbound --access Deny --protocol Tcp --source-address-prefixes <YourSecureIPRange> --destination-port-ranges 3389
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            New-AzNetworkSecurityRuleConfig -Name RestrictRDP -Protocol Tcp -Direction Inbound -Priority 1001 -SourceAddressPrefix <YourSecureIPRange> -SourcePortRange * -DestinationAddressPrefix * -DestinationPortRange 3389 -Access Allow
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Ensure the `source_address_prefix` is configured to a restrictive CIDR address

            resource "azurerm_network_security_group" "example" {
              name                = "example-rdp-security"
              location            = azurerm_resource_group.rg.location
              resource_group_name = azurerm_resource_group.rg.name

              security_rule {
                name                       = "RDP"
                priority                   = 1001
                direction                  = "Inbound"
                access                     = "Allow"
                protocol                   = "Tcp"
                source_port_range          = "*"
                destination_port_range     = "3389"
                source_address_prefix      = "192.168.22.5/24"
                destination_address_prefix = "*"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-vnc-access-restricted-from-internet
    title: Ensure that VNC access is restricted from the internet
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-network-security-group"
    props:
      - uid: mondooAzureSecurityDisallowedPortsVNC
        title: a list of disallowed TCP ports, by default VNC listens only on TCP port 5900. Add more ports as needed.
        mql: |
          return [
            5900,
          ]
    mql: |
      allNsgTCP = azure.subscription.network.securityGroup.securityRules
        .where(
          properties.access == 'Allow'
            && direction == 'Inbound'
            && properties.protocol == /TCP|\*/i
            && properties.sourceAddressPrefix == /\*|0\.0\.0\.0|<nw>\/0|\/0|internet|any/
        )
      allNsgTCP.all(properties.destinationPortRange != "*")
      props.mondooAzureSecurityDisallowedPortsVNC {
        disallowedPortVNC = _
        disallowedPortVNC
        allNsgTCP.none(destinationPortRange.any(fromPort <= disallowedPortVNC && toPort >= disallowedPortVNC))
      }
    docs:
      desc: |
        This check ensures that VNC access (port 5900) is restricted from the internet to minimize security risks.

        **Why this matters**

        Exposing VNC access to the internet can lead to significant security risks:

        - **Unauthorized access**: VNC is a common target for brute force and other unauthorized access attempts.
        - **Increased attack surface**: Allowing unrestricted VNC access expands the attack surface, making it easier for attackers to exploit vulnerabilities.
        - **Compliance risks**: Many security standards and best practices recommend restricting VNC access to reduce potential threats.
        - **Operational risks**: Misconfigured or exposed VNC access can lead to unintended access, service disruptions, or data breaches.

        By ensuring VNC access is restricted to known, secure sources, this check helps to minimize security vulnerabilities, align with best practices, and enhance the overall security posture of Azure resources.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log into the Azure Portal.
        2. Navigate to **Network security groups** under the Networking or directly through the search bar.
        3. For each NSG, access the **Inbound security rules**.
        4. Carefully review each rule to identify any that allow inbound VNC traffic (TCP port 5900):
          - Check for rules where the protocol is set to `TCP`.
          - The destination port or port range includes `5900`.
          - The source address prefix is too broad, such as 'Any', '0.0.0.0', '<nw>/0', '/0', 'internet', or 'any'.
        5. Note down any NSG rules that do not comply with your organization's security policy regarding restricted access to VNC. These rules should ideally allow access only from trusted, secure networks, and not from the open internet.

        1. Navigate to **Virtual Machines** in the Azure Portal.
        2. For each VM, select the **Networking** blade to review network configurations.
        3. Check the **Inbound port rules** under the associated Network Security Group (NSG).
        4. Verify that there are no rules allowing VNC access (TCP port 5900) from 'Any' or 'Internet'. Only secure, specified IP ranges should be allowed if necessary.

        **Automated Audit with Azure CLI:**

        List NSGs and verify VNC access rules:

        ```bash
        az network nsg list --query "[].{NSG: name, Rules: securityRules[?access=='Allow' && protocol=='Tcp' && direction=='Inbound' && (destinationPortRange=='5900' || destinationPortRanges.contains('5900')) && (sourceAddressPrefix=='*' || sourceAddressPrefix=='0.0.0.0' || sourceAddressPrefix=='<nw>/0' || sourceAddressPrefix=='/0' || sourceAddressPrefix=='internet' || sourceAddressPrefix=='any')]}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log into the Azure Portal and navigate to **Network Security Groups**.
            2. Select the NSG associated with your VM.
            3. Review the **Inbound security rules** and modify or delete any rules that allow internet access to port 5900.
            4. Preferably, change the `source_address_prefix` to more restrictive settings, such as a specific IP range or a secure VPN gateway.
        - id: cli
          desc: |
            **Using Azure CLI**

            Update or create a new NSG rule to restrict VNC access:

            ```bash
            az network nsg rule create --resource-group <ResourceGroupName> --nsg-name <NSGName> --name RestrictVNC --priority 1001 --direction Inbound --access Deny --protocol Tcp --source-address-prefixes <YourSecureIPRange> --destination-port-ranges 5900
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            New-AzNetworkSecurityRuleConfig -Name RestrictVNC -Protocol Tcp -Direction Inbound -Priority 1001 -SourceAddressPrefix <YourSecureIPRange> -SourcePortRange * -DestinationAddressPrefix * -DestinationPortRange 5900 -Access Allow
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Ensure the `source_address_prefix` is configured to a restrictive CIDR address

            resource "azurerm_network_security_group" "example" {
              name                = "example-vnc-security"
              location            = azurerm_resource_group.rg.location
              resource_group_name = azurerm_resource_group.rg.name

              security_rule {
                name                       = "VNC"
                priority                   = 1001
                direction                  = "Inbound"
                access                     = "Allow"
                protocol                   = "Tcp"
                source_port_range          = "*"
                destination_port_range     = "5900"
                source_address_prefix      = "192.168.22.5/24"
                destination_address_prefix = "*"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-secure-transfer-required-enabled
    title: Mandate HTTPS for Secure Data Transfer to Azure storage accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties.EnableHTTPSTrafficOnly == true
    docs:
      desc: |
        This check ensures that "Secure transfer required" is enabled. This setting enforces the use of HTTPS for data operations, ensuring that data transmitted to and from Azure storage accounts is secured.

        **Why this matters**

        Enabling "Secure transfer required" provides critical security benefits:

        - **Data protection**: Ensures that data in transit is encrypted, preventing interception or tampering during transmission.
        - **Compliance**: Aligns with security best practices and regulatory requirements for secure data transmission.
        - **Mitigation of risks**: Blocks unencrypted HTTP requests, reducing the risk of data breaches or unauthorized access.
        - **Operational integrity**: Prevents unencrypted connections, such as certain SMB protocols, from accessing storage accounts, ensuring secure communication.

        By enforcing HTTPS for all data operations, this check helps to minimize security vulnerabilities, enhance compliance, and protect sensitive data in Azure storage accounts.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage Accounts** from the Azure portal.
        2. For each storage account, select **Configuration** under the settings panel.
        3. Verify that the **Secure transfer required** option is set to **Enabled**.

        **Automated Audit with Azure CLI:**

        Use the Azure CLI to check the status of the 'Secure transfer required' setting across all storage accounts:

        ```bash
        az storage account list --query "[].{AccountName:name, SecureTransferEnabled: enableHttpsTrafficOnly}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage Accounts** in the Azure portal.
            2. Select the storage account you want to configure.
            3. In the settings menu, select **Configuration**.
            4. Set the **Secure transfer required** option to **Enabled**.
            5. Save the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Enable 'Secure transfer required' for an individual storage account in a resource group:

            ```bash
            az storage account update --name <StorageAccountName> --resource-group <ResourceGroupName> --https-only true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzStorageAccount -Name <StorageAccountName> -ResourceGroupName <ResourceGroupName> -EnableHttpsTrafficOnly $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example_storage_account" {
              ...
              enable_https_traffic_only = true
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/storage-security-guide
        title: Azure Storage Security Guide
  - uid: mondoo-azure-security-public-access-level-private-blob-containers
    title: Ensure that anonymous access to blob containers and public access on storage accounts are disabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-3
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties.AllowBlobPublicAccess == "false"
    docs:
      desc: |
        This check ensures that anonymous access to blob containers is disabled and public access on storage accounts is disabled.

        **Why this matters**

        Allowing anonymous access to blob containers and enabling public access on storage accounts can lead to significant security risks:

        - **Unauthorized access**: Anonymous access allows anyone to read or write data without authentication, potentially exposing sensitive information.
        - **Increased attack surface**: Public access to storage accounts expands the attack surface, making it easier for attackers to exploit vulnerabilities.
        - **Compliance risks**: Many security standards and best practices recommend restricting public access to storage accounts to reduce potential threats.
        - **Operational risks**: Misconfigured or exposed storage accounts can lead to unintended data exposure, service disruptions, or data breaches.

        By ensuring anonymous access is disabled and public access is restricted, this check helps to minimize security vulnerabilities, align with best practices, and enhance the overall security posture of Azure storage accounts.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Go to Storage Accounts.
        2. For each storage account, go to the Networking setting under Security + networking.
        3. Ensure the 'Public Network Access' setting is set to 'Disabled'.
        4. In the storage account menu pane, under the 'Settings' section, select 'Configuration'.
        5. Under 'Allow Blob Anonymous Access', ensure that the setting is 'Disabled'.

        **Automated Audit with Azure CLI:**

        1. Authenticate using az login and ensure you are in the correct subscription.
        2. Use the following command to check the 'Public Network Access' setting:

        ```bash
        az storage account show --name <storage-account> --resource-group <resource-group> --query "{publicNetworkAccess:publicNetworkAccess}"
        ```

        ```bash
        az storage account show --name <yourStorageAccountName> --query allowBlobPublicAccess
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Go to Storage Accounts.
            2. For each storage account, go to Networking in Security + networking.
            3. Set 'Public Network Access' to 'Disabled'.
            4. Select a Storage Account and in the settings pane, select 'Configuration'.
            5. Under 'Allow Blob Anonymous Access', select 'Disabled'.
            6. For each container, change the access level to 'Private (no anonymous access)'.
        - id: cli
          desc: |
            **Using Azure CLI**

            - Disable public network access:

              ```bash
              az storage account update --name <storage-account> --resource-group <resource-group> --public-network-access Disabled
              ```

            - Set blob containers to private access:

              ```bash
              az storage container set-permission --name <container_name> --public-access off --account-name <account_name> --account-key <account_key>
              ```
        - id: powershell
          desc: |
            **Using PowerShell**

            - Disable public network access:

              ```powershell
              Set-AzStorageAccount -Name <storage-account> -ResourceGroupName <resource-group> -PublicNetworkAccess Disabled
              ```

            - Set blob containers to private access:

              ```powershell
              Set-AzStorageContainerAcl -Name <container_name> -PublicAccess Off -Context $context
              ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Ensure the `allow_blob_public_access` is set to `false`

            resource "azurerm_storage_account" "example_storage_account" {
              ...
              allow_blob_public_access = false
            }
            ```

            ```hcl
            # Ensure the `container_access_type` is set to `private`
            resource "azurerm_storage_container" "example_container" {
              ...
              container_access_type = "private"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/storage-security-guide
        title: Azure Storage Security Guide
  - uid: mondoo-azure-security-default-network-access-rule-storage-accounts-deny
    title: Enforce Deny as Default Network Access for Azure Storage Accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties.NetworkRuleSet.defaultAction == "Deny"
    docs:
      desc: |
        This check ensures that Azure storage accounts have their default network access rule set to "Deny". This configuration is critical for enhancing security by ensuring that only explicitly allowed networks can access the storage accounts.

        **Why this matters**

        Setting the default network access rule to "Deny" provides several security benefits:

        - **Unauthorized access prevention**: Blocks access from any network that is not explicitly allowed, reducing the risk of unauthorized access.
        - **Minimized attack surface**: Restricts access to storage accounts, ensuring that only approved sources such as specific Azure Virtual Networks or designated public IP addresses can connect.
        - **Compliance alignment**: Many security standards and best practices recommend limiting access to sensitive resources to reduce potential threats.
        - **Operational integrity**: Prevents accidental exposure of storage accounts to the public internet, safeguarding sensitive data from unauthorized access or breaches.

        By enforcing this configuration, this check helps to secure Azure storage accounts, align with best practices, and enhance the overall security posture of your Azure environment.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage Accounts** in the Azure Portal.
        2. Select a storage account and select the **Networking** blade.
        3. Under the **Firewalls and virtual networks** section, review the **Default action**.
        4. Ensure the Default action is set to **Deny**. This setting should block all access unless explicitly allowed by other network rules.

        **Automated Audit with Azure CLI:**

        Use the Azure CLI to verify the default network access rule for all storage accounts:

        ```bash
        az storage account list --query "[].{AccountName: name, DefaultAction: networkRuleSet.defaultAction}" -o table
        ```

        This command lists each storage account along with the default action. Verify that all entries show "Deny" as the default action.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log into the Azure Portal and navigate to **Storage Accounts**.
            2. Select the storage account you wish to configure.
            3. Select the **Networking** blade.
            4. Navigate to the **Firewalls and virtual networks** section.
            5. Set the **Default action** to **Deny**.
            6. Save your changes to enforce that all unrecognized network traffic is blocked by default.
        - id: cli
          desc: |
            **Using Azure CLI**

            To set the default network access rule to "Deny" for a new storage account, use the following Azure CLI command:

            ```bash
            az storage account create --name <StorageAccountName> --resource-group <ResourceGroupName> --location <Location> --default-action Deny
            ```

            This command updates the storage account to deny all traffic by default, significantly enhancing the security posture by limiting access to only configured exceptions.
        - id: powershell
          desc: |
            **Using PowerShell**

            To set the default network access rule to "Deny" for a new storage account, use the following PowerShell command:

            ```powershell
            New-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> -Location <Location> -SkuName Standard_LRS -Kind StorageV2 -DefaultAction Deny
            ```

            This command updates the storage account to deny all traffic by default, significantly enhancing the security posture by limiting access to only configured exceptions.
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Ensure the `default_action` is set to `Deny`

            resource "azurerm_storage_account_network_rules" "example_storage_account" {
              resource_group_name  = azurerm_resource_group.example.name
              storage_account_name = azure_storage_account.example.name

              default_action       = "Deny"
            }
            ```

            ```hcl
            resource "azurerm_storage_account" "example_storage_account" {
              name                = "example_storage_account"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location

              network_rules {
                default_action = "Deny"
              }

              ...
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/storage-security-guide
        title: Azure Storage Security Guide
  - uid: mondoo-azure-security-trusted-microsoft-services-enabled-for-storage-account-access
    title: Ensure "Trusted Microsoft Services" have access to Azure storage accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-7
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties.NetworkRuleSet.bypass.contains("AzureServices")
      azure.subscription.storage.account.properties.NetworkRuleSet.defaultAction == "Deny"
    docs:
      desc: |
        This check ensures that "Trusted Microsoft Services" is enabled for storage account access.

        **Why this matters**

        Allowing trusted Microsoft services to access storage accounts provides several benefits:

        - **Operational functionality**: Certain Azure services, such as Azure Backup, Azure Site Recovery, Azure Monitor, and Azure Event Grid, require access to storage accounts to function properly. Enabling this setting ensures these services can operate without interruptions.
        - **Enhanced security**: Access is granted securely using strong authentication mechanisms, reducing the risk of unauthorized access.
        - **Compliance alignment**: Many security standards recommend limiting access to trusted services to maintain a secure environment.
        - **Reduced complexity**: This setting simplifies network configurations by allowing trusted services to bypass network rules without compromising security.

        By enabling this setting, organizations can maintain both functionality and security for Azure storage accounts, ensuring seamless integration with essential Azure services while minimizing potential risks.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage Accounts** in the Azure Portal.
        2. Select a specific storage account.
        3. Go to the **Networking** blade.
        4. Under the **Firewalls and virtual networks** section, check if the option **Allow Azure services on the trusted services list to access this storage account** is enabled.

        **Automated Audit with Azure CLI:**

        List the network rules for all storage accounts and verify that AzureServices is included in the bypass list:

        ```bash
        az storage account list --query "[*].{AccountName:name, BypassRules:networkRuleSet.bypass}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage Accounts** in the Azure Portal.
            2. Select the storage account you want to configure.
            3. Go to the **Networking** blade.
            4. Under the **Firewalls and virtual networks** section, check the box for **Allow Azure services on the trusted services list to access this storage account**.
            5. Save your changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Enable trusted Microsoft services for a storage account:

            ```bash
            az storage account update --name <StorageAccountName> --resource-group <ResourceGroupName> --bypass AzureServices
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzStorageAccount -Name <StorageAccountName> -ResourceGroupName <ResourceGroupName> -NetworkRuleSetBypass AzureServices
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
                ...
              network_rules {
                ...
                bypass = ["AzureServices"]
                ...
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/storage-security-guide
        title: Azure Storage Security Guide
  - uid: mondoo-azure-security-ensure-auditing-retention-greater-than-30-days
    title: Ensure minimum 30-Day retention for SQL server Audit Logs
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure-sql-server"
    mql: |
      azure.subscription.sql.server.auditingPolicy.state == "Enabled"
      azure.subscription.sql.server.auditingPolicy.retentionDays >= 30 ||
       azure.subscription.sql.server.auditingPolicy.retentionDays == 0
    docs:
      desc: |
        This check ensures that Azure SQL servers have an audit log retention policy set to at least 30 days.

        **Why this matters**

        Maintaining audit logs for an extended period is crucial for compliance and security analysis:

        - **Compliance requirements**: Many regulatory standards mandate retaining audit logs for a minimum duration to ensure traceability and accountability.
        - **Security incident analysis**: Historical audit logs help identify patterns and investigate potential security threats or breaches over time.
        - **Operational integrity**: Retaining logs for at least 30 days ensures that organizations have sufficient data to analyze and address operational anomalies.
        - **Forensic investigations**: Extended retention periods provide critical data for forensic investigations in the event of a security incident.

        By enforcing a minimum retention policy of 30 days, this check helps organizations comply with regulatory requirements, enhance their security posture, and maintain operational resilience.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **SQL servers** in the Azure Portal.
        2. Select a server and select **Auditing** under the **Security** settings.
        3. Check if the **Retention (days)** is set to 30 or more.

        **Automated Audit with Azure CLI:**

        Retrieve the audit retention settings for all SQL servers:

        ```bash
        az sql server list --query "[].{ServerName:name, RetentionDays:auditingSettings.retentionDays}" -o table
        ```

        Ensure that each server listed has a retention period of 30 days or more.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **SQL servers** in the Azure Portal.
            2. Select the SQL server you want to configure.
            3. Go to **Auditing** under the **Security** section.
            4. Set the **Retention (days)** to at least 30 days, or use '0' for unlimited retention.
            5. Select **Save** to apply the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Update the audit retention policy for a specific SQL server:

            ```bash
            az sql db audit-policy update --name <DatabaseName> --resource-group <ResourceGroupName> --retention-days 30
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzSqlDatabaseAuditingPolicy -ResourceGroupName <ResourceGroupName> -ServerName <ServerName> -DatabaseName <DatabaseName> -RetentionDays 30
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_sql_server" "example" {
              ...
              extended_auditing_policy {
                storage_endpoint           = azure_storage_account.example.primary_blob_endpoint
                storage_account_access_key = azure_storage_account.example.primary_access_key
                storage_account_access_key_is_secondary = true
                retention_in_days                       = 30
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/security-overview
        title: Azure SQL Database Security
  - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0
    title: Ensure no SQL Databases allow ingress 0.0.0.0/0 (ANY IP)
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    variants:
      - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0-single-azuresql
        tags:
          mondoo.com/filter-title: "Azure SQL Database"
          mondoo.com/icon: "azure"
      - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0-single-postgresql-flexible
        tags:
          mondoo.com/filter-title: "Azure PostgreSQL Flexible Server"
          mondoo.com/icon: "azure"
      - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0-single-mysql-flexible
        tags:
          mondoo.com/filter-title: "Azure MySQL Flexible Server"
          mondoo.com/icon: "azure"
    docs:
      desc: |
        This check ensures that SQL databases across various platforms (Azure SQL, PostgreSQL, MySQL) do not permit unrestricted network access by blocking ingress from the IP address range "0.0.0.0/0".

        **Why this matters**

        Allowing unrestricted network access to SQL databases can lead to significant security risks:

        - **Unauthorized access**: Open access from "0.0.0.0/0" allows any IP address to connect, increasing the likelihood of unauthorized access.
        - **Increased attack surface**: Exposing databases to the internet unnecessarily expands the attack surface, making it easier for attackers to exploit vulnerabilities.
        - **Compliance risks**: Many security standards and best practices recommend restricting access to sensitive resources to reduce potential threats.
        - **Operational risks**: Misconfigured or exposed databases can lead to unintended access, data breaches, or service disruptions.

        By ensuring that ingress from "0.0.0.0/0" is blocked, this check helps to minimize security vulnerabilities, align with best practices, and enhance the overall security posture of Azure environments.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **SQL servers** in the Azure Portal.
        2. Select a specific SQL server.
        3. Under the **Settings** section, select **Firewall and virtual networks**.
        4. Review the **Firewall rules** section.
        5. Ensure that there are no rules allowing ingress from ""0.0.0.0/0"

        **Automated Audit with Azure CLI:**

        List the firewall rules for all SQL servers and verify that none allow ingress from "0.0.0.0/0":

        ```bash
        az sql server firewall-rule list --server <server-name> --resource-group <resource-group> --query "[?startIpAddress=='0.0.0.0'].{Name:name, StartIP:startIpAddress}"
        az postgres server firewall-rule list --server <server-name> --resource-group <resource-group> --query "[?startIpAddress=='0.0.0.0'].{Name:name, StartIP:startIpAddress}"
        az mysql server firewall-rule list --server <server-name> --resource-group <resource-group> --query "[?startIpAddress=='0.0.0.0'].{Name:name, StartIP:startIpAddress}"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **SQL servers** in the Azure Portal.
            2. Select the SQL server you want to configure.
            3. Go to **Firewall and virtual networks** under the **Settings** section.
            4. Review the **Firewall rules** and remove any rules allowing ingress from "0.0.0.0/0".
            5. Preferably, create new rules that restrict access to specific IP ranges or virtual networks.
            6. Save your changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Ensure that the start and end IP addresses in the firewall rules are set to secure IPs within your controlled network range, effectively blocking public access.

            ```bash
            # Replace <server-name>, <resource-group>, and <rule-name> with your specific details

            # Azure SQL
            az sql server firewall-rule create --resource-group <resource-group> --server <server-name> --name <rule-name> --start-ip-address <secure-start-ip> --end-ip-address <secure-end-ip>

            # PostgreSQL
            az postgres server firewall-rule create --resource-group <resource-group> --server <server-name> --name <rule-name> --start-ip-address <secure-start-ip> --end-ip-address <secure-end-ip>

            # MySQL
            az mysql server firewall-rule create --resource-group <resource-group> --server <server-name> --name <rule-name> --start-ip-address <secure-start-ip> --end-ip-address <secure-end-ip>

            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            # Replace <server-name>, <resource-group>, and <rule-name> with your specific details

            # Azure SQL
            New-AzSqlServerFirewallRule -ResourceGroupName <resource-group> -ServerName <server-name> -FirewallRuleName <rule-name> -StartIpAddress <secure-start-ip> -EndIpAddress <secure-end-ip>

            # PostgreSQL
            New-AzPostgreSqlServerFirewallRule -ResourceGroupName <resource-group> -ServerName <server-name> -FirewallRuleName <rule-name> -StartIpAddress <secure-start-ip> -EndIpAddress <secure-end-ip>

            # MySQL
            New-AzMySqlServerFirewallRule -ResourceGroupName <resource-group> -ServerName <server-name> -FirewallRuleName <rule-name> -StartIpAddress <secure-start-ip> -EndIpAddress <secure-end-ip>

            ```
        - id: terraform
          desc: |
            **Using Terraform**

            __mySQL__

            ```hcl
            # Ensure `start_ip_address` is not configured to `0.0.0.0`

            resource "azurerm_mysql_firewall_rule" "example" {
              ...
              start_ip_address    = "192.168.2.22"
              end_ip_address      = "255.255.255.255"
            }
            ```

            __SQL__

            ```hcl
            # Ensure `start_ip_address` is not configured to `0.0.0.0`

            resource "azurerm_sql_firewall_rule" "example" {
              ...
              start_ip_address    = "192.168.2.22"
              end_ip_address      = "255.255.255.255"
            }
            ```

            __Postgres__

            ```hcl
            # Ensure `start_ip_address` is not configured to `0.0.0.0`

            resource "azurerm_postgresql_firewall_rule" "example" {
              ...
              start_ip_address    = "192.168.2.22"
              end_ip_address      = "255.255.255.255"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/security-overview
        title: Azure SQL Database Security
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0-single-azuresql
    filters: |
      asset.platform == "azure-sql-server"
    mql: |
      azure.subscription.sql.server.firewallRules.all(startIpAddress != "0.0.0.0")
  - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0-single-postgresql-flexible
    filters: |
      asset.platform == "azure-postgresql-flexible-server"
    mql: |
      azure.subscription.postgreSql.flexibleServer.firewallRules.all(startIpAddress != "0.0.0.0")
  - uid: mondoo-azure-security-no-sql-databases-allow-ingress-0-0-0-0-0-single-mysql-flexible
    filters: |
      asset.platform == "azure-mysql-flexible-server"
    mql: |
      azure.subscription.mySql.flexibleServer.firewallRules.all(startIpAddress != "0.0.0.0")
  - uid: mondoo-azure-security-ensure-register-with-ad-is-enabled-on-app-service
    title: Enable Managed Identities for App services to Authenticate via Microsoft Entra ID
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-8
      compliance/iso-27001-2022: iso-27001-2022-a-8-5
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(identity.type != empty)
      azure.subscription.web.apps.all(identity.principalId != empty)
    docs:
      desc: |
        This check ensures that Managed Identities are enabled for Azure App Services to securely authenticate with Microsoft Entra ID.

        **Why this matters**

        Enabling Managed Identities for Azure App Services provides several security and operational benefits:

        - **Eliminates credential storage**: Managed Identities remove the need to store sensitive credentials within the application, reducing the risk of credential theft.
        - **Streamlined authentication**: Applications can directly authenticate to Azure services like Azure SQL Database, Azure Storage, and Azure Key Vault without requiring manual credential management.
        - **Enhanced security**: Managed Identities are tied to the application and managed by Azure, ensuring secure and seamless authentication.
        - **Compliance alignment**: Many security standards recommend minimizing the use of hardcoded credentials to reduce potential attack vectors.

        By enabling Managed Identities, this check helps to enhance the security posture of Azure App Services, align with best practices, and simplify authentication workflows.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to the Azure Portal at https://portal.azure.com.
        2. Navigate to **App Services**.
        3. Select an app service and select **Identity** under **Settings**.
        4. Verify that the **Status** for **System assigned managed identity** is set to **On**.

        **Automated Audit with Azure CLI:**

        Use the Azure CLI to check if the system assigned identity is enabled for each App Service:

        ```bash
        az webapp identity show --resource-group <RESOURCE_GROUP_NAME> --name <APP_NAME> --query principalId
        ```
        If the command returns a non-null principal ID, it indicates that the managed identity is enabled. If it returns null, the managed identity is not enabled.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log in to the Azure Portal
            2. Navigate to **App Services**.
            3. Select an app service and select **Identity** under **Settings**.
            4. Set the **Status** for **System assigned managed identity** to **On**.
            5. Save your changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Enable a system-assigned managed identity for an App Service:

            ```bash
            az webapp identity assign --resource-group <RESOURCE_GROUP_NAME> --name <APP_NAME>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $app = Get-AzWebApp -ResourceGroupName <RESOURCE_GROUP_NAME> -Name <APP_NAME>
            $app.Identity.Type = "SystemAssigned"
            Set-AzWebApp -ResourceGroupName <RESOURCE_GROUP_NAME> -Name <APP_NAME> -Identity $app.Identity
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_app_service" "example" {
              name                = "example-app-service"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              app_service_plan_id = azurerm_app_service_plan.example.id

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/overview-security
        title: Azure App Service Security
      - url: https://learn.microsoft.com/en-us/entra/fundamentals/security-defaults
        title: Microsoft Entra Security Defaults
  - uid: mondoo-azure-security-ensure-the-kv-is-recoverable
    title: Ensure Key Vaults are configured with Recovery features
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-11
      compliance/iso-27001-2022: iso-27001-2022-a-8-14
    filters: |
      asset.platform == "azure-keyvault-vault"
    mql: |
      azure.subscription.keyVault.vault.properties.enablePurgeProtection == true
    docs:
      desc: |
        This check ensures that Azure Key Vaults are configured with purge protection to prevent accidental or malicious deletion of key vaults and their contents.

        **Why this matters**

        Enabling purge protection for Azure Key Vaults provides several critical security and operational benefits:

        - **Accidental deletion prevention**: Purge protection ensures that deleted key vaults cannot be permanently removed until the retention period is reached, reducing the risk of accidental data loss.
        - **Malicious deletion mitigation**: Protects against unauthorized or malicious attempts to permanently delete key vaults, ensuring that sensitive keys, secrets, and certificates remain recoverable.
        - **Compliance alignment**: Many regulatory standards and best practices recommend implementing safeguards to prevent the permanent loss of critical data.
        - **Operational resilience**: Ensures that deleted key vaults can be recovered during the retention period, minimizing disruptions to applications and services that rely on them.

        By enabling purge protection, this check helps to enhance the security posture of Azure Key Vaults, align with best practices, and ensure the availability and recoverability of critical cryptographic assets.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to the Azure Portal at https://portal.azure.com.
        2. Navigate to **Key Vaults**.
        3. Select a key vault and select **Properties**.
        4. Verify that **Purge Protection** is enabled, which ensures that deleted vaults and vault objects are recoverable during the retention period.

        **Automated Audit with Azure CLI:**

        Verify Purge Protection is enabled for each Key Vault:

        ```bash
        az keyvault list --query "[].{Name: name, PurgeProtection: properties.enablePurgeProtection}"
        ```
        Check the output for each Key Vault, ensuring that PurgeProtection is set to true.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log in to the Azure Portal at https://portal.azure.com.
            2. Navigate to **Key Vaults**.
            3. Select a key vault and select **Properties**.
            4. Scroll to the **Security** section.
            5. If **Purge Protection** is not enabled, enable it. Note that once enabled, this setting cannot be disabled.
            6. Save your changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Enable Purge Protection for a specific Key Vault:

            ```bash
            az keyvault update --name <VaultName> --resource-group <ResourceGroupName> --set properties.enablePurgeProtection=true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $vault = Get-AzKeyVault -VaultName <VaultName> -ResourceGroupName <ResourceGroupName>
            $vault.EnablePurgeProtection = $true
            Set-AzKeyVault -KeyVault $vault
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_key_vault" "example" {
              name                = "example-keyvault"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name

              purge_protection_enabled = true
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/key-vault/general/security-features
        title: Azure Key Vault Security
  - uid: mondoo-azure-security-ensure-web-app-is-using-the-latest-tls
    title: Ensure that Web Apps use the latest available version of TLS encryption
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(configuration.properties.minTlsVersion == "1.2")
    docs:
      desc: |
        This check ensures that Azure App Services use the latest available version of TLS encryption for secure Web App connections.

        **Why this matters**

        Using the latest TLS version provides several critical security benefits:

        - **Enhanced security**: TLS 1.2 offers stronger encryption algorithms and improved security features compared to older versions, reducing the risk of data breaches and unauthorized access.
        - **Compliance alignment**: Many regulatory standards and best practices require the use of up-to-date encryption protocols to protect sensitive data.
        - **Mitigation of vulnerabilities**: Older TLS versions, such as TLS 1.0 and TLS 1.1, are known to have vulnerabilities that can be exploited by attackers.
        - **Operational integrity**: Ensuring the use of the latest TLS version helps maintain secure communication channels, preventing potential disruptions caused by deprecated protocols.

        By enforcing the use of TLS 1.2, this check helps to minimize security vulnerabilities, align with compliance requirements, and enhance the overall security posture of Azure App Services.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to the Azure Portal at https://portal.azure.com.
        2. Navigate to **App Services**.
        3. Select an app service and select **TLS/SSL settings** under **Settings**.
        4. Verify that the **Minimum TLS Version** is set to **1.2**.

        **Automated Audit with Azure CLI:**

        Verify that the minimum TLS version is set to 1.2 for each App Service:

        ```bash
        az webapp config show --resource-group <RESOURCE_GROUP_NAME> --name <APP_NAME> --query minTlsVersion
        ```

        **Automated Audit with PowerShell:**

        Get-AzWebApp | foreach {
          Get-AzWebApp -ResourceGroupName $_.ResourceGroup -Name $_.Name | Select-Object Name, ResourceGroup, @{Name="TLS Version"; Expression={$_.SiteConfig.MinTlsVersion}}
        }
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To update using Microsoft Azure Portal:
            1. Log into Microsoft Azure Portal at https://portal.azure.com
            2. Go to **App Services**.
            3. For each app:
              a. Select the app.
              b. Select **TLS/SSL settings** under **Settings**.
              c. Under **Minimum TLS Version**, select **1.2**.
              d. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            To set the minimum TLS version to 1.2 for a new app service:

            ```bash
            az webapp create --name <APP_NAME> --resource-group <RESOURCE_GROUP_NAME> --plan <APP_SERVICE_PLAN> --min-tls-version 1.2
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            Get-AzWebApp | foreach {
              Set-AzWebApp -ResourceGroupName $_.ResourceGroup -Name $_.Name -MinTlsVersion "1.2"
            }
        - id: terraform
          desc: |
            **Using Terraform**

            To set the minimum TLS version to 1.2 for an app service:

            ```hcl
            resource "azurerm_app_service" "example" {
              name                = "example-app-service"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              app_service_plan_id = azurerm_app_service_plan.example.id

              site_config {
                min_tls_version = "1.2"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/overview-security
        title: Azure App Service Security
  - uid: mondoo-azure-security-ensure-the-expiration-date-is-set-for-all-keys-and-secrets-in-kv
    title: Ensure that the expiration date is set for all keys and secrets in key vaults
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-9
      compliance/iso-27001-2022: iso-27001-2022-a-5-17
    filters: |
      asset.platform == "azure-keyvault-vault"
    mql: |
      azure.subscription.keyVault.vault.keys.where(enabled == true).all(expires != empty)
      azure.subscription.keyVault.vault.secrets.where(enabled == true).all(expires != empty)
    docs:
      desc: |
        This check ensures that expiration dates are set for all keys and secrets in Azure Key Vaults to enforce proper key rotation and prevent the use of expired cryptographic materials.

        **Why this matters**

        Setting expiration dates for keys and secrets provides several critical benefits:

        - **Enhanced security**: Expiration dates enforce key rotation, reducing the risk of compromised or outdated cryptographic materials being used.
        - **Compliance alignment**: Many security standards and best practices require periodic key rotation and the use of expiration dates to meet regulatory requirements.
        - **Operational integrity**: Expired keys and secrets can disrupt applications and services. Setting expiration dates ensures proactive management and renewal of cryptographic materials.
        - **Risk mitigation**: Prevents the indefinite use of keys and secrets, reducing the likelihood of unauthorized access or data breaches.

        By ensuring that expiration dates are set, this check helps to enhance the security posture of Azure Key Vaults, align with compliance requirements, and maintain operational resilience.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Key Vaults** via the Azure Portal at https://portal.azure.com.
        2. Select a key vault and then select **Keys** or **Secrets**.
        3. Check each key and secret to verify that an expiration date is set and is appropriate.

        **Automated Audit with Azure CLI:**

        - For keys:

          ```bash
          az keyvault key list --vault-name <KeyVaultName> --query "[?attributes.expires && attributes.enabled == \`true\`].{name: name, expires: attributes.expires}" -o table
          ```

        - For secrets:

          ```bash
          az keyvault secret list --vault-name <KeyVaultName> --query "[?attributes.expires && attributes.enabled == \`true\`].{name: name, expires: attributes.expires}" -o table
          ```

        **Automated Audit with PowerShell:**

        - For keys:

          ```powershell
          Get-AzKeyVaultKey -VaultName <VaultName> | Where-Object {$_.Enabled -eq $true -and $_.Expires -ne $null}
          ```

        - For secrets:

          ```powershell
          Get-AzKeyVaultSecret -VaultName <VaultName> | Where-Object {$_.Enabled -eq $true -and $_.Expires -ne $null}
          ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log into Microsoft Azure Portal at https://portal.azure.com.
            2. Go to **Key vaults**.
            3. For each key vault:
               a. Select the key vault.
               b. Select **Keys** or **Secrets**.
               c. For each key/secret, set an expiration date.
        - id: cli
          desc: |
            **Using Azure CLI**

            To set an expiration date for a key or secret in a key vault:

            - For keys:

              ```bash
              az keyvault key set-attributes --vault-name <VaultName> --name <KeyName> --expires <DateTime-in-ISO8601>
              ```

            - For secrets:

              ```bash
              az keyvault secret set-attributes --vault-name <VaultName> --name <SecretName> --expires <DateTime-in-ISO8601>
              ```
        - id: powershell
          desc: |
            **Using PowerShell**

            To set an expiration date for a key or secret in a key vault:

            - For keys:

              ```powershell
              $key = Get-AzKeyVaultKey -VaultName <VaultName> -Name <KeyName>
              $key.Expires = (Get-Date).AddYears(1)
              Update-AzKeyVaultKey -VaultName <VaultName> -Key $key
              ```

            - For secrets:

              ```powershell
              $secret = Get-AzKeyVaultSecret -VaultName <VaultName> -Name <SecretName>
              $secret.Expires = (Get-Date).AddYears(1)
              Update-AzKeyVaultSecret -VaultName <VaultName> -Secret $secret
              ```
        - id: terraform
          desc: |
            **Using Terraform**

            To set an expiration date for a key or secret in a key vault:

            ```hcl
            resource "azurerm_key_vault_key" "example" {
              name         = "example-key"
              key_vault_id = azurerm_key_vault.example.id
              key_type     = "RSA"
              key_size     = 2048
              expiration_date = "2027-05-01T01:02:03Z"

              key_opts = [
                "decrypt",
                "encrypt",
                "sign",
                "unwrapKey",
                "verify",
                "wrapKey",
              ]
            }

            resource "azurerm_key_vault_secret" "example" {
              name         = "example-secret"
              value        = "exampleValue"
              key_vault_id = azurerm_key_vault.example.id
              expiration_date = "2027-05-01T01:02:03Z"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/key-vault/general/security-features
        title: Azure Key Vault Security
  - uid: mondoo-azure-security-ensure-logging-enabled-kv
    title: Ensure all operations in Azure Key Vault are logged
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure-keyvault-vault"
    mql: |
      azure.subscription.keyVault.vault.diagnosticSettings.any(properties.logs.where(categoryGroup == "audit").any(enabled == true))
      azure.subscription.keyVault.vault.diagnosticSettings.any(properties.logs.where(categoryGroup == "allLogs").any(enabled == true))
    docs:
      desc: |
        This check ensures that all operations in Azure Key Vault are logged to provide a comprehensive audit trail for security and compliance purposes.

        **Why this matters**

        Monitoring interactions with Azure Key Vault is critical for maintaining security and compliance:

        - **Unauthorized access detection**: Logging operations allow organizations to audit access and use of keys, secrets, and certificates, ensuring that any unauthorized access or anomalies are detected and addressed.
        - **Compliance alignment**: Many regulatory standards and best practices require detailed logging of access to sensitive resources like Key Vault.
        - **Operational integrity**: Logs provide insights into the usage patterns of Key Vault, helping to identify misconfigurations or potential misuse.
        - **Incident response**: In the event of a security incident, logs serve as a critical resource for forensic investigations and root cause analysis.

        By enabling logging for Azure Key Vault, this check helps to enhance security, align with compliance requirements, and maintain operational resilience.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to the Azure Portal at https://portal.azure.com.
        2. Go to **Key Vaults** and select a Key Vault.
        3. Under **Monitoring**, select **Diagnostic settings**.
        4. Verify that logging for both **audit** and **allLogs** categories are enabled and that they are configured to send logs to an Azure Storage Account, Log Analytics workspace, or Event Hub.

        **Automated Audit with Azure CLI:**

        Retrieve the diagnostic settings for each Key Vault to ensure that logging is enabled:

        ```bash
        az monitor diagnostic-settings list --resource <Key Vault Resource ID> --output table
        ```

        Ensure that the output shows that logs for audit and allLogs categories are enabled and properly configured to a storage account or other supported destinations.

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzKeyVault | ForEach-Object {
            Get-AzDiagnosticSetting -ResourceId $_.ResourceId
        }
        ```
        Verify that each Key Vault has audit and allLogs enabled and is logging to the designated destinations.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log into Microsoft Azure Portal at https://portal.azure.com.
            2. Navigate to **Key Vaults**.
            3. Select a Key Vault and go to **Diagnostic settings**.
            4. Click on **Add diagnostic setting** or edit an existing one.
            5. Ensure that both **audit** and **allLogs** categories are selected.
            6. Choose the appropriate destination for logs (e.g., Storage Account, Log Analytics workspace).
            7. Save the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            To create or update diagnostic settings for a Key Vault:

            ```bash
            az monitor diagnostic-settings create --name "defaultLogs" --resource <Key Vault Resource ID> --logs '[{"category": "audit", "enabled": true}, {"category": "allLogs", "enabled": true}]' --storage-account <Storage Account ID> | --workspace <Log Analytics Workspace ID> | --event-hub <Event Hub Name>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            To create or update diagnostic settings for a Key Vault:

            ```powershell
            $logs = @(
                New-AzDiagnosticSettingLogConfig -Category "audit" -Enabled $true
                New-AzDiagnosticSettingLogConfig -Category "allLogs" -Enabled $true
            )
            Set-AzDiagnosticSetting -ResourceId <Key Vault Resource ID> -Log $logs -StorageAccountId <Storage Account ID> | -WorkspaceId <Log Analytics Workspace ID> | -EventHubAuthorizationRuleId <Event Hub Authorization Rule ID> | -EventHubName <Event Hub Name>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            To create or update diagnostic settings for a Key Vault:

            ```hcl
            resource "azurerm_monitor_diagnostic_setting" "example" {
              name               = "kv-logging"
              target_resource_id = azurerm_key_vault.example.id
              log_analytics_workspace_id = azurerm_log_analytics_workspace.example.id

              log {
                category = "audit"
                enabled  = true

                retention_policy {
                  enabled = true
                  days    = 0
                }
              }

              log {
                category = "allLogs"
                enabled  = true

                retention_policy {
                  enabled = true
                  days    = 0
                }
              }

              metric {
                category = "AllMetrics"
                enabled  = false

                retention_policy {
                  enabled = false
                  days    = 0
                }
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/key-vault/general/security-features
        title: Azure Key Vault Security
  - uid: mondoo-azure-security-ensure-activity-log-alert-exists-for-create-update-delete-network-security-group
    title: Ensure that activity log alerts exist for the commands Create, Update, and Delete Network Security Group
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.monitor.activityLog.alerts.where(actions != empty).any(conditions.any(equals == "Microsoft.Network/networkSecurityGroups/write" && fieldName == "operationName"))
      azure.subscription.monitor.activityLog.alerts.where(actions != empty).any(conditions.any(equals == "Microsoft.Network/networkSecurityGroups/delete" && fieldName == "operationName"))
    docs:
      desc: |
        This check ensures that activity log alerts are configured for the creation, update, and deletion of network security groups to monitor changes and detect suspicious activities.

        **Why this matters**

        Monitoring activity log alerts for network security group changes provides several critical benefits:

        - **Unauthorized access detection**: Alerts help identify unauthorized or unexpected changes to network security groups, which could indicate a potential security breach.
        - **Increased visibility**: Tracking changes to network security groups ensures that administrators are aware of modifications that could impact the security posture of the environment.
        - **Compliance alignment**: Many security standards and best practices require monitoring and alerting on changes to critical network configurations.
        - **Operational integrity**: Detecting and responding to unauthorized changes helps maintain the intended security and operational state of the network.

        By ensuring activity log alerts are configured for these events, this check helps to enhance security monitoring, align with compliance requirements, and maintain the overall security posture of Azure environments.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to the `Monitor` blade.
        2. Select `Alerts`.
        3. In the Alerts window, select `Alert rules`.
        4. Verify that alert rules exist for the following conditions:
          - Operation name equals `Microsoft.Network/networkSecurityGroups/write` for Create/Update events.
          - Operation name equals `Microsoft.Network/networkSecurityGroups/delete` for Delete events.
        5. Select the alert rule name to review its configuration.
          - Ensure the `Condition` panel specifies the correct operation names and does not filter on irrelevant criteria like `Level`, `Status`, or `Caller`.
          - Confirm that the `Actions` panel is set up to notify the appropriate personnel within your organization.

        **Automated Audit with Azure CLI:**

        Run the following commands to list the current alert rules and verify their conditions:

        ```bash
        az monitor activity-log alert list --subscription <subscription ID> --query "[].{Name:name, Enabled:enabled, Condition:condition.allOf, Actions:actions}"
        ```

        Check for the presence of conditions targeting the `Microsoft.Network/networkSecurityGroups/write` and `Microsoft.Network/networkSecurityGroups/delete` operation names in the output.

        **Using PowerShell**

        Utilize the following PowerShell commands to inspect the alert rules:

        ```powershell
        Get-AzActivityLogAlert -SubscriptionId <subscription ID> | where-object {$_.ConditionAllOf.Equal -match "Microsoft.Network/networkSecurityGroups/write"} | select-object Location, Name, Enabled, ResourceGroupName, ConditionAllOf

        Get-AzActivityLogAlert -SubscriptionId <subscription ID> | where-object {$_.ConditionAllOf.Equal -match "Microsoft.Network/networkSecurityGroups/delete"} | select-object Location, Name, Enabled, ResourceGroupName, ConditionAllOf
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To create or update activity log alerts in Microsoft Azure Portal:

            1. Log into Microsoft Azure Portal at https://portal.azure.com.
            2. Go to **Monitor**.
            3. Select **Alerts**.
            4. Select **+ Create**.
            5. Under **Resource types**, select **Activity Log**.
            6. Select the subscription name, resource group, or network security group to apply the rule to.
            7. Verify that the selection preview shows:
                - All network security groups or your selected network security group
                - The subscription, group, or resource you selected
            8. Select the **Apply** button.
            9. Select the **Condition** tab and select **See all signals**.
            10. Select **Create or Update Network Security Group**.
            11. Select the **Actions** tab and either choose an existing action group or create a new one to notify the necessary personnel.
            12. Select the **Details** tab and provide:
                - The resource group where you want the alert rule to reside
                - A name (and optional description) for the alert rule
            13. Select the **Review + create button and verify the summary.
            14. Select the **Create** button.
        - id: cli
          desc: |
            **Using Azure CLI**

            To create an activity log alert for network security group changes:

            ```bash
            az monitor activity-log alert create --name <AlertName> --resource-group <ResourceGroupName> --scopes <ResourceID> --condition "category == 'Administrative' and operationName == 'Microsoft.Network/networkSecurityGroups/write'" --action-group <ActionGroupID>
            ```

            To create an activity log alert for network security group deletions:

            ```bash
            az monitor activity-log alert create --name <AlertName> --resource-group <ResourceGroupName> --scopes <ResourceID> --condition "category == 'Administrative' and operationName == 'Microsoft.Network/networkSecurityGroups/delete'" --action-group <ActionGroupID>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            To create an activity log alert for network security group changes:

            ```powershell
            New-AzActivityLogAlert -Name <AlertName> -ResourceGroupName <ResourceGroupName> -Location <Location> -Condition "category == 'Administrative' and operationName == 'Microsoft.Network/networkSecurityGroups/write'" -ActionGroupId <ActionGroupID>
            ```

            To create an activity log alert for network security group deletions:

            ```powershell
            New-AzActivityLogAlert -Name <AlertName> -ResourceGroupName <ResourceGroupName> -Location <Location> -Condition "category == 'Administrative' and operationName == 'Microsoft.Network/networkSecurityGroups/delete'" -ActionGroupId <ActionGroupID>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            To create an activity log alert for network security group changes:

            ```hcl
            resource "azurerm_monitor_activity_log_alert" "example" {
              name                = "example-alert"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location

              scopes = [
                azurerm_network_security_group.example.id,
              ]

              criteria {
                category = "Administrative"
                operation_name = "Microsoft.Network/networkSecurityGroups/write"
              }

              action {
                action_group_id = azurerm_monitor_action_group.example.id
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-monitor/best-practices
        title: Azure Monitor Best Practices
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-ensure-that-notify-about-alerts-with-high-severity-is-on
    title: Ensure that "Notify about alerts with high severity" is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.securityContacts.all(notificationSources.Alert.minimalSeverity.in(["High","Medium","Low"]))
      azure.subscription.cloudDefender.securityContacts.all(notificationSources.Alert.state == "On")
    docs:
      desc: |
        This check ensures that security alert email notifications are enabled to promptly inform administrators of potential security issues.

        **Why this matters**

        Enabling security alert email notifications provides several critical benefits:

        - **Timely response**: Alerts ensure that administrators are immediately informed of potential security issues, enabling quick action to mitigate risks.
        - **Enhanced visibility**: Notifications provide real-time insights into security events, helping organizations stay aware of their security posture.
        - **Compliance alignment**: Many security standards and best practices recommend enabling alert notifications to ensure proactive monitoring and response.
        - **Operational resilience**: Early detection and response to security issues help prevent potential disruptions and maintain the integrity of the environment.

        By enabling security alert email notifications, this check helps to enhance security monitoring, align with compliance requirements, and improve the overall security posture of the organization.
      audit: |
        **Manual Audit via Azure Portal:**

          1. From Azure Home, select the Portal Menu.
          2. Select `Microsoft Defender for Cloud`.
          3. Select `Environment Settings`.
          4. Select the appropriate Management Group, Subscription, or Workspace.
          5. Select `Email notifications`.
          6. Verify that the `Notify about alerts with the following severity (or higher):` setting is checked and set to `High`.

        **Automated Audit with Azure CLI:**

          Run the following command to check the notification settings for high severity alerts. Make sure the output is set to `true`, indicating that notifications for high severity alerts are enabled.

          ```bash
          az account get-access-token --query "{subscription:subscription,accessToken:accessToken}" --out tsv | xargs -L1 bash -c 'curl -X GET -H "Authorization: Bearer $1" -H "Content-Type: application/json" https://management.azure.com/subscriptions/$0/providers/Microsoft.Security/securityContacts?api-version=2020-01-01-preview' | jq '.|.[] | select(.name=="default")'|jq '.properties.alertNotifications'
          ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To enable high severity alert notifications in Microsoft Azure Portal:

              1. Log into Microsoft Azure Portal at https://portal.azure.com.
              2. Select `Microsoft Defender for Cloud` from the Portal Menu.
              3. Go to `Environment Settings` and select the appropriate management group, subscription, or workspace.
              4. Navigate to `Email notifications`.
              5. Ensure the `Notify about alerts with the following severity (or higher):` option is enabled and set to `High`.
              6. Select `Save` to apply the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            Use the following command to update the security contact settings to enable high severity alert notifications. Replace `<Your_Subscription_Id>` and `<validEmailAddress>` with the appropriate values.

              ```bash
              az account get-access-token --query "{subscription:subscription,accessToken:accessToken}" --out tsv | xargs -L1 bash -c 'curl -X PUT -H "Authorization: Bearer $1" -H "Content-Type: application/json" https://management.azure.com/subscriptions/<$0>/providers/Microsoft.Security/securityContacts/default1?api-version=2017-08-01-preview -d "@input.json"'
              ```

              Ensure the `input.json` file contains the following data, with `<validEmailAddress>` replaced with your contact email:

              ```json
              {
                "id": "/subscriptions/<Your_Subscription_Id>/providers/Microsoft.Security/securityContacts/default1",
                "name": "default1",
                "type": "Microsoft.Security/securityContacts",
                "properties": {
                  "email": "<validEmailAddress>",
                  "alertNotifications": "On",
                  "alertsToAdmins": "On"
                }
              }
              ```
        - id: powershell
          desc: |
            **Using PowerShell**

            To enable high severity alert notifications, use the following PowerShell command. Replace `<Your_Subscription_Id>` and `<validEmailAddress>` with the appropriate values.

              ```powershell
              $securityContact = @{
                id = "/subscriptions/<Your_Subscription_Id>/providers/Microsoft.Security/securityContacts/default1"
                name = "default1"
                type = "Microsoft.Security/securityContacts"
                properties = @{
                  email = "<validEmailAddress>"
                  alertNotifications = "On"
                  alertsToAdmins = "On"
                }
              }
              New-AzSecurityContact -SecurityContact $securityContact
              ```
        - id: terraform
          desc: |
            **Using Terraform**

            To enable high severity alert notifications, use the following Terraform configuration. Replace `<Your_Subscription_Id>` and `<validEmailAddress>` with the appropriate values.

            ```hcl
            resource "azurerm_security_contact" "example" {
              name  = "default1"
              email = "<validEmailAddress>"
              alert_notifications = "On"
              alerts_to_admins = "On"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/overview
        title: Azure Security Fundamentals
  - uid: mondoo-azure-security-ensure-that-ssl-enabled-postgresql
    title: Ensure SSL connection enabled for PostgreSQL database servers
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-postgresql-flexible-server"
    mql: |
      // TLS/SSL is enforced on the server by default.
      azure.subscription.postgreSql.flexibleServer.configuration.where(name == 'require_secure_transport').all(value.downcase == "on")
    docs:
      desc: |
        This check ensures that SSL/TLS is enforced for all connections to PostgreSQL database servers to safeguard data in transit.

        **Why this matters**

        Enforcing SSL/TLS connections for PostgreSQL database servers provides several critical benefits:

        - **Data protection**: Encrypting data in transit prevents eavesdropping and man-in-the-middle attacks, ensuring the confidentiality and integrity of sensitive information.
        - **Compliance alignment**: Many security standards and best practices mandate the use of secure communication protocols to protect data in transit.
        - **Mitigation of risks**: Disabling unencrypted connections reduces the risk of unauthorized access and data breaches.
        - **Operational integrity**: Ensuring secure connections helps maintain the trustworthiness and reliability of database operations.

        By enforcing SSL/TLS connections, this check helps to minimize security vulnerabilities, align with compliance requirements, and enhance the overall security posture of PostgreSQL database servers.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to Azure Portal at https://portal.azure.com.
        2. Navigate to `Azure Database for PostgreSQL server`.
        3. Select each database server to review its settings.
        4. Under `Connection security`, confirm that `Enforce SSL connection` is set to `ENABLED`. This setting should be consistent across all PostgreSQL database servers to ensure uniform security posture.

        **Automated Audit with Azure CLI:**

        To verify the SSL enforcement setting across all PostgreSQL servers in a resource group, you can use the Azure CLI. The expected output for compliant servers is `Enabled`:

        ```bash
        az postgres server list --resource-group <resourceGroupName> --query "[].{Name:name, SSL:sslEnforcement}" -o table
        ```

        This command provides a clear, tabulated output indicating which servers have SSL enforced and which do not, enabling quick identification of non-compliant resources.

        **Using PowerShell**

        PowerShell can also be used for a detailed audit. The command should return `Enabled` for each server checked:

        ```powershell
        Get-AzPostgreSqlServer -ResourceGroupName <ResourceGroupName> | Select-Object Name, SslEnforcement
        ```

        This command lists all PostgreSQL servers in the specified resource group along with their SSL enforcement status, providing a comprehensive overview.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To enforce SSL connections:

            1. Access the Azure Portal at https://portal.azure.com.
            2. Navigate to `Azure Database for PostgreSQL server`.
            3. For each server, access `Connection security`.
            4. Locate the `SSL settings` and set `Enforce SSL connection` to `ENABLED`.
            5. Apply the changes to ensure that the setting is enforced across all servers.

            Consistency in enforcement is key. Verify that all PostgreSQL servers within your Azure environment have this setting enabled to maintain a high security standard.
        - id: cli
          desc: |
            **Using Azure CLI**

            For a batch update or to automate the enforcement across multiple servers, use the Azure CLI:

            ```bash
            az postgres server update --resource-group <resourceGroupName> --name <serverName> --ssl-enforcement Enabled
            ```

            Automate this process using scripts to iterate over all PostgreSQL servers in a subscription or resource group, ensuring no server is left without SSL enforcement.
        - id: powershell
          desc: |
            **Using PowerShell**

            To enforce SSL connections across all PostgreSQL servers in a resource group, you can use the following PowerShell script:

            ```powershell
            $servers = Get-AzPostgreSqlServer -ResourceGroupName <ResourceGroupName>
            foreach ($server in $servers) {
                Set-AzPostgreSqlServer -ResourceGroupName <ResourceGroupName> -ServerName $server.Name -SslEnforcement Enabled
            }
            ```

            This script iterates over all PostgreSQL servers in the specified resource group and sets SSL enforcement to `Enabled`. Regularly running such scripts can help maintain compliance over time, especially in dynamic environments where new servers are frequently deployed.
        - id: terraform
          desc: |
            **Using Terraform**

            To enforce SSL connections for PostgreSQL servers, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_postgresql_server" "example" {
              name                = "example-postgresql-server"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              version             = "11"
              ssl_enforcement     = "Enabled"

              storage_mb         = 5120
              sku {
                name     = "B_Gen5_1"
                tier     = "Basic"
                capacity = 1
              }
            }
            ```

            This configuration ensures that SSL connections are enforced for the PostgreSQL server. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/postgresql/single-server/concepts-security
        title: Azure PostgreSQL Security
  - uid: mondoo-azure-security-ensure-that-ssl-enabled-latest-version-mysql
    title: Ensure SSL connection enabled for MySQL Database Server with the latest version
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-mysql-flexible-server"
    props:
      - uid: latestTlsVersions
        title: The latest supported TLS versions for MySQL flexible servers
        mql: |
          return ["TLSv1.2", "TLSv1.3", "TLSv1.2,TLSv1.3"]
    mql: |
      azure.subscription.mySql.flexibleServer.configuration.where(name == "tls_version").all(value.in(props.latestTlsVersions))
      azure.subscription.mySql.flexibleServer.configuration.where(name == "require_secure_transport").all(value.downcase == "on")
    docs:
      desc: |
        This check ensures that SSL connections are enforced for MySQL database servers to safeguard data in transit and that the latest supported TLS version is used to mitigate vulnerabilities associated with older versions.

        **Why this matters**

        Enforcing SSL connections and using the latest TLS version for MySQL database servers provides several critical benefits:

        - **Data protection**: Encrypting data in transit prevents eavesdropping and man-in-the-middle attacks, ensuring the confidentiality and integrity of sensitive information.
        - **Compliance alignment**: Many security standards and best practices mandate the use of secure communication protocols to protect data in transit.
        - **Mitigation of risks**: Disabling unencrypted connections and using outdated TLS versions increases the risk of unauthorized access and data breaches.
        - **Operational integrity**: Ensuring secure connections and up-to-date TLS versions helps maintain the trustworthiness and reliability of database operations.

        By enforcing SSL connections and adopting the latest TLS version, this check helps to minimize security vulnerabilities, align with compliance requirements, and enhance the overall security posture of MySQL database servers.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to the Azure Portal at https://portal.azure.com.
        2. Navigate to `Azure Database for MySQL servers`.
        3. Select each server to inspect its settings.
        4. Under `Connection security`, verify that `Enforce SSL connection` is set to `ENABLED`.
        5. Additionally, ensure that the server is configured to use the latest supported TLS version (e.g., TLS 1.2 or higher).

        **Automated Audit with Azure CLI:**

        Run the following command to inspect the SSL enforcement and the minimum TLS version for each MySQL server:

        ```bash
        az mysql server list --resource-group <resourceGroupName> --query "[].{Name:name, SSL:sslEnforcement, TLS:minimalTlsVersion}" -o table
        ```

        This command provides a tabulated view showing the SSL enforcement and TLS version for each server, facilitating quick identification of non-compliant or outdated configurations.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To enforce SSL connections and ensure the use of the latest TLS version:

            1. Access the Azure Portal at https://portal.azure.com.
            2. Navigate to `Azure Database for MySQL servers`.
            3. For each server, go to `Connection security`.
            4. Set `Enforce SSL connection` to `ENABLED`.
            5. Select the latest supported TLS version from the dropdown menu to ensure maximum security.
            6. Apply these settings to ensure compliance across all MySQL servers.

            Regular reviews and updates of these settings are recommended to adapt to new TLS versions as they become available, ensuring that the security configurations remain up-to-date.
        - id: cli
          desc: |
            **Using Azure CLI**

            To enforce SSL connections and set the latest TLS version for MySQL servers, use the following Azure CLI command:

            ```bash
            az mysql server update --resource-group <resourceGroupName> --name <serverName> --ssl-enforcement Enabled --minimal-tls-version TLS1_2
            ```

            This command updates the specified MySQL server to enforce SSL connections and sets the minimum TLS version to 1.2. Adjust the `--minimal-tls-version` parameter as needed to specify the latest supported version.
        - id: powershell
          desc: |
            **Using PowerShell**

            To enforce SSL connections and set the latest TLS version for MySQL servers, use the following PowerShell command:

            ```powershell
            $server = Get-AzMySqlServer -ResourceGroupName <resourceGroupName> -Name <serverName>
            $server.SslEnforcement = "Enabled"
            $server.MinimalTlsVersion = "TLS1_2"
            Update-AzMySqlServer -MySqlServer $server
            ```

            This command retrieves the specified MySQL server, updates the SSL enforcement and TLS version settings, and applies the changes.
        - id: terraform
          desc: |
            **Using Terraform**

            To enforce SSL connections and set the latest TLS version for MySQL servers, use the following Terraform configuration:

            ```hcl
            resource "azurerm_mysql_server" "example" {
              name                = "example-mysql-server"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              version             = "5.7"
              ssl_enforcement     = "Enabled"
              minimal_tls_version = "TLS1_2"

              sku {
                name     = "B_Gen5_1"
                tier     = "Basic"
                capacity = 1
              }
            }
            ```

            This configuration ensures that SSL connections are enforced and sets the minimum TLS version to 1.2 for the MySQL server. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/mysql/single-server/concepts-security
        title: Azure MySQL Security
  - uid: mondoo-azure-security-ensure-disabled-public-access-sql
    title: Ensure public network access for SQL server is blocked or Limited to Use Selected Networks Instead of All Networks
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-3
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-sql-server"
    mql: |
      azure.subscription.sql.server.properties.publicNetworkAccess == "Disabled"
        || azure.subscription.sql.server.virtualNetworkRules != empty || azure.subscription.sql.server.firewallRules != empty
    docs:
      desc: |
        This check ensures that public network access for Azure SQL servers is either disabled or limited to specific networks, significantly reducing exposure to potential attacks.

        **Why this matters**

        Limiting public network access to Azure SQL servers provides several critical benefits:

        - **Enhanced security**: Restricting access to private endpoints or specific public IP addresses minimizes the risk of unauthorized access and potential data breaches.
        - **Reduced attack surface**: Disabling public network access ensures that the SQL server is not exposed to the internet, reducing the likelihood of exploitation.
        - **Compliance alignment**: Many security standards and best practices recommend limiting public access to sensitive resources to meet regulatory requirements.
        - **Operational integrity**: Ensuring controlled access helps maintain the intended security and operational state of the database environment.

        By enforcing these restrictions, this check helps to enhance the security posture of Azure SQL servers, align with compliance requirements, and minimize security vulnerabilities.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to the Azure Portal at https://portal.azure.com.
        2. Navigate to **SQL servers** under Azure SQL services.
        3. Select each SQL server to review its networking settings.
        4. Under the **Security** section, select **Networking**.
        5. Verify that for **Public network access**, the setting is either **Disabled** or configured to allow **Selected networks** only, ensuring no open access to all networks.

        **Automated Audit with Azure CLI:**

        You can also verify the public network access settings using Azure CLI:

        ```bash
        az sql server list --query "[].{Name:name, PublicNetworkAccess:publicNetworkAccess}" -o table
        ```

        This command lists all SQL servers along with their public network access settings. Ensure that none of the servers are listed as having unrestricted public network access unless specific rules are applied.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To restrict public network access in Microsoft Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **SQL servers** and select the server you wish to configure.
            3. In the server's settings, select **Networking** under the **Security** section.
            4. Locate the **Public network access** setting.
            5. Change the setting to **Disabled** to completely block public access or to **Selected networks** to restrict access to specific IP addresses or ranges.
            6. If selecting **Selected networks**, ensure you configure the necessary firewall rules or virtual network settings to specify which networks can access the server.
        - id: cli
          desc: |
            **Using Azure CLI**

            To disable public network access for all SQL servers in a subscription, you can use the following Azure CLI command for each server:

            ```bash
            az sql server update --name <ServerName> --resource-group <ResourceGroupName> --set publicNetworkAccess='Disabled'
            ```

            Replace `<ServerName>` and `<ResourceGroupName>` with your actual server names and resource group names. For granular control, manually configure network settings in the Azure Portal to specify allowed networks if opting for the "Selected networks" setting.
        - id: powershell
          desc: |
            **Using PowerShell**

            To disable public network access for SQL servers, you can use the following PowerShell command:

            ```powershell
            $server = Get-AzSqlServer -ResourceGroupName <ResourceGroupName> -ServerName <ServerName>
            $server.PublicNetworkAccess = "Disabled"
            Set-AzSqlServer -SqlServer $server
            ```

            This command retrieves the specified SQL server, updates the public network access setting to disabled, and applies the changes. Regularly review and update these settings to ensure compliance with security best practices.
        - id: terraform
          desc: |
            **Using Terraform**

            To disable public network access for SQL servers, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_sql_server" "example" {
              name                         = "example-sql-server"
              resource_group_name          = azurerm_resource_group.example.name
              location                     = azurerm_resource_group.example.location
              version                      = "12.0"
              administrator_login          = "sqladmin"
              administrator_login_password = "P@ssw0rd1234"

              public_network_access = "Disabled"
            }
            ```

            This configuration ensures that public network access is disabled for the specified SQL server. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/security-overview
        title: Azure SQL Database Security
  - uid: mondoo-azure-security-keyvault-public-access-disabled
    title: Ensure default public network access for Azure Key Vault is disabled or Limited to Use Selected Networks Instead of All Networks
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-keyvault-vault"
    mql: |
      azure.subscription.keyVault.vault.properties.all(publicNetworkAccess == "Disabled")
        || azure.subscription.keyVault.vault.properties.networkAcls.ipRules != empty
        || azure.subscription.keyVault.vault.properties.networkAcls.virtualNetworkRules != empty
    docs:
      desc: |
        This check ensures that public network access to Azure Key Vault is either disabled or restricted to selected networks, significantly reducing exposure to potential attacks.

        **Why this matters**

        Restricting public network access to Azure Key Vault provides several critical benefits:

        - **Enhanced security**: Disabling public access or limiting it to specific networks minimizes the risk of unauthorized access and potential data breaches.
        - **Reduced attack surface**: Blocking public network access ensures that the key vault is not exposed to the internet, reducing the likelihood of exploitation.
        - **Compliance alignment**: Many security standards and best practices recommend limiting public access to sensitive resources to meet regulatory requirements.
        - **Operational integrity**: Ensuring controlled access helps maintain the intended security and operational state of the key vault environment.

        By enforcing these restrictions, this check helps to enhance the security posture of Azure Key Vault, align with compliance requirements, and minimize security vulnerabilities.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log in to the Azure Portal at https://portal.azure.com.
        2. Navigate to **Key vaults** to list all key vaults in your subscriptions.
        3. Select each key vault to review its networking settings.
        4. In the key vault's **Settings**, select **Networking**.
        5. Check the **Firewalls and virtual networks** settings to ensure public access is either disabled or limited:
          - Verify that **Public network access** is set to **Disabled**.
          - If public access is enabled, ensure that access is restricted to selected networks by configuring IP rules or linking to specific virtual networks.

        **Automated Audit with Azure CLI:**

        You can check the public network access settings for all key vaults in a given subscription using the Azure CLI:

        ```bash
        az keyvault list --query "[].{Name:name, PublicNetworkAccess:properties.publicNetworkAccess}" -o table
        ```

        This command outputs the public network access settings for each key vault, allowing you to quickly identify configurations that do not align with best practices.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To restrict public network access in Microsoft Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **Key vaults** and select the key vault you wish to configure.
            3. In the key vault's **Settings**, select **Networking**.
            4. Locate the **Public network access** setting.
            5. Change the setting to **Disabled** to completely block public access or to **Enabled** with specific IP rules or virtual network links to restrict access to selected networks only.
            6. If you need to allow access from specific networks:
              - Set **Public network access** to **Enabled**.
              - Configure **Firewall rules** to define allowed IP address ranges.
              - Link to specific **Virtual networks** to restrict access to designated networks only.
        - id: cli
          desc: |
            **Using Azure CLI**

            To disable public network access for all key vaults in a subscription, you can use the following Azure CLI command for each key vault:

            ```bash
            az keyvault update --name <KeyVaultName> --resource-group <ResourceGroupName> --set properties.publicNetworkAccess='Disabled'
            ```

            Replace `<KeyVaultName>` and `<ResourceGroupName>` with your actual key vault names and resource group names. For granular control, manually configure network settings in the Azure Portal to specify allowed networks if opting for the "Enabled" setting.
        - id: powershell
          desc: |
            **Using PowerShell**

            To disable public network access for key vaults, you can use the following PowerShell command:

            ```powershell
            $keyVault = Get-AzKeyVault -ResourceGroupName <ResourceGroupName> -VaultName <KeyVaultName>
            $keyVault.Properties.PublicNetworkAccess = "Disabled"
            Set-AzKeyVault -KeyVault $keyVault
            ```

            This command retrieves the specified key vault, updates the public network access setting to disabled, and applies the changes. Regularly review and update these settings to ensure compliance with security best practices.
        - id: terraform
          desc: |
            **Using Terraform**

            To disable public network access for key vaults, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_key_vault" "example" {
              name                = "example-keyvault"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              sku_name            = "standard"

              properties {
                public_network_access = "Disabled"
              }
            }
            ```

            This configuration ensures that public network access is disabled for the specified key vault. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/key-vault/general/security-features
        title: Azure Key Vault Security
  - uid: mondoo-azure-security-sql-server-audit-on
    title: Ensure that all activities on SQL server are audited
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure-sql-server"
    mql: |
      azure.subscription.sql.server.auditingPolicy.state == "Enabled"
    docs:
      desc: |
        This check ensures that auditing is enabled for every database or server in your Azure deployment to monitor and log activities for security and compliance purposes.

        **Why this matters**

        Enabling auditing for Azure SQL databases and servers provides several critical benefits:

        - **Enhanced visibility**: Auditing captures detailed logs of database activities, helping to identify unauthorized access or suspicious behavior.
        - **Compliance alignment**: Many regulatory standards and best practices require auditing to ensure accountability and traceability of database operations.
        - **Operational integrity**: Logs provide valuable insights into database usage patterns, helping to detect misconfigurations or potential misuse.
        - **Risk mitigation**: Auditing helps to identify and address security vulnerabilities, reducing the likelihood of data breaches or unauthorized access.

        By enabling auditing, this check helps to enhance the security posture of Azure SQL databases and servers, align with compliance requirements, and maintain operational resilience.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Go to the Azure Portal at https://portal.azure.com.
        2. Navigate to **SQL servers** and select each server to inspect its auditing settings.
        3. Select **Auditing** for each server.
        4. Verify that `Enable Azure SQL Auditing` is switched to `On`. Check that an appropriate storage account, Log Analytics workspace, or Event Hub is selected as the audit log destination.

        **Automated Audit with Azure CLI:**

        To verify the auditing settings for all SQL Servers in a subscription: (replace <resourceGroupName> with your resource group name)

        ```bash
        az sql server list --query "[].{Name:name, ResourceGroupName:<resourceGroupName>}" -o tsv | while read -r name rg; do
          echo "Server: $name"
          az sql server audit-policy show --name $name --resource-group $rg
        done
        ```

        This script iterates over all SQL servers, displaying their audit policy status, ensuring that auditing is enabled and correctly configured.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To enable auditing for SQL servers in Microsoft Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **SQL servers** and select the server you want to configure.
            3. Under **Security**, select **Auditing**.
            4. Set `Enable Azure SQL Auditing` to `On`.
            5. Select a destination for the audit logs: Storage Account, Log Analytics workspace, or Event Hub.
            6. Configure the retention period, ensuring it aligns with your organization's compliance requirements.
            7. Select `Save` to apply the settings.
        - id: cli
          desc: |
            **Using Azure CLI**

            For each SQL server, enable auditing and specify the log retention settings and destination. Here's how you can enable auditing to a Storage Account with a retention period:

            ```bash
            az sql server audit-policy update --name <ServerName> --resource-group <ResourceGroupName> --state Enabled --blob-storage-target-state Enabled --storage-endpoint <StorageAccountBlobEndpoint> --storage-key <StorageAccountKey> --retention-days 90
            ```

            Replace placeholders with your specific details. Similar commands can be executed to set up auditing with Log Analytics or Event Hub as the destination. Ensuring that auditing is enabled and properly configured across all SQL servers in your Azure environment is a key step in maintaining a strong security and compliance posture.
        - id: powershell
          desc: |
            **Using PowerShell**

            To enable auditing for SQL servers, you can use the following PowerShell command:

            ```powershell
            Set-AzSqlServerAudit -ResourceGroupName <ResourceGroupName> -ServerName <ServerName> -State Enabled -StorageAccountName <StorageAccountName> -StorageAccountKey <StorageAccountKey> -RetentionDays 90
            ```

            This command enables auditing for the specified SQL server and configures the storage account and retention period. Regularly review and update these settings to ensure compliance with security best practices.
        - id: terraform
          desc: |
            **Using Terraform**

            To enable auditing for SQL servers, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_sql_server" "example" {
              name                         = "example-sql-server"
              resource_group_name          = azurerm_resource_group.example.name
              location                     = azurerm_resource_group.example.location
              version                      = "12.0"
              administrator_login          = "sqladmin"
              administrator_login_password = "P@ssw0rd1234"

              blob_storage_target_state = "Enabled"
              storage_account_name      = azurerm_storage_account.example.name
              retention_days            = 90
            }
            ```

            This configuration ensures that auditing is enabled for the specified SQL server and configures the storage account and retention period. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/security-overview
        title: Azure SQL Database Security
  - uid: mondoo-azure-security-sql-server-tde-on
    title: Ensure that transparent data encryption is enabled for SQL Server databases
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-10
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-sql-server" && azure.subscription.sql.server.databases.any(name != "master")
    mql: |
      azure.subscription.sql.server.databases.where(name != "master").all(transparentDataEncryption.state == "Enabled")
    docs:
      desc: |
        This check ensures that Transparent Data Encryption (TDE) is enabled for SQL Server databases to encrypt data at rest and protect sensitive information.

        **Why this matters**

        Enabling TDE provides several critical benefits:

        - **Data protection**: TDE encrypts data and log files in real-time, ensuring that sensitive information is protected from unauthorized access.
        - **Compliance alignment**: Many laws, regulations, and industry guidelines require encryption of data at rest to meet security and privacy standards.
        - **Operational integrity**: TDE ensures that encryption and decryption occur seamlessly without requiring changes to existing applications, maintaining operational efficiency.
        - **Risk mitigation**: Encrypting data at rest reduces the risk of data breaches and unauthorized access to sensitive information.

        By enabling TDE, this check helps to enhance the security posture of SQL Server databases, align with compliance requirements, and protect critical data from potential threats.
      audit: |
        **Manual Audit via Azure Portal:**

        1. In the Azure Portal, navigate to **SQL databases** under your SQL Server instances.
        2. Select each database to inspect its settings.
        3. Select **Transparent data encryption** under the **Security** settings.
        4. Verify that `Data encryption` is set to `On` for each database (except the master database, which cannot be encrypted with TDE).

        **Automated Audit with Azure CLI:**

        To check the TDE status for all databases in a specific SQL server:

        ```bash
        az sql db list --resource-group <ResourceGroupName> --server <ServerName> --query "[].{Name:name, TDE:transparentDataEncryption}" -o table
        ```

        Use the following command to check the TDE status of a specific database:

        ```bash
        az sql db tde show --name <DatabaseName> --resource-group <ResourceGroupName> --server <ServerName>
        ```

        Ensure the TDE status is `Enabled` for each database.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To enable TDE for SQL databases in Microsoft Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **SQL databases** under your SQL Server instances.
            3. Select each database to configure TDE.
            4. Under the **Security** section, select **Transparent data encryption**.
            5. Set `Data encryption` to `On`.
            6. Save the changes to apply TDE to the selected database.
        - id: cli
          desc: |
            **Using Azure CLI**

            To enable TDE for a specific database, use the following command:

            ```bash
            az sql db tde set --database <DatabaseName> --resource-group <ResourceGroupName> --server <ServerName> --status Enabled
            ```

            Replace `<DatabaseName>`, `<ResourceGroupName>`, and `<ServerName>` with your actual database, resource group, and server names. This command enables TDE for the specified database.
        - id: powershell
          desc: |
            **Using PowerShell**

            To enable TDE for SQL databases, use the following PowerShell command:

            ```powershell
            Set-AzSqlDatabaseTransparentDataEncryption -DatabaseName <DatabaseName> -ServerName <ServerName> -ResourceGroupName <ResourceGroupName> -State 'Enabled'
            ```

            Replace `<DatabaseName>`, `<ServerName>`, and `<ResourceGroupName>` with your actual database, server, and resource group names. This command enables TDE for the specified database.
        - id: terraform
          desc: |
            **Using Terraform**

            To enable TDE for SQL databases, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_sql_database" "example" {
              name                = "example-sql-database"
              resource_group_name = azurerm_resource_group.example.name
              server_name         = azurerm_sql_server.example.name
              requested_service_objective_name = "S0"

              transparent_data_encryption {
                state = "Enabled"
              }
            }
            ```

            This configuration ensures that TDE is enabled for the specified SQL database. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/security-overview
        title: Azure SQL Database Security
  - uid: mondoo-azure-security-diagnostic-settings-exist
    title: Ensure that diagnostic settings exist for the subscription
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.monitor.diagnosticSettings != empty
    docs:
      desc: |
        This check ensures that diagnostic settings are configured for Azure resources to collect essential logs and metrics, enabling effective monitoring and security analysis.

        **Why this matters**

        Configuring diagnostic settings provides several critical benefits:

        - **Enhanced visibility**: Diagnostic settings capture detailed logs and metrics, offering insights into resource activities and potential security issues.
        - **Compliance alignment**: Many regulatory standards and best practices require the collection and retention of logs for auditing and compliance purposes.
        - **Operational integrity**: Logs and metrics help identify misconfigurations, performance issues, and potential misuse of resources.
        - **Risk mitigation**: Retaining logs for extended periods allows for thorough analysis of activities, helping to detect and address security-related issues.

        By ensuring diagnostic settings are configured, this check helps to enhance the security posture of Azure resources, align with compliance requirements, and maintain operational resilience.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Go to the Azure Portal at https://portal.azure.com.
        2. Navigate to **Monitor** and then **Activity log**.
        3. Select **Diagnostic settings** and review the settings for your subscription.
        4. Ensure that there are diagnostic settings configured and that they cover the essential log categories: Administrative, Security, Alert, and Policy.

        **Automated Audit with Azure CLI:**

        To check the diagnostic settings for the subscription:

        ```bash
        az monitor diagnostic-settings list --resource /subscriptions/{subscriptionId}
        ```

        Verify that the output includes diagnostic settings with the necessary categories enabled.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To configure diagnostic settings in the Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **Monitor** and then **Activity log**.
            3. Select **Diagnostic settings** and click on **Add diagnostic setting**.
            4. Provide a name for the diagnostic setting.
            5. Select the necessary log categories: Administrative, Security, Alert, and Policy.
            6. Choose the destination for the logs, such as an Azure Storage account, a Log Analytics workspace, or an Event Hub.
            7. Save the configuration to ensure continuous monitoring.
        - id: cli
          desc: |
            **Using Azure CLI**

            To create or update diagnostic settings for a subscription, use the following command:

            ```bash
            az monitor diagnostic-settings create --name <NameOfSetting> --resource /subscriptions/{subscriptionId} --logs '[{"category": "Administrative", "enabled": true}, {"category": "Security", "enabled": true}, {"category": "Alert", "enabled": true}, {"category": "Policy", "enabled": true}]' --storage-account <StorageAccountId> --workspace <LogAnalyticsWorkspaceId> --event-hub <EventHubName>
            ```

            Replace the placeholders with your specific resource IDs and desired diagnostic setting name.
        - id: powershell
          desc: |
            **Using PowerShell**

            To configure diagnostic settings with PowerShell, use the following command:

            ```powershell
            $subsId = "<SubscriptionId>"
            $settingName = "<DiagnosticSettingName>"
            $storageAccountId = "<StorageAccountId>"
            $workspaceId = "<LogAnalyticsWorkspaceId>"
            $eventHubAuthRuleId = "<EventHubAuthorizationRuleId>"

            Set-AzDiagnosticSetting -ResourceId "/subscriptions/$subsId" -StorageAccountId $storageAccountId -WorkspaceId $workspaceId -Enabled $true -Name $settingName -Category @("Administrative", "Security", "Alert", "Policy")
            ```

            Modify the script to match your specific resource IDs and configuration preferences. It's crucial to routinely review and update these settings to adapt to any changes in your Azure environment or organizational requirements.
        - id: terraform
          desc: |
            **Using Terraform**

            To configure diagnostic settings for a subscription, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_monitor_diagnostic_setting" "example" {
              name               = "example-diagnostic-setting"
              target_resource_id = azurerm_sql_server.example.id

              log {
                category = "Administrative"
                enabled  = true
              }

              log {
                category = "Security"
                enabled  = true
              }

              log {
                category = "Alert"
                enabled  = true
              }

              log {
                category = "Policy"
                enabled  = true
              }

              storage_account_id = azurerm_storage_account.example.id
            }
            ```

            This configuration ensures that the specified log categories are collected for the Azure resource. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-monitor/best-practices
        title: Azure Monitor Best Practices
  - uid: mondoo-azure-security-diagnostic-settings-essential-categories
    title: Ensure that diagnostic settings collect essential security categories
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.monitor.diagnosticSettings != empty
      azure.subscription.monitor.diagnosticSettings.all(properties.logs.where(category == "Administrative").all(enabled == true))
      azure.subscription.monitor.diagnosticSettings.all(properties.logs.where(category == "Security").all(enabled == true))
      azure.subscription.monitor.diagnosticSettings.all(properties.logs.where(category == "Alert").all(enabled == true))
      azure.subscription.monitor.diagnosticSettings.all(properties.logs.where(category == "Policy").all(enabled == true))
    docs:
      desc: |
        This check ensures that diagnostic settings collect essential security categories such as Administrative, Security, Alert, and Policy logs to provide comprehensive monitoring and security insights.

        **Why this matters**

        Capturing essential log categories in diagnostic settings provides several critical benefits:

        - **Enhanced visibility**: Logs offer detailed insights into resource activities, helping to identify unauthorized access or suspicious behavior.
        - **Compliance alignment**: Many regulatory standards and best practices require the collection of specific log categories to meet auditing and compliance requirements.
        - **Operational integrity**: Logs help detect misconfigurations, performance issues, and potential misuse of resources.
        - **Risk mitigation**: Retaining logs for extended periods allows for thorough analysis of activities, helping to detect and address security-related issues.

        By ensuring these log categories are collected, this check helps to enhance the security posture of Azure resources, align with compliance requirements, and maintain operational resilience.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Access **Azure Monitor** within the Azure Portal.
        2. Navigate to **Activity log** and proceed to **Diagnostic settings**.
        3. Review the settings for each subscription ensuring the collection of Administrative, Security, Alert, and Policy logs.
        4. Confirm that these categories are enabled and correctly configured to export to an appropriate destination.

        **Automated Audit with Azure CLI:**

        Use the Azure CLI to list and verify the diagnostic settings across subscriptions:

        ```bash
        az monitor diagnostic-settings list --resource /subscriptions/{subscriptionId}
        ```

        Review the settings to confirm that the essential categories are enabled.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To configure diagnostic settings for essential categories in the Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **Monitor** and then **Activity log**.
            3. Select **Diagnostic settings** and either add a new setting or edit an existing one.
            4. Provide a name for the diagnostic setting and ensure the inclusion of Administrative, Security, Alert, and Policy logs.
            5. Choose the destination for these logs, such as an Azure Storage account, Log Analytics workspace, or Event Hub.
            6. Save the configuration to ensure continuous monitoring.
        - id: cli
          desc: |
            **Using Azure CLI**

            To create or update diagnostic settings for capturing essential log categories, use:

            ```bash
            az monitor diagnostic-settings create --name <NameOfSetting> --resource /subscriptions/{subscriptionId} --logs '[{"category": "Administrative", "enabled": true}, {"category": "Security", "enabled": true}, {"category": "Alert", "enabled": true}, {"category": "Policy", "enabled": true}]' --storage-account <StorageAccountId> --workspace <LogAnalyticsWorkspaceId> --event-hub <EventHubName>
            ```

            Replace the placeholders with your specific resource IDs and desired diagnostic setting name.
        - id: powershell
          desc: |
            **Using PowerShell**

            To configure diagnostic settings with PowerShell, use the following command:

            ```powershell
            $subsId = "<SubscriptionId>"
            $settingName = "<DiagnosticSettingName>"
            $storageAccountId = "<StorageAccountId>"
            $workspaceId = "<LogAnalyticsWorkspaceId>"
            $eventHubAuthRuleId = "<EventHubAuthorizationRuleId>"

            Set-AzDiagnosticSetting -ResourceId "/subscriptions/$subsId" -StorageAccountId $storageAccountId -WorkspaceId $workspaceId -Enabled $true -Name $settingName -Category @("Administrative", "Security", "Alert", "Policy")
            ```

            Modify the script to match your specific resource IDs and configuration preferences. It's crucial to routinely review and update these settings to adapt to any changes in your Azure environment or organizational requirements.
        - id: terraform
          desc: |
            **Using Terraform**

            To configure diagnostic settings for essential categories, you can use the following Terraform configuration:

            ```hcl
            resource "azurerm_monitor_diagnostic_setting" "example" {
              name               = "example-diagnostic-setting"
              target_resource_id = azurerm_sql_server.example.id

              log {
                category = "Administrative"
                enabled  = true
              }

              log {
                category = "Security"
                enabled  = true
              }

              log {
                category = "Alert"
                enabled  = true
              }

              log {
                category = "Policy"
                enabled  = true
              }

              storage_account_id = azurerm_storage_account.example.id
            }
            ```

            This configuration ensures that the specified log categories are collected for the Azure resource. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-monitor/best-practices
        title: Azure Monitor Best Practices
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/overview
        title: Azure Security Fundamentals
  - uid: mondoo-azure-security-disable-udp-virtualmachines
    title: Ensure direct UDP access to Resources from the internet is restricted
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-network-security-group"
    props:
      - uid: mondooAzureSecurityDisallowedPortsUDP
        title: A list of disallowed UDP ports, by default covering common UDP services. Add more as needed.
        mql: |
          return [
            53,    // DNS
            123,   // NTP
            161,   // SNMP
            389,   // CLDAP
            1900   // SSDP
          ]
    mql: |
      allNsgUDP = azure.subscription.network.securityGroup.securityRules
        .where(
          properties.access == 'Allow'
            && direction == 'Inbound'
            && properties.protocol == /UDP|\*/i
            && properties.sourceAddressPrefix == /\*|0\.0\.0\.0|<nw>\/0|\/0|internet|any/
        )
      allNsgUDP.all(properties.destinationPortRange != "*")
      props.mondooAzureSecurityDisallowedPortsUDP {
        disallowedPortUDP = _
        disallowedPortUDP
        allNsgUDP.none(destinationPortRange.any(fromPort <= disallowedPortUDP && toPort >= disallowedPortUDP))
      }
    docs:
      desc: |
        This check ensures that direct UDP access to resources from the internet is restricted to minimize security risks and prevent potential exploitation.

        **Why this matters**

        Exposing UDP services to the internet can lead to significant security risks:

        - **Reflection amplification attacks**: UDP's connectionless nature allows attackers to spoof a target's IP address and send information requests using UDP. This can result in amplified traffic directed at the victim, often leading to denial-of-service (DoS) attacks.
        - **Lack of authentication**: UDP does not verify source IP addresses, making it easier for attackers to manipulate IP datagrams and exploit open UDP ports.
        - **Increased attack surface**: Open UDP ports, especially those using well-known protocols like DNS, NTP, CLDAP, SSDP, or SNMPv2, can be exploited as amplifiers in attacks.
        - **Operational risks**: Misconfigured or exposed UDP services can lead to unintended access, service disruptions, or data breaches.

        By restricting unnecessary UDP traffic from the internet and employing best practices for network security, this check helps to minimize security vulnerabilities, align with compliance requirements, and enhance the overall security posture of Azure resources.

        **Examples of vulnerable UDP-based protocols**

        Some application-layer protocols that rely on UDP and are commonly targeted include:

        - Domain Name System (DNS)
        - Network Time Protocol (NTP)
        - Connection-less Lightweight Directory Access Protocol (CLDAP)
        - Simple Service Discovery Protocol (SSDP)
        - Simple Network Management Protocol version 2 (SNMPv2)
        - Portmap/Remote Procedure Call (RPC)
        - Network Basic Input/Output System (NetBIOS)
        - Trivial File Transfer Protocol (TFTP)

        Employing Network Security Groups (NSGs) to deny or control inbound UDP traffic, especially on ports known to be vulnerable or unnecessary for internet exposure, is a key defensive measure. For services that require UDP access, ensure they are secured, monitored, and only exposed when absolutely necessary, using the principle of least privilege to minimize potential attack vectors.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Access the Azure Portal and review the networking settings for each resource, focusing on those with public internet exposure.
        2. Inspect inbound port rules for associated Network Security Groups (NSGs) and any other relevant firewall settings.
        3. Confirm that none of the critical UDP ports are allowed from the internet, particularly for resources that do not require such access.

        **Automated Audit with Azure CLI:**

        Use the Azure CLI to review NSG rules across your Azure environment:

        ```bash
        az network nsg rule list --query "[].{NSG:networkSecurityGroup, Protocol:protocol, Access:access, Direction:direction, SourceAddressPrefix:sourceAddressPrefix, DestinationPortRange:destinationPortRange}" -o table
        ```

        Ensure no rule improperly exposes the specified UDP ports to the internet.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            To restrict UDP traffic in Microsoft Azure Portal:

            1. Log into the Azure Portal at https://portal.azure.com.
            2. Navigate to **Network Security Groups** and select the NSG associated with your resources.
            3. Review the inbound security rules and identify any that allow traffic on the disallowed UDP ports from the internet.
            4. Modify or remove these rules as necessary to restrict access.
            5. For services requiring UDP access, consider using secure alternatives or private connections (e.g., VPNs, ExpressRoute).
        - id: cli
          desc: |
            **Using Azure CLI**

            To restrict UDP traffic using the Azure CLI, you can delete or update the NSG rules that allow disallowed UDP ports:

            ```bash
            az network nsg rule list --resource-group <ResourceGroupName> --nsg-name <NSGName> --query "[].{Name:name, Protocol:protocol, Access:access, Direction:direction, SourceAddressPrefix:sourceAddressPrefix, DestinationPortRange:destinationPortRange}" -o table
            ```

            Review the output and identify any rules allowing disallowed UDP ports. Then, either delete or update those rules as needed.
        - id: powershell
          desc: |
            **Using PowerShell**

            To restrict UDP traffic using PowerShell, you can use the following command to list NSG rules:

            ```powershell
            Get-AzNetworkSecurityRuleConfig -NetworkSecurityGroup <NSGName> | Where-Object { $_.Access -eq "Allow" -and $_.Direction -eq "Inbound" -and $_.Protocol -match "UDP|*" }
            ```

            Review the output and identify any rules allowing disallowed UDP ports. Then, either delete or update those rules as needed.
        - id: terraform
          desc: |
            **Using Terraform**

            To restrict UDP traffic using Terraform, you can modify the NSG rules in your configuration:

            ```hcl
            resource "azurerm_network_security_rule" "example" {
              name                        = "example-nsg-rule"
              network_security_group_name = azurerm_network_security_group.example.name
              priority                    = 100
              direction                   = "Inbound"
              access                      = "Deny"
              protocol                    = "Udp"
              source_address_prefix      = "*"
              destination_port_range     = "<DisallowedPort>"
            }
            ```

            Replace `<DisallowedPort>` with the specific port you want to restrict. Regularly review and update your Terraform configurations to ensure compliance with security best practices.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-storage-blob-soft-delete-enabled
    title: Ensure blob soft delete is enabled for Azure Storage accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc9-1-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-14
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.dataProtection.blobSoftDeletionEnabled == true
    docs:
      desc: |
        This check ensures that blob soft delete is enabled for Azure Storage accounts to protect against accidental or malicious deletion of blob data.

        **Why this matters**

        Enabling blob soft delete provides several critical benefits:

        - **Data protection**: Soft delete retains deleted blobs for a specified period, allowing recovery from accidental or malicious deletions.
        - **Ransomware mitigation**: In the event of a ransomware attack that attempts to delete or overwrite data, soft delete provides a recovery mechanism.
        - **Compliance alignment**: Many regulatory standards require data retention and recoverability capabilities for critical data stores.
        - **Operational resilience**: Soft delete acts as a safety net, reducing the impact of human errors or application bugs that inadvertently delete data.

        By enabling blob soft delete, organizations can enhance their data protection posture and ensure recoverability of critical blob data.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage accounts** in the Azure Portal.
        2. Select a storage account and go to **Data protection** under **Data management**.
        3. Verify that **Enable soft delete for blobs** is checked and the retention period is set appropriately.

        **Automated Audit with Azure CLI:**

        ```bash
        az storage account blob-service-properties show --account-name <StorageAccountName> --resource-group <ResourceGroupName> --query "deleteRetentionPolicy"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage accounts** in the Azure Portal.
            2. Select the storage account.
            3. Go to **Data protection** under **Data management**.
            4. Check **Enable soft delete for blobs**.
            5. Set the retention period (recommended: 7 days minimum).
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az storage account blob-service-properties update --account-name <StorageAccountName> --resource-group <ResourceGroupName> --enable-delete-retention true --delete-retention-days 7
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
              name                     = "examplestorageaccount"
              resource_group_name      = azurerm_resource_group.example.name
              location                 = azurerm_resource_group.example.location
              account_tier             = "Standard"
              account_replication_type = "LRS"

              blob_properties {
                delete_retention_policy {
                  days = 7
                }
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/blobs/soft-delete-blob-overview
        title: Soft delete for blobs
  - uid: mondoo-azure-security-storage-container-soft-delete-enabled
    title: Ensure container soft delete is enabled for Azure Storage accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc9-1-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-14
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.dataProtection.containerSoftDeletionEnabled == true
    docs:
      desc: |
        This check ensures that container soft delete is enabled for Azure Storage accounts to protect against accidental or malicious deletion of storage containers and their contents.

        **Why this matters**

        Enabling container soft delete provides several critical benefits:

        - **Data protection**: Soft delete retains deleted containers and their data for a specified period, allowing recovery from accidental or malicious deletions.
        - **Ransomware mitigation**: Container soft delete provides a recovery mechanism if an attacker attempts to delete entire containers.
        - **Compliance alignment**: Many regulatory standards require data retention and recoverability capabilities for critical data stores.
        - **Operational resilience**: Provides a safety net that reduces the impact of human errors, application bugs, or malicious actions that delete containers.

        By enabling container soft delete, organizations can enhance their data protection posture and ensure recoverability of critical storage containers.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage accounts** in the Azure Portal.
        2. Select a storage account and go to **Data protection** under **Data management**.
        3. Verify that **Enable soft delete for containers** is checked and the retention period is set appropriately.

        **Automated Audit with Azure CLI:**

        ```bash
        az storage account blob-service-properties show --account-name <StorageAccountName> --resource-group <ResourceGroupName> --query "containerDeleteRetentionPolicy"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage accounts** in the Azure Portal.
            2. Select the storage account.
            3. Go to **Data protection** under **Data management**.
            4. Check **Enable soft delete for containers**.
            5. Set the retention period (recommended: 7 days minimum).
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az storage account blob-service-properties update --account-name <StorageAccountName> --resource-group <ResourceGroupName> --enable-container-delete-retention true --container-delete-retention-days 7
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
              name                     = "examplestorageaccount"
              resource_group_name      = azurerm_resource_group.example.name
              location                 = azurerm_resource_group.example.location
              account_tier             = "Standard"
              account_replication_type = "LRS"

              blob_properties {
                container_delete_retention_policy {
                  days = 7
                }
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/blobs/soft-delete-container-overview
        title: Soft delete for containers
  - uid: mondoo-azure-security-storage-min-tls-version
    title: Ensure Azure Storage accounts enforce minimum TLS 1.2
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties["minimumTlsVersion"] == "TLS1_2"
    docs:
      desc: |
        This check ensures that Azure Storage accounts enforce a minimum TLS version of 1.2 for all connections, preventing the use of older, vulnerable TLS versions.

        **Why this matters**

        Enforcing TLS 1.2 as the minimum version provides several critical benefits:

        - **Enhanced security**: TLS 1.2 offers stronger encryption algorithms and improved security features compared to TLS 1.0 and 1.1, which have known vulnerabilities.
        - **Compliance alignment**: Many regulatory standards and security frameworks require the use of TLS 1.2 or higher for data in transit.
        - **Mitigation of vulnerabilities**: Older TLS versions are susceptible to attacks such as POODLE, BEAST, and other cryptographic weaknesses.
        - **Industry best practice**: Microsoft and major cloud providers recommend TLS 1.2 as the minimum acceptable version for secure communications.

        By enforcing TLS 1.2, this check helps to minimize security vulnerabilities and protect data in transit to and from Azure Storage accounts.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage accounts** in the Azure Portal.
        2. Select a storage account and go to **Configuration**.
        3. Verify that **Minimum TLS version** is set to **Version 1.2**.

        **Automated Audit with Azure CLI:**

        ```bash
        az storage account show --name <StorageAccountName> --resource-group <ResourceGroupName> --query "minimumTlsVersion"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage accounts** in the Azure Portal.
            2. Select the storage account.
            3. Go to **Configuration**.
            4. Set **Minimum TLS version** to **Version 1.2**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az storage account update --name <StorageAccountName> --resource-group <ResourceGroupName> --min-tls-version TLS1_2
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
              name                     = "examplestorageaccount"
              resource_group_name      = azurerm_resource_group.example.name
              location                 = azurerm_resource_group.example.location
              account_tier             = "Standard"
              account_replication_type = "LRS"
              min_tls_version          = "TLS1_2"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/transport-layer-security-configure-minimum-version
        title: Configure minimum required version of TLS for a storage account
  - uid: mondoo-azure-security-sql-threat-detection-enabled
    title: Ensure threat detection is enabled on Azure SQL servers
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure-sql-server"
    mql: |
      azure.subscription.sql.server.threatDetectionPolicy.state == "Enabled"
    docs:
      desc: |
        This check ensures that Advanced Threat Protection (threat detection) is enabled on Azure SQL servers to detect anomalous database activities and potential security threats.

        **Why this matters**

        Enabling threat detection provides several critical benefits:

        - **Proactive threat identification**: Advanced Threat Protection detects anomalous activities indicating unusual and potentially harmful attempts to access or exploit databases, such as SQL injection, brute force attacks, and anomalous login patterns.
        - **Real-time alerts**: Administrators receive immediate notifications about suspicious activities, enabling rapid investigation and response.
        - **Compliance alignment**: Many security standards and regulatory frameworks require proactive threat monitoring and detection for database systems.
        - **Forensic analysis**: Threat detection logs provide detailed information for investigating security incidents and understanding attack patterns.

        By enabling threat detection, organizations can proactively identify and respond to potential threats targeting their Azure SQL databases.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **SQL servers** in the Azure Portal.
        2. Select a server and go to **Microsoft Defender for SQL** under **Security**.
        3. Verify that **Microsoft Defender for SQL** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az sql server threat-policy show --resource-group <ResourceGroupName> --server <ServerName>
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **SQL servers** in the Azure Portal.
            2. Select the server.
            3. Go to **Microsoft Defender for SQL** under **Security**.
            4. Set **Microsoft Defender for SQL** to **On**.
            5. Configure alert recipients and storage settings as needed.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az sql server threat-policy update --resource-group <ResourceGroupName> --server <ServerName> --state Enabled
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_mssql_server_security_alert_policy" "example" {
              resource_group_name = azurerm_resource_group.example.name
              server_name         = azurerm_mssql_server.example.name
              state               = "Enabled"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/threat-detection-configure
        title: Configure Advanced Threat Protection for Azure SQL Database
  - uid: mondoo-azure-security-sql-ad-admin-configured
    title: Ensure an Azure Active Directory administrator is configured for SQL servers
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure-sql-server"
    mql: |
      azure.subscription.sql.server.azureAdAdministrators != empty
    docs:
      desc: |
        This check ensures that an Azure Active Directory (Azure AD) administrator is configured for Azure SQL servers, enabling centralized identity management and stronger authentication.

        **Why this matters**

        Configuring an Azure AD administrator for SQL servers provides several critical benefits:

        - **Centralized identity management**: Azure AD integration allows organizations to manage database access using the same identity provider used for other Azure resources.
        - **Stronger authentication**: Azure AD supports multi-factor authentication (MFA), conditional access policies, and other advanced security features not available with SQL authentication alone.
        - **Reduced credential sprawl**: Eliminates the need for separate SQL logins and passwords, reducing the attack surface and simplifying credential management.
        - **Compliance alignment**: Many security standards require centralized identity management and strong authentication for database access.

        By configuring an Azure AD administrator, organizations can enforce consistent access policies and leverage advanced identity security features for their SQL databases.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **SQL servers** in the Azure Portal.
        2. Select a server and go to **Microsoft Entra ID** under **Settings**.
        3. Verify that an Azure AD administrator is configured.

        **Automated Audit with Azure CLI:**

        ```bash
        az sql server ad-admin list --resource-group <ResourceGroupName> --server-name <ServerName>
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **SQL servers** in the Azure Portal.
            2. Select the server.
            3. Go to **Microsoft Entra ID** under **Settings**.
            4. Select **Set admin** and choose an Azure AD user or group.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az sql server ad-admin create --resource-group <ResourceGroupName> --server-name <ServerName> --display-name <AdminDisplayName> --object-id <AdminObjectId>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_mssql_server" "example" {
              name                         = "example-sqlserver"
              resource_group_name          = azurerm_resource_group.example.name
              location                     = azurerm_resource_group.example.location
              version                      = "12.0"

              azuread_administrator {
                login_username = "AzureAD Admin"
                object_id      = "<AdminObjectId>"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-aad-configure
        title: Configure Azure AD authentication for Azure SQL
  - uid: mondoo-azure-security-keyvault-rbac-enabled
    title: Ensure Azure Key Vault uses RBAC authorization
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-3-3
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure-keyvault-vault"
    mql: |
      azure.subscription.keyVault.vault.rbacAuthorizationEnabled == true
    docs:
      desc: |
        This check ensures that Azure Key Vault uses Role-Based Access Control (RBAC) for authorization instead of vault access policies, providing more granular and manageable access control.

        **Why this matters**

        Using RBAC authorization for Key Vault provides several critical benefits:

        - **Granular access control**: RBAC allows fine-grained permissions at the individual key, secret, and certificate level, rather than broad vault-level access policies.
        - **Centralized management**: RBAC permissions are managed through Azure's central IAM system, providing a unified view of access across all Azure resources.
        - **Audit and compliance**: RBAC integrates with Azure's audit logging, making it easier to track and review access permissions for compliance purposes.
        - **Least privilege enforcement**: RBAC's built-in and custom roles make it easier to implement the principle of least privilege compared to vault access policies.

        By using RBAC authorization, organizations can enforce more consistent and manageable access control for their Key Vault resources.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Key Vaults** in the Azure Portal.
        2. Select a Key Vault and go to **Access configuration** under **Settings**.
        3. Verify that **Permission model** is set to **Azure role-based access control**.

        **Automated Audit with Azure CLI:**

        ```bash
        az keyvault show --name <VaultName> --query "properties.enableRbacAuthorization"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Key Vaults** in the Azure Portal.
            2. Select the Key Vault.
            3. Go to **Access configuration** under **Settings**.
            4. Set **Permission model** to **Azure role-based access control**.
            5. Select **Apply**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az keyvault update --name <VaultName> --resource-group <ResourceGroupName> --enable-rbac-authorization true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_key_vault" "example" {
              name                        = "example-keyvault"
              location                    = azurerm_resource_group.example.location
              resource_group_name         = azurerm_resource_group.example.name
              tenant_id                   = data.azurerm_client_config.current.tenant_id
              sku_name                    = "standard"
              enable_rbac_authorization   = true
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/key-vault/general/rbac-guide
        title: Provide access to Key Vault keys, certificates, and secrets with Azure RBAC
  - uid: mondoo-azure-security-keyvault-key-auto-rotation
    title: Ensure Key Vault keys have auto-rotation enabled
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-9
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-keyvault-vault"
    mql: |
      azure.subscription.keyVault.vault.keys.where(enabled == true).all(rotationPolicy.enabled == true)
    docs:
      desc: |
        This check ensures that all enabled keys in Azure Key Vault have automatic rotation configured, reducing the risk of using long-lived cryptographic keys.

        **Why this matters**

        Enabling key auto-rotation provides several critical benefits:

        - **Reduced key exposure**: Automatic rotation limits the lifetime of each key version, reducing the window of opportunity if a key is compromised.
        - **Compliance alignment**: Many security standards and frameworks require periodic key rotation to maintain strong cryptographic practices.
        - **Operational efficiency**: Auto-rotation eliminates the manual effort and potential human error involved in periodic key rotation.
        - **Continuous security**: Ensures that encryption keys are regularly refreshed without requiring application downtime or manual intervention.

        By enabling auto-rotation, organizations can maintain strong cryptographic hygiene and reduce the risk associated with long-lived keys.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Key Vaults** in the Azure Portal.
        2. Select a Key Vault and go to **Keys**.
        3. Select each enabled key and review its **Rotation policy**.
        4. Verify that auto-rotation is configured with an appropriate rotation interval.

        **Automated Audit with Azure CLI:**

        ```bash
        az keyvault key rotation-policy show --vault-name <VaultName> --name <KeyName>
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Key Vaults** in the Azure Portal.
            2. Select the Key Vault and go to **Keys**.
            3. Select the key.
            4. Go to **Rotation policy**.
            5. Configure the auto-rotation settings with an appropriate expiry time and rotation interval.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az keyvault key rotation-policy update --vault-name <VaultName> --name <KeyName> --value @rotation-policy.json
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_key_vault_key" "example" {
              name         = "example-key"
              key_vault_id = azurerm_key_vault.example.id
              key_type     = "RSA"
              key_size     = 2048
              key_opts     = ["decrypt", "encrypt", "sign", "unwrapKey", "verify", "wrapKey"]

              rotation_policy {
                automatic {
                  time_before_expiry = "P30D"
                }

                expire_after         = "P90D"
                notify_before_expiry = "P29D"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/key-vault/keys/how-to-configure-key-rotation
        title: Configure key auto-rotation in Azure Key Vault
  - uid: mondoo-azure-security-compute-data-disks-encrypted
    title: Ensure data disks use Customer Managed Key encryption for Azure virtual machines
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-10
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure-compute-vm-api"
    mql: |
      azure.subscription.compute.vm.dataDisks.all(properties.encryption.type == "EncryptionAtRestWithCustomerKey")
    docs:
      desc: |
        This check ensures that data disks attached to Azure virtual machines are encrypted with Customer Managed Keys (CMK), protecting stored data from unauthorized access.

        **Why this matters**

        Encrypting data disks with Customer Managed Keys provides several critical benefits:

        - **Data protection**: Encryption ensures that data on attached disks is unreadable to unauthorized users, protecting against both external attacks and insider threats.
        - **Enhanced control**: Using CMK allows organizations to manage their own encryption keys via Azure Key Vault, enabling key rotation and revocation capabilities.
        - **Compliance alignment**: Many regulatory standards and security frameworks require encryption of data at rest with organization-managed keys.
        - **Risk mitigation**: Encrypting data disks prevents unauthorized access to sensitive data in scenarios such as disk theft, improper decommissioning, or unauthorized snapshot access.

        By ensuring data disks are encrypted with Customer Managed Keys, this check helps protect sensitive data, meet compliance requirements, and enhance the overall security posture of Azure virtual machines.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Virtual machines** in the Azure Portal.
        2. Select a virtual machine and access **Disks** under the Settings menu.
        3. Review each data disk and verify that encryption is set to Customer-managed keys.

        **Automated Audit with Azure CLI:**

        ```bash
        az disk list --resource-group <ResourceGroupName> --query "[?managedBy!=null].{Name:name, EncryptionType:encryption.type}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Disks** in the Azure Portal.
            2. Select the data disk you wish to encrypt.
            3. In the **Encryption** section, set **Encryption type** to **Customer-managed keys**.
            4. Specify the Azure Key Vault and select the appropriate key.
            5. Save the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az disk update --resource-group <ResourceGroupName> --name <DiskName> --encryption-type EncryptionAtRestWithCustomerKey --disk-encryption-set <DiskEncryptionSetId>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_managed_disk" "example" {
              name                 = "example-data-disk"
              location             = azurerm_resource_group.example.location
              resource_group_name  = azurerm_resource_group.example.name
              storage_account_type = "Standard_LRS"
              create_option        = "Empty"
              disk_size_gb         = 128
              disk_encryption_set_id = azurerm_disk_encryption_set.example.id
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/virtual-machines/disk-encryption-overview
        title: Overview of managed disk encryption options
  - uid: mondoo-azure-security-network-watcher-flow-logs-enabled
    title: Ensure Network Watcher flow logs are enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.watchers.all(flowLogs.any(enabled == true))
    docs:
      desc: |
        This check ensures that Network Watcher flow logs are enabled to capture and record network traffic data for security analysis and monitoring.

        **Why this matters**

        Enabling Network Watcher flow logs provides several critical benefits:

        - **Network visibility**: Flow logs capture information about IP traffic flowing through network security groups, providing deep visibility into network activity.
        - **Threat detection**: Flow log data can be analyzed to detect anomalous traffic patterns, unauthorized access attempts, and potential data exfiltration.
        - **Compliance alignment**: Many security standards require monitoring and logging of network traffic for auditing and compliance purposes.
        - **Forensic analysis**: In the event of a security incident, flow logs provide critical data for understanding attack vectors and assessing impact.
        - **Traffic analytics**: Flow logs integrate with Azure Traffic Analytics to provide insights into traffic patterns, top talkers, and security threats.

        By enabling flow logs, organizations can maintain comprehensive visibility into their network traffic and improve their ability to detect and respond to security threats.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Network Watcher** in the Azure Portal.
        2. Select **NSG flow logs** under **Logs**.
        3. Verify that flow logs are enabled for all relevant network security groups.

        **Automated Audit with Azure CLI:**

        ```bash
        az network watcher flow-log list --location <Location> --query "[].{Name:name, Enabled:enabled, TargetResourceId:targetResourceId}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Network Watcher** in the Azure Portal.
            2. Select **NSG flow logs** under **Logs**.
            3. Select the NSG for which to enable flow logs.
            4. Set **Flow logs** to **On**.
            5. Configure the storage account and retention settings.
            6. Optionally enable **Traffic Analytics** for advanced insights.
            7. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network watcher flow-log create --location <Location> --name <FlowLogName> --nsg <NSGResourceId> --storage-account <StorageAccountId> --enabled true --retention 90
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_network_watcher_flow_log" "example" {
              network_watcher_name = azurerm_network_watcher.example.name
              resource_group_name  = azurerm_resource_group.example.name
              name                 = "example-flow-log"

              network_security_group_id = azurerm_network_security_group.example.id
              storage_account_id        = azurerm_storage_account.example.id
              enabled                   = true

              retention_policy {
                enabled = true
                days    = 90
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/network-watcher/nsg-flow-logs-overview
        title: NSG flow logs overview
  - uid: mondoo-azure-security-defender-for-servers-enabled
    title: Ensure Microsoft Defender for Servers is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForServers["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Servers is enabled to provide advanced threat protection for Azure virtual machines and on-premises servers connected to Azure.

        **Why this matters**

        Enabling Defender for Servers provides several critical benefits:

        - **Threat detection**: Detects threats targeting servers, including malware, brute force attacks, fileless attacks, and suspicious process execution.
        - **Vulnerability assessment**: Provides integrated vulnerability scanning powered by Qualys to identify security weaknesses.
        - **Just-in-time VM access**: Reduces attack surface by enabling on-demand access to VM management ports.
        - **Adaptive application controls**: Uses machine learning to recommend application whitelisting policies.
        - **File integrity monitoring**: Detects unauthorized changes to critical system files and registry settings.

        By enabling Defender for Servers, organizations can significantly improve their ability to detect and respond to threats targeting their server infrastructure.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Servers** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name VirtualMachines --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Servers** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name VirtualMachines --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "servers" {
              tier          = "Standard"
              resource_type = "VirtualMachines"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-servers-introduction
        title: Overview of Microsoft Defender for Servers
  - uid: mondoo-azure-security-defender-for-app-services-enabled
    title: Ensure Microsoft Defender for App Service is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForAppServices["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for App Service is enabled to detect threats targeting applications hosted on Azure App Service.

        **Why this matters**

        Enabling Defender for App Service provides several critical benefits:

        - **Web application protection**: Detects attacks targeting web applications, including SQL injection, cross-site scripting, and command injection attempts.
        - **Dangling DNS detection**: Identifies DNS records pointing to decommissioned App Service resources that could be exploited for subdomain takeover.
        - **Runtime threat detection**: Monitors application behavior at runtime to detect suspicious activity patterns.
        - **Compliance alignment**: Many security frameworks require advanced threat protection for internet-facing applications.

        By enabling Defender for App Service, organizations can detect and respond to threats targeting their web applications and APIs.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **App Service** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name AppServices --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **App Service** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name AppServices --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "app_services" {
              tier          = "Standard"
              resource_type = "AppServices"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-app-service-introduction
        title: Overview of Microsoft Defender for App Service
  - uid: mondoo-azure-security-defender-for-sql-databases-enabled
    title: Ensure Microsoft Defender for Azure SQL Databases is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForSqlDatabases["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Azure SQL Databases is enabled to provide advanced threat detection for Azure SQL Database instances.

        **Why this matters**

        Enabling Defender for Azure SQL Databases provides several critical benefits:

        - **SQL injection detection**: Identifies SQL injection attacks and anomalous query patterns that could indicate exploitation attempts.
        - **Anomalous access detection**: Detects unusual login patterns, access from unfamiliar locations, and brute force attacks.
        - **Data exfiltration alerts**: Monitors for unusual data export patterns that could indicate data theft.
        - **Vulnerability assessment**: Scans databases for security misconfigurations and provides remediation guidance.

        By enabling Defender for Azure SQL Databases, organizations can proactively detect and respond to threats targeting their database infrastructure.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Azure SQL Databases** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name SqlServers --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Azure SQL Databases** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name SqlServers --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "sql_servers" {
              tier          = "Standard"
              resource_type = "SqlServers"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-sql-introduction
        title: Overview of Microsoft Defender for Azure SQL
  - uid: mondoo-azure-security-defender-for-storage-enabled
    title: Ensure Microsoft Defender for Storage is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForStorageAccounts["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Storage is enabled to detect unusual and potentially harmful attempts to access or exploit Azure Storage accounts.

        **Why this matters**

        Enabling Defender for Storage provides several critical benefits:

        - **Malware scanning**: Detects malware uploaded to blob storage, protecting downstream consumers of the data.
        - **Anomalous access detection**: Identifies unusual access patterns, such as access from suspicious IP addresses or unexpected data access volumes.
        - **Data exfiltration alerts**: Monitors for unusual data export patterns that could indicate data theft.
        - **Sensitive data exposure**: Detects potentially sensitive data exposed through misconfigured storage accounts.

        By enabling Defender for Storage, organizations can detect and respond to threats targeting their storage infrastructure and the data it contains.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Storage** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name StorageAccounts --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Storage** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name StorageAccounts --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "storage" {
              tier          = "Standard"
              resource_type = "StorageAccounts"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-storage-introduction
        title: Overview of Microsoft Defender for Storage
  - uid: mondoo-azure-security-defender-for-keyvault-enabled
    title: Ensure Microsoft Defender for Key Vault is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForKeyVaults["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Key Vault is enabled to detect unusual and potentially harmful attempts to access or exploit Azure Key Vault resources.

        **Why this matters**

        Enabling Defender for Key Vault provides several critical benefits:

        - **Anomalous access detection**: Identifies unusual access patterns to secrets, keys, and certificates that could indicate credential theft or unauthorized access.
        - **Suspicious operations**: Detects unusual operations such as bulk secret access, access from unusual locations, or access using suspicious identities.
        - **Threat intelligence**: Correlates Key Vault access patterns with known threat indicators.
        - **Compliance alignment**: Many security frameworks require advanced threat monitoring for sensitive credential stores.

        By enabling Defender for Key Vault, organizations can detect and respond to threats targeting their most sensitive cryptographic materials and secrets.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Key Vault** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name KeyVaults --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Key Vault** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name KeyVaults --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "key_vaults" {
              tier          = "Standard"
              resource_type = "KeyVaults"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-key-vault-introduction
        title: Overview of Microsoft Defender for Key Vault
  - uid: mondoo-azure-security-defender-for-containers-enabled
    title: Ensure Microsoft Defender for Containers is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForContainers["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Containers is enabled to provide threat protection for Azure Kubernetes Service (AKS) clusters and container workloads.

        **Why this matters**

        Enabling Defender for Containers provides several critical benefits:

        - **Runtime threat detection**: Detects threats at the container and cluster level, including suspicious process execution, shell escapes, and privilege escalation attempts.
        - **Vulnerability scanning**: Scans container images for known vulnerabilities in registries and running workloads.
        - **Kubernetes audit log analysis**: Monitors Kubernetes API server audit logs for suspicious activities and policy violations.
        - **Network anomaly detection**: Identifies unusual network traffic patterns between containers and external endpoints.

        By enabling Defender for Containers, organizations can detect and respond to threats across their containerized workloads and Kubernetes infrastructure.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Containers** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name Containers --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Containers** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name Containers --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "containers" {
              tier          = "Standard"
              resource_type = "Containers"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-containers-introduction
        title: Overview of Microsoft Defender for Containers
  - uid: mondoo-azure-security-defender-for-resource-manager-enabled
    title: Ensure Microsoft Defender for Resource Manager is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForResourceManager["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Resource Manager is enabled to monitor Azure management operations and detect suspicious resource management activities.

        **Why this matters**

        Enabling Defender for Resource Manager provides several critical benefits:

        - **Management plane protection**: Monitors all Azure Resource Manager operations for suspicious patterns, such as operations from unusual IP addresses or unfamiliar locations.
        - **Lateral movement detection**: Identifies attempts to exploit Azure management APIs for lateral movement within the cloud environment.
        - **Persistence detection**: Detects techniques used by attackers to maintain persistent access to Azure resources.
        - **Cryptomining detection**: Identifies resource deployments commonly associated with cryptocurrency mining activities.

        By enabling Defender for Resource Manager, organizations can detect threats targeting the Azure management layer and prevent unauthorized resource manipulation.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Resource Manager** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name Arm --query "pricingTier"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Resource Manager** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name Arm --tier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "arm" {
              tier          = "Standard"
              resource_type = "Arm"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-resource-manager-introduction
        title: Overview of Microsoft Defender for Resource Manager
  - uid: mondoo-azure-security-defender-auto-provisioning-enabled
    title: Ensure auto-provisioning of the monitoring agent is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.monitoringAgentAutoProvision == true
    docs:
      desc: |
        This check ensures that auto-provisioning of the monitoring agent is enabled so that all new and existing virtual machines are automatically configured for security data collection.

        **Why this matters**

        Enabling auto-provisioning of the monitoring agent provides several critical benefits:

        - **Comprehensive coverage**: Ensures that all VMs in the subscription are monitored for security threats without manual intervention.
        - **Consistent security posture**: Eliminates gaps in monitoring that can occur when new VMs are provisioned without manual agent installation.
        - **Reduced operational burden**: Automates the deployment and configuration of monitoring agents, freeing security teams to focus on threat response.
        - **Compliance alignment**: Many security frameworks require consistent monitoring across all compute resources in the environment.

        By enabling auto-provisioning, organizations can ensure that no VM is left unmonitored and that security data collection begins immediately upon resource creation.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Select **Auto provisioning** under **Settings**.
        4. Verify that the Log Analytics agent or Azure Monitor agent auto-provisioning is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security auto-provisioning-setting show --name default --query "autoProvision"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Select **Auto provisioning** under **Settings**.
            4. Set the monitoring agent auto-provisioning to **On**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security auto-provisioning-setting update --name default --auto-provision On
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_auto_provisioning" "example" {
              auto_provision = "On"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/monitoring-components
        title: Auto provisioning agents and extensions from Microsoft Defender for Cloud
  - uid: mondoo-azure-security-aks-rbac-enabled
    title: Ensure RBAC is enabled on Azure Kubernetes Service clusters
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-3-3
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.aks.clusters.all(rbacEnabled == true)
    docs:
      desc: |
        This check ensures that Role-Based Access Control (RBAC) is enabled on all Azure Kubernetes Service (AKS) clusters to enforce proper access control for Kubernetes resources.

        **Why this matters**

        Enabling RBAC on AKS clusters provides several critical benefits:

        - **Access control**: RBAC allows fine-grained control over who can perform what actions within the Kubernetes cluster, enforcing the principle of least privilege.
        - **Reduced attack surface**: Without RBAC, any authenticated user may have unrestricted access to all cluster resources, significantly increasing the risk of unauthorized actions.
        - **Compliance alignment**: Many security standards and frameworks require role-based access control for container orchestration platforms.
        - **Azure AD integration**: RBAC enables integration with Azure Active Directory for centralized identity management and authentication.

        By enabling RBAC, organizations can enforce proper access controls and minimize the risk of unauthorized access to Kubernetes resources.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster.
        3. Go to **Cluster configuration** under **Settings**.
        4. Verify that **Kubernetes RBAC** is enabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az aks list --query "[].{Name:name, ResourceGroup:resourceGroup, RbacEnabled:enableRbac}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            RBAC cannot be disabled after cluster creation. To ensure RBAC is enabled:

            1. When creating a new AKS cluster, navigate to **Kubernetes services**.
            2. Select **Create** and configure your cluster.
            3. Under **Authentication and Authorization**, ensure **Kubernetes RBAC** is enabled.
            4. Complete the cluster creation process.

            For existing clusters without RBAC, you must recreate the cluster with RBAC enabled.
        - id: cli
          desc: |
            **Using Azure CLI**

            When creating a new cluster, RBAC is enabled by default:

            ```bash
            az aks create --resource-group <ResourceGroupName> --name <ClusterName> --enable-rbac
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"
              role_based_access_control_enabled = true

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/aks/manage-azure-rbac
        title: Use Azure RBAC for Kubernetes Authorization
  - uid: mondoo-azure-security-aks-api-server-authorized-ip-ranges
    title: Ensure AKS API server has authorized IP ranges configured
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-6
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
      azure.subscription.aks.clusters.any(apiServerAccessProfile["enablePrivateCluster"] != true)
    mql: |
      azure.subscription.aks.clusters
        .where(apiServerAccessProfile["enablePrivateCluster"] != true)
        .all(apiServerAccessProfile["authorizedIPRanges"] != empty)
    docs:
      desc: |
        This check ensures that non-private AKS clusters have API server authorized IP ranges configured to restrict access to the Kubernetes API server from known, trusted networks. Private clusters are excluded from this check as they use private endpoints for API server access, which provides stronger network isolation.

        **Why this matters**

        Configuring authorized IP ranges for the AKS API server provides several critical benefits:

        - **Reduced attack surface**: Restricting API server access to known IP ranges prevents unauthorized networks from reaching the Kubernetes control plane.
        - **Defense in depth**: Even if API credentials are compromised, attackers cannot access the API server from unauthorized networks.
        - **Compliance alignment**: Many security frameworks require network-level access controls for management interfaces.
        - **Brute force prevention**: Limits the ability of attackers to perform brute force authentication attempts against the API server.

        By configuring authorized IP ranges, organizations can significantly reduce the risk of unauthorized access to their Kubernetes management plane.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Set authorized IP ranges** is enabled and appropriate IP ranges are configured.

        **Automated Audit with Azure CLI:**

        ```bash
        az aks show --resource-group <ResourceGroupName> --name <ClusterName> --query "apiServerAccessProfile.authorizedIpRanges"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Kubernetes services** in the Azure Portal.
            2. Select the AKS cluster.
            3. Go to **Networking** under **Settings**.
            4. Enable **Set authorized IP ranges**.
            5. Enter the trusted IP ranges (e.g., your corporate network CIDR ranges).
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az aks update --resource-group <ResourceGroupName> --name <ClusterName> --api-server-authorized-ip-ranges <IPRange1>,<IPRange2>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"

              api_server_access_profile {
                authorized_ip_ranges = ["10.0.0.0/8", "172.16.0.0/12"]
              }

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/aks/api-server-authorized-ip-ranges
        title: Secure access to the API server using authorized IP address ranges in AKS
  - uid: mondoo-azure-security-aks-network-policy-enabled
    title: Ensure AKS clusters have a network policy configured
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-5
      compliance/iso-27001-2022: iso-27001-2022-a-8-22
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.aks.clusters.all(networkProfile["networkPolicy"] != empty)
    docs:
      desc: |
        This check ensures that AKS clusters have a network policy configured (such as Azure Network Policy or Calico) to control traffic flow between pods.

        **Why this matters**

        Configuring network policies on AKS clusters provides several critical benefits:

        - **Pod-to-pod traffic control**: Network policies allow you to define rules that control which pods can communicate with each other, implementing micro-segmentation.
        - **Lateral movement prevention**: Without network policies, all pods can communicate freely, allowing an attacker who compromises one pod to easily move to others.
        - **Compliance alignment**: Many security frameworks require network segmentation and traffic control for container workloads.
        - **Blast radius reduction**: Network policies limit the impact of a compromised pod by restricting its ability to reach other services in the cluster.

        By configuring network policies, organizations can enforce the principle of least privilege at the network level and reduce the risk of lateral movement within their Kubernetes clusters.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster.
        3. Go to **Networking** under **Settings**.
        4. Verify that a **Network policy** is configured (Azure or Calico).

        **Automated Audit with Azure CLI:**

        ```bash
        az aks show --resource-group <ResourceGroupName> --name <ClusterName> --query "networkProfile.networkPolicy"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            Network policy must be configured at cluster creation time:

            1. Navigate to **Kubernetes services** and select **Create**.
            2. Under **Networking**, select a **Network policy** option (Azure or Calico).
            3. Complete the cluster creation process.

            For existing clusters, network policy cannot be changed. You must recreate the cluster with network policy enabled.
        - id: cli
          desc: |
            **Using Azure CLI**

            When creating a new cluster:

            ```bash
            az aks create --resource-group <ResourceGroupName> --name <ClusterName> --network-plugin azure --network-policy azure
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"

              network_profile {
                network_plugin = "azure"
                network_policy = "azure"
              }

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/aks/use-network-policies
        title: Secure traffic between pods using network policies in AKS
  - uid: mondoo-azure-security-app-service-https-only
    title: Ensure App Service web apps enforce HTTPS
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(properties["httpsOnly"] == true)
    docs:
      desc: |
        This check ensures that Azure App Service web applications are configured to enforce HTTPS-only access, automatically redirecting HTTP requests to HTTPS.

        **Why this matters**

        Enforcing HTTPS for App Service web apps provides several critical benefits:

        - **Data protection**: HTTPS encrypts data in transit, preventing eavesdropping and man-in-the-middle attacks on sensitive information exchanged between clients and the web application.
        - **Authentication integrity**: Without HTTPS, session tokens and authentication cookies can be intercepted, leading to session hijacking.
        - **Compliance alignment**: Many regulatory standards and security frameworks require encryption of data in transit for internet-facing applications.
        - **Trust and credibility**: HTTPS is expected by users and browsers; HTTP-only sites receive security warnings that can damage user trust.

        By enforcing HTTPS, organizations ensure that all traffic to their web applications is encrypted and protected from interception.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select a web app.
        3. Go to **Configuration** > **General settings**.
        4. Verify that **HTTPS Only** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az webapp list --query "[].{Name:name, ResourceGroup:resourceGroup, HttpsOnly:httpsOnly}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the web app.
            3. Go to **Configuration** > **General settings**.
            4. Set **HTTPS Only** to **On**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az webapp update --resource-group <ResourceGroupName> --name <WebAppName> --set httpsOnly=true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-webapp"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id
              https_only          = true

              site_config {}
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/configure-ssl-bindings
        title: Secure a custom DNS name with a TLS/SSL binding in Azure App Service
  - uid: mondoo-azure-security-app-service-ftp-disabled
    title: Ensure App Service FTP basic auth publishing credentials are disabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-9
      compliance/iso-27001-2022: iso-27001-2022-a-5-17
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(ftp.allow == false)
    docs:
      desc: |
        This check ensures that basic authentication for FTP publishing is disabled on Azure App Service web apps, preventing the use of username/password credentials for file deployment.

        **Why this matters**

        Disabling FTP basic auth provides several critical benefits:

        - **Credential security**: FTP basic authentication transmits credentials in an insecure manner and relies on static username/password combinations that can be easily compromised.
        - **Reduced attack surface**: Disabling basic auth forces the use of more secure deployment methods such as Azure AD-based authentication, deployment tokens, or managed identities.
        - **Brute force prevention**: Basic auth credentials are a common target for brute force attacks. Disabling them eliminates this attack vector.
        - **Compliance alignment**: Many security frameworks discourage or prohibit the use of basic authentication for publishing and deployment operations.

        By disabling FTP basic auth, organizations can enforce the use of stronger, more auditable authentication methods for application deployment.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select a web app.
        3. Go to **Configuration** > **General settings**.
        4. Under **Platform settings**, verify that **FTP Basic Auth Publishing Credentials** is set to **Off**.

        **Automated Audit with Azure CLI:**

        ```bash
        az resource show --resource-group <ResourceGroupName> --name ftp --namespace Microsoft.Web --resource-type basicPublishingCredentialsPolicies --parent sites/<WebAppName> --query "properties.allow"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the web app.
            3. Go to **Configuration** > **General settings**.
            4. Under **Platform settings**, set **FTP Basic Auth Publishing Credentials** to **Off**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az resource update --resource-group <ResourceGroupName> --name ftp --namespace Microsoft.Web --resource-type basicPublishingCredentialsPolicies --parent sites/<WebAppName> --set properties.allow=false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-web-app"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id

              site_config {
                ftps_state = "Disabled"
              }
            }
            ```

            For Windows web apps, use `azurerm_windows_web_app` with the same `site_config` block.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/configure-basic-auth-disable
        title: Disable basic authentication in App Service deployments
  - uid: mondoo-azure-security-app-service-scm-disabled
    title: Ensure App Service SCM basic auth publishing credentials are disabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-9
      compliance/iso-27001-2022: iso-27001-2022-a-5-17
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(scm.allow == false)
    docs:
      desc: |
        This check ensures that basic authentication for SCM (Kudu) site publishing is disabled on Azure App Service web apps, preventing the use of username/password credentials for deployment via the SCM endpoint.

        **Why this matters**

        Disabling SCM basic auth provides several critical benefits:

        - **Credential security**: SCM basic authentication uses static credentials that can be compromised through credential stuffing, phishing, or leaks.
        - **Reduced attack surface**: The SCM/Kudu endpoint provides powerful deployment and diagnostic capabilities; securing it with Azure AD authentication is critical.
        - **Deployment security**: Disabling basic auth forces the use of Azure AD-based authentication, which supports MFA, conditional access, and centralized audit logging.
        - **Compliance alignment**: Many security frameworks require strong authentication for all management and deployment interfaces.

        By disabling SCM basic auth, organizations can enforce stronger authentication for the powerful Kudu deployment endpoint.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select a web app.
        3. Go to **Configuration** > **General settings**.
        4. Under **Platform settings**, verify that **SCM Basic Auth Publishing Credentials** is set to **Off**.

        **Automated Audit with Azure CLI:**

        ```bash
        az resource show --resource-group <ResourceGroupName> --name scm --namespace Microsoft.Web --resource-type basicPublishingCredentialsPolicies --parent sites/<WebAppName> --query "properties.allow"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the web app.
            3. Go to **Configuration** > **General settings**.
            4. Under **Platform settings**, set **SCM Basic Auth Publishing Credentials** to **Off**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az resource update --resource-group <ResourceGroupName> --name scm --namespace Microsoft.Web --resource-type basicPublishingCredentialsPolicies --parent sites/<WebAppName> --set properties.allow=false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-web-app"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id

              site_config {}

              # Disable SCM basic auth via azapi_resource
            }

            resource "azapi_update_resource" "disable_scm_basic_auth" {
              type        = "Microsoft.Web/sites/basicPublishingCredentialsPolicies@2023-12-01"
              resource_id = "${azurerm_linux_web_app.example.id}/basicPublishingCredentialsPolicies/scm"

              body = {
                properties = {
                  allow = false
                }
              }
            }
            ```

            For Windows web apps, use `azurerm_windows_web_app` with the same approach.
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/configure-basic-auth-disable
        title: Disable basic authentication in App Service deployments
  - uid: mondoo-azure-security-redis-ssl-only
    title: Ensure Azure Cache for Redis disables the non-SSL port
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cache.redis.all(enableNonSslPort == false)
    docs:
      desc: |
        This check ensures that the non-SSL port (6379) is disabled on Azure Cache for Redis instances, requiring all connections to use TLS-encrypted communication.

        **Why this matters**

        Disabling the non-SSL port provides several critical benefits:

        - **Data protection**: Redis commands and data transmitted over unencrypted connections can be intercepted by attackers, exposing sensitive cached data.
        - **Authentication security**: Redis authentication tokens sent over unencrypted connections are vulnerable to interception.
        - **Compliance alignment**: Many security standards require encryption of data in transit, especially for caching services that may contain sensitive data.
        - **Industry best practice**: Microsoft recommends disabling the non-SSL port and using only TLS-encrypted connections for production Redis deployments.

        By disabling the non-SSL port, organizations ensure that all Redis communication is encrypted, protecting cached data from interception and unauthorized access.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cache for Redis** in the Azure Portal.
        2. Select a Redis cache instance.
        3. Go to **Advanced settings**.
        4. Verify that **Allow access only via SSL** is set to **Yes** (or that the non-SSL port is disabled).

        **Automated Audit with Azure CLI:**

        ```bash
        az redis list --query "[].{Name:name, ResourceGroup:resourceGroup, NonSslPort:enableNonSslPort}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cache for Redis** in the Azure Portal.
            2. Select the Redis cache instance.
            3. Go to **Advanced settings**.
            4. Set **Allow access only via SSL** to **Yes**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az redis update --name <RedisCacheName> --resource-group <ResourceGroupName> --set enableNonSslPort=false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_redis_cache" "example" {
              name                = "example-redis"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              capacity            = 1
              family              = "C"
              sku_name            = "Standard"
              enable_non_ssl_port = false
              minimum_tls_version = "1.2"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/cache-remove-tls-10-11
        title: Remove TLS 1.0 and 1.1 from use with Azure Cache for Redis
  - uid: mondoo-azure-security-redis-public-access-disabled
    title: Ensure Azure Cache for Redis disables public network access
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cache.redis.all(publicNetworkAccess == "Disabled")
    docs:
      desc: |
        This check ensures that public network access is disabled on Azure Cache for Redis instances, requiring connections to go through private endpoints.

        **Why this matters**

        Disabling public network access provides several critical benefits:

        - **Reduced attack surface**: Disabling public access ensures that the Redis cache is not reachable from the public internet, eliminating a major attack vector.
        - **Network isolation**: All access must go through private endpoints within the virtual network, providing strong network-level isolation.
        - **Data protection**: Private endpoints ensure that Redis traffic stays within the Azure backbone network, reducing the risk of data interception.
        - **Compliance alignment**: Many security frameworks require that caching services containing sensitive data are not accessible from the public internet.

        By disabling public network access, organizations can ensure that their Redis caches are only accessible from trusted, internal networks.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cache for Redis** in the Azure Portal.
        2. Select a Redis cache instance.
        3. Go to **Private endpoint connections** under **Settings**.
        4. Verify that public network access is disabled and private endpoints are configured.

        **Automated Audit with Azure CLI:**

        ```bash
        az redis list --query "[].{Name:name, ResourceGroup:resourceGroup, PublicNetworkAccess:publicNetworkAccess}" -o table
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cache for Redis** in the Azure Portal.
            2. Select the Redis cache instance.
            3. Go to **Private endpoint connections** under **Settings**.
            4. Set **Public network access** to **Disabled**.
            5. Configure a private endpoint for the Redis cache.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az redis update --name <RedisCacheName> --resource-group <ResourceGroupName> --set publicNetworkAccess=Disabled
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_redis_cache" "example" {
              name                          = "example-redis"
              location                      = azurerm_resource_group.example.location
              resource_group_name           = azurerm_resource_group.example.name
              capacity                      = 1
              family                        = "C"
              sku_name                      = "Standard"
              public_network_access_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/cache-private-link
        title: Azure Cache for Redis with Azure Private Link
  - uid: mondoo-azure-security-aks-private-cluster-enabled
    title: Ensure AKS clusters are configured as private clusters
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.aks.clusters.all(apiServerAccessProfile["enablePrivateCluster"] == true)
    docs:
      desc: |
        This check ensures that Azure Kubernetes Service (AKS) clusters are configured as private clusters, making the API server accessible only through private endpoints within the virtual network.

        **Why this matters**

        Configuring AKS clusters as private clusters provides several critical benefits:

        - **Reduced attack surface**: Private clusters remove the API server's public endpoint, preventing access from the public internet and eliminating a major attack vector.
        - **Network isolation**: All communication between the API server and node pools traverses the Microsoft backbone network through private link, ensuring traffic never leaves the Azure network.
        - **Data protection**: Sensitive Kubernetes API traffic, including authentication tokens and configuration data, is never exposed to the public internet.
        - **Compliance alignment**: Many regulatory standards and security frameworks require management interfaces to be inaccessible from the public internet.

        By configuring AKS clusters as private clusters, organizations can significantly reduce the risk of unauthorized access to the Kubernetes control plane.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Private cluster** is enabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az aks list --query "[].{Name:name, ResourceGroup:resourceGroup, PrivateCluster:apiServerAccessProfile.enablePrivateCluster}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzAksCluster | Select-Object Name, ResourceGroupName, @{Name="PrivateCluster"; Expression={$_.ApiServerAccessProfile.EnablePrivateCluster}}
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            Private cluster must be configured at cluster creation time:

            1. Navigate to **Kubernetes services** and select **Create**.
            2. Under **Networking**, enable **Private cluster**.
            3. Complete the cluster creation process.

            For existing public clusters, you must recreate the cluster as a private cluster.
        - id: cli
          desc: |
            **Using Azure CLI**

            When creating a new cluster:

            ```bash
            az aks create --resource-group <ResourceGroupName> --name <ClusterName> --enable-private-cluster
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            New-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> -EnablePrivateCluster
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"
              private_cluster_enabled = true

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/aks/private-clusters
        title: Create a private Azure Kubernetes Service (AKS) cluster
  - uid: mondoo-azure-security-aks-run-command-disabled
    title: Ensure run command is disabled on AKS clusters
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-6
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.aks.clusters.all(securityProfile["runCommandDisabled"] == true)
    docs:
      desc: |
        This check ensures that the run command feature is disabled on Azure Kubernetes Service (AKS) clusters, preventing remote command execution through the Azure API.

        **Why this matters**

        Disabling the run command on AKS clusters provides several critical benefits:

        - **Reduced attack surface**: The run command feature allows executing commands inside the cluster through the Azure API, bypassing Kubernetes RBAC and network policies. Disabling it removes this privileged access path.
        - **Access control enforcement**: With run command enabled, users with Azure-level permissions can bypass Kubernetes-level access controls, undermining the cluster's security model.
        - **Audit integrity**: Commands executed via the run command feature may not be captured by Kubernetes audit logging, creating blind spots in security monitoring.
        - **Compliance alignment**: Many security frameworks require that all management access to container orchestration platforms is properly controlled and auditable.

        By disabling the run command, organizations ensure that all cluster access goes through properly configured and auditable Kubernetes authentication and authorization mechanisms.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster.
        3. Go to **Cluster configuration** under **Settings**.
        4. Verify that **Run command** is disabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az aks show --resource-group <ResourceGroupName> --name <ClusterName> --query "securityProfile.runCommandDisabled"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> | Select-Object -ExpandProperty SecurityProfile | Select-Object RunCommandDisabled
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Kubernetes services** in the Azure Portal.
            2. Select the AKS cluster.
            3. Go to **Cluster configuration** under **Settings**.
            4. Set **Run command** to **Disabled**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az aks update --resource-group <ResourceGroupName> --name <ClusterName> --disable-run-command
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> -DisableRunCommand
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"
              run_command_enabled = false

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/aks/access-private-cluster
        title: Access a private AKS cluster using run command
  - uid: mondoo-azure-security-aks-azure-policy-addon-enabled
    title: Ensure Azure Policy add-on is enabled for AKS clusters
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc7-1-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-9
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.aks.clusters.all(addonProfiles.any(_["azurepolicy"]["enabled"] == true))
    docs:
      desc: |
        This check ensures that the Azure Policy add-on is enabled on Azure Kubernetes Service (AKS) clusters, allowing organizations to enforce governance and compliance policies at the cluster level.

        **Why this matters**

        Enabling the Azure Policy add-on for AKS clusters provides several critical benefits:

        - **Centralized governance**: Azure Policy provides a centralized way to enforce organizational standards and assess compliance across all AKS clusters at scale.
        - **Built-in policy library**: Azure provides a rich library of built-in policies for Kubernetes, covering security, networking, and resource management best practices.
        - **Real-time enforcement**: The add-on uses Open Policy Agent (OPA) Gatekeeper to enforce policies in real-time, preventing non-compliant resources from being deployed.
        - **Compliance alignment**: Azure Policy integration enables continuous compliance assessment and reporting against regulatory standards and security frameworks.

        By enabling the Azure Policy add-on, organizations can enforce consistent security and governance policies across their Kubernetes clusters.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster.
        3. Go to **Policies** under **Settings**.
        4. Verify that the **Azure Policy add-on** is enabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az aks show --resource-group <ResourceGroupName> --name <ClusterName> --query "addonProfiles.azurepolicy.enabled"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> | Select-Object -ExpandProperty AddonProfiles
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Kubernetes services** in the Azure Portal.
            2. Select the AKS cluster.
            3. Go to **Policies** under **Settings**.
            4. Select **Enable** to activate the Azure Policy add-on.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            For an existing cluster:

            ```bash
            az aks enable-addons --resource-group <ResourceGroupName> --name <ClusterName> --addons azure-policy
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> -EnableAzurePolicy
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"

              azure_policy_enabled = true

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/governance/policy/concepts/policy-for-kubernetes
        title: Understand Azure Policy for Kubernetes clusters
  - uid: mondoo-azure-security-aks-private-cluster-public-fqdn-disabled
    title: Ensure private AKS clusters do not expose a public FQDN
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.aks.clusters.where(apiServerAccessProfile["enablePrivateCluster"] == true).all(apiServerAccessProfile["enablePrivateClusterPublicFQDN"] == false)
    docs:
      desc: |
        This check ensures that private AKS clusters do not expose a public fully qualified domain name (FQDN), preventing DNS resolution of the API server from outside the private network.

        **Why this matters**

        Disabling the public FQDN on private AKS clusters provides several critical benefits:

        - **Reduced information disclosure**: A public FQDN allows anyone to resolve the API server's DNS name, even if the API server itself is not publicly accessible. This reveals information about the cluster's existence and configuration.
        - **Defense in depth**: Removing the public FQDN adds an additional layer of network security on top of the private cluster configuration, making it harder for attackers to discover and target the cluster.
        - **DNS-level isolation**: Without a public FQDN, the API server can only be resolved through private DNS zones, ensuring complete network isolation.
        - **Compliance alignment**: Many security frameworks require that management interfaces for sensitive infrastructure are not discoverable from the public internet.

        By disabling the public FQDN, organizations ensure that their private AKS clusters are fully isolated and not discoverable through public DNS resolution.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Kubernetes services** in the Azure Portal.
        2. Select an AKS cluster that is configured as a private cluster.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Private cluster public FQDN** is disabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az aks show --resource-group <ResourceGroupName> --name <ClusterName> --query "apiServerAccessProfile.enablePrivateClusterPublicFQDN"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> | Select-Object -ExpandProperty ApiServerAccessProfile | Select-Object EnablePrivateClusterPublicFqdn
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Kubernetes services** in the Azure Portal.
            2. Select the private AKS cluster.
            3. Go to **Networking** under **Settings**.
            4. Disable **Private cluster public FQDN**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az aks update --resource-group <ResourceGroupName> --name <ClusterName> --disable-public-fqdn
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzAksCluster -ResourceGroupName <ResourceGroupName> -Name <ClusterName> -DisablePublicFqdn
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_kubernetes_cluster" "example" {
              name                = "example-aks"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              dns_prefix          = "example"
              private_cluster_enabled             = true
              private_cluster_public_fqdn_enabled = false

              default_node_pool {
                name       = "default"
                node_count = 1
                vm_size    = "Standard_D2_v2"
              }

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/aks/private-clusters
        title: Create a private Azure Kubernetes Service (AKS) cluster
  - uid: mondoo-azure-security-app-service-client-cert-enabled
    title: Ensure client certificate authentication is enabled for App Service web apps
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-5
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(properties["clientCertEnabled"] == true)
    docs:
      desc: |
        This check ensures that client certificate authentication (mutual TLS) is enabled for Azure App Service web applications, requiring clients to present a valid certificate to establish a connection.

        **Why this matters**

        Enabling client certificate authentication provides several critical benefits:

        - **Mutual authentication**: Client certificates ensure both the client and server verify each other's identity, providing stronger authentication than username/password or token-based methods alone.
        - **Reduced attack surface**: By requiring a valid client certificate, unauthorized clients are blocked at the TLS handshake level before reaching the application layer.
        - **Phishing resistance**: Client certificates cannot be phished like passwords or tokens, as they are bound to the client device's certificate store.
        - **Compliance alignment**: Many regulatory standards and security frameworks require mutual TLS for sensitive applications handling financial, healthcare, or government data.

        By enabling client certificate authentication, organizations add a strong layer of identity verification that complements other authentication mechanisms.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select a web app.
        3. Go to **Configuration** > **General settings**.
        4. Verify that **Client certificate mode** is set to **Require**.

        **Automated Audit with Azure CLI:**

        ```bash
        az webapp list --query "[].{Name:name, ResourceGroup:resourceGroup, ClientCertEnabled:clientCertEnabled}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzWebApp | Select-Object Name, ResourceGroup, ClientCertEnabled
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the web app.
            3. Go to **Configuration** > **General settings**.
            4. Set **Client certificate mode** to **Require**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az webapp update --resource-group <ResourceGroupName> --name <WebAppName> --set clientCertEnabled=true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzWebApp -ResourceGroupName <ResourceGroupName> -Name <WebAppName> -ClientCertEnabled $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                       = "example-webapp"
              resource_group_name        = azurerm_resource_group.example.name
              location                   = azurerm_resource_group.example.location
              service_plan_id            = azurerm_service_plan.example.id
              client_certificate_enabled = true
              client_certificate_mode    = "Required"

              site_config {}
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/app-service-web-configure-tls-mutual-auth
        title: Configure TLS mutual authentication for Azure App Service
  - uid: mondoo-azure-security-app-service-remote-debugging-disabled
    title: Ensure remote debugging is disabled for App Service web apps
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-6
      compliance/iso-27001-2022: iso-27001-2022-a-8-9
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(configuration.properties["remoteDebuggingEnabled"] == false)
    docs:
      desc: |
        This check ensures that remote debugging is disabled for Azure App Service web applications, preventing the exposure of debugging ports and interfaces to the network.

        **Why this matters**

        Disabling remote debugging provides several critical benefits:

        - **Reduced attack surface**: Remote debugging opens additional ports and services on the application, providing attackers with more potential entry points.
        - **Prevents unauthorized access**: Debugging interfaces often provide elevated access to application internals, memory, and configuration, which can be exploited by attackers.
        - **Performance protection**: Remote debugging can significantly impact application performance and stability, making it unsuitable for production environments.
        - **Compliance alignment**: Many security frameworks require that debugging features are disabled in production environments to reduce the risk of information disclosure and unauthorized access.

        By disabling remote debugging, organizations eliminate an unnecessary attack surface and ensure their production applications are not exposing sensitive diagnostic interfaces.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select a web app.
        3. Go to **Configuration** > **General settings**.
        4. Verify that **Remote debugging** is set to **Off**.

        **Automated Audit with Azure CLI:**

        ```bash
        az webapp config show --resource-group <ResourceGroupName> --name <WebAppName> --query "remoteDebuggingEnabled"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzWebApp -ResourceGroupName <ResourceGroupName> -Name <WebAppName> | Select-Object -ExpandProperty SiteConfig | Select-Object RemoteDebuggingEnabled
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the web app.
            3. Go to **Configuration** > **General settings**.
            4. Set **Remote debugging** to **Off**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az webapp config set --resource-group <ResourceGroupName> --name <WebAppName> --remote-debugging-enabled false
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzWebApp -ResourceGroupName <ResourceGroupName> -Name <WebAppName> -RemoteDebuggingEnabled $false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-webapp"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id

              site_config {
                remote_debugging_enabled = false
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/overview-security
        title: Azure App Service Security
  - uid: mondoo-azure-security-app-service-http20-enabled
    title: Ensure HTTP 2.0 is enabled for App Service web apps
    impact: 40
    tags:
      compliance/soc2-2017: soc2-control-cc7-1-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-9
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(configuration.properties["http20Enabled"] == true)
    docs:
      desc: |
        This check ensures that HTTP 2.0 is enabled for Azure App Service web applications, providing improved performance and security features over HTTP 1.1.

        **Why this matters**

        Enabling HTTP 2.0 for App Service web apps provides several critical benefits:

        - **Improved security**: HTTP 2.0 requires TLS encryption by default in most implementations, ensuring data is always protected in transit.
        - **Header compression**: HTTP 2.0 uses HPACK header compression, reducing the overhead of transmitting repetitive headers and mitigating certain header-based attacks.
        - **Multiplexing**: HTTP 2.0 supports multiplexing multiple requests over a single connection, reducing the attack surface created by multiple simultaneous connections.
        - **Performance improvements**: Binary framing, server push, and stream prioritization improve application performance, reducing the window of opportunity for certain time-based attacks.

        By enabling HTTP 2.0, organizations benefit from modern protocol security features while also improving application performance.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select a web app.
        3. Go to **Configuration** > **General settings**.
        4. Verify that **HTTP version** is set to **2.0**.

        **Automated Audit with Azure CLI:**

        ```bash
        az webapp config show --resource-group <ResourceGroupName> --name <WebAppName> --query "http20Enabled"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzWebApp -ResourceGroupName <ResourceGroupName> -Name <WebAppName> | Select-Object -ExpandProperty SiteConfig | Select-Object Http20Enabled
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the web app.
            3. Go to **Configuration** > **General settings**.
            4. Set **HTTP version** to **2.0**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az webapp config set --resource-group <ResourceGroupName> --name <WebAppName> --http20-enabled true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzWebApp -ResourceGroupName <ResourceGroupName> -Name <WebAppName> -Http20Enabled $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-webapp"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id

              site_config {
                http2_enabled = true
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/overview-security
        title: Azure App Service Security
  - uid: mondoo-azure-security-app-service-ftps-required
    title: Ensure App Service apps require FTPS for file deployment
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(configuration.properties["ftpsState"] != "AllAllowed")
    docs:
      desc: |
        This check ensures that Azure App Service apps do not allow unencrypted FTP connections for file deployment, requiring either FTPS (FTP over TLS) or disabling FTP entirely.

        **Why this matters**

        Requiring FTPS or disabling FTP entirely provides several critical benefits:

        - **Data protection**: Plain FTP transmits files and credentials in cleartext, making them vulnerable to interception. FTPS encrypts the connection using TLS.
        - **Credential security**: FTP credentials sent over unencrypted connections can be captured by network-level attackers, leading to unauthorized access to the deployment pipeline.
        - **Compliance alignment**: Many security frameworks and regulatory standards prohibit the use of unencrypted file transfer protocols for application deployment.
        - **Defense in depth**: Even when FTP basic auth is disabled, ensuring the protocol itself requires encryption adds an additional layer of protection.

        The `ftpsState` setting should be set to `FtpsOnly` (to allow only encrypted FTP connections) or `Disabled` (to block FTP entirely). The value `AllAllowed` permits unencrypted FTP and should be avoided.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select an app.
        3. Go to **Configuration** > **General settings**.
        4. Under **Platform settings**, verify that **FTP state** is set to **FTPS Only** or **Disabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az webapp config show --resource-group <ResourceGroupName> --name <AppName> --query "ftpsState"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the app.
            3. Go to **Configuration** > **General settings**.
            4. Under **Platform settings**, set **FTP state** to **FTPS Only** or **Disabled**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az webapp config set --resource-group <ResourceGroupName> --name <AppName> --ftps-state FtpsOnly
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-app"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id

              site_config {
                ftps_state = "FtpsOnly"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/deploy-ftp
        title: Deploy content using FTP/S - Azure App Service
  - uid: mondoo-azure-security-app-service-cors-no-wildcard
    title: Ensure App Service apps do not allow CORS access from all origins
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-3-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.all(
        configuration.properties["cors"] == null ||
        configuration.properties["cors"]["allowedOrigins"] == null ||
        configuration.properties["cors"]["allowedOrigins"].none(_ == "*")
      )
    docs:
      desc: |
        This check ensures that Azure App Service apps do not have Cross-Origin Resource Sharing (CORS) configured with a wildcard (`*`) origin, which would allow any website to make cross-origin requests to the application.

        **Why this matters**

        Restricting CORS origins provides several critical benefits:

        - **Cross-site attack prevention**: A wildcard CORS origin allows any website to make authenticated requests to the application, which can be exploited in cross-site request forgery and data exfiltration attacks.
        - **Data protection**: With wildcard CORS, a malicious website can read API responses from the application if the user is authenticated, potentially leaking sensitive data.
        - **Least privilege access**: CORS should only allow specific, trusted origins that legitimately need to make cross-origin requests to the application.
        - **Compliance alignment**: Many security frameworks require that cross-origin access is restricted to known and trusted domains.

        CORS should be configured with specific, trusted origin domains rather than using the wildcard `*` character.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **App Services** in the Azure Portal.
        2. Select an app.
        3. Go to **API** > **CORS**.
        4. Verify that the **Allowed Origins** list does not contain `*`.

        **Automated Audit with Azure CLI:**

        ```bash
        az webapp cors show --resource-group <ResourceGroupName> --name <AppName> --query "allowedOrigins"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **App Services** in the Azure Portal.
            2. Select the app.
            3. Go to **API** > **CORS**.
            4. Remove the `*` entry from **Allowed Origins**.
            5. Add only specific, trusted origin domains.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az webapp cors remove --resource-group <ResourceGroupName> --name <AppName> --allowed-origins "*"
            az webapp cors add --resource-group <ResourceGroupName> --name <AppName> --allowed-origins "https://trusted-domain.com"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_web_app" "example" {
              name                = "example-app"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id

              site_config {
                cors {
                  allowed_origins = ["https://trusted-domain.com"]
                }
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-rest-api
        title: CORS in Azure App Service
  - uid: mondoo-azure-security-function-app-authentication-enabled
    title: Ensure Azure Function apps have authentication enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-5
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.where(kind == /functionapp/).all(authenticationSettings.properties["enabled"] == true)
    docs:
      desc: |
        This check ensures that Azure Function apps have App Service Authentication (Easy Auth) enabled, requiring callers to authenticate before reaching the function endpoints.

        **Why this matters**

        Enabling authentication on Function apps provides several critical benefits:

        - **Unauthorized access prevention**: Without authentication, Function app HTTP endpoints are publicly accessible to anyone who knows the URL, allowing unauthenticated invocation of functions.
        - **Identity verification**: App Service Authentication integrates with Microsoft Entra ID and other identity providers, ensuring that only verified users and services can invoke functions.
        - **Centralized access control**: Authentication at the platform level provides a consistent security layer independent of function code, reducing the risk of authentication bypass in application logic.
        - **Audit trail**: Authenticated requests include identity information, enabling comprehensive audit logging of who invoked which functions and when.

        By enabling App Service Authentication, organizations ensure that their Function apps require valid credentials before processing any requests.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Function Apps** in the Azure Portal.
        2. Select a function app.
        3. Go to **Authentication** under **Settings**.
        4. Verify that an identity provider is configured and authentication is enabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az functionapp auth show --resource-group <ResourceGroupName> --name <FunctionAppName> --query "enabled"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Function Apps** in the Azure Portal.
            2. Select the function app.
            3. Go to **Authentication** under **Settings**.
            4. Select **Add identity provider**.
            5. Configure Microsoft Entra ID or another identity provider.
            6. Set **Restrict access** to **Require authentication**.
            7. Select **Add**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az functionapp auth update --resource-group <ResourceGroupName> --name <FunctionAppName> --enabled true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_linux_function_app" "example" {
              name                = "example-function"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location
              service_plan_id     = azurerm_service_plan.example.id
              storage_account_name       = azurerm_storage_account.example.name
              storage_account_access_key = azurerm_storage_account.example.primary_access_key

              site_config {}

              auth_settings {
                enabled = true
                active_directory {
                  client_id = "<ClientID>"
                }
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/overview-authentication-authorization
        title: Authentication and authorization in Azure App Service and Azure Functions
  - uid: mondoo-azure-security-function-app-private-endpoints
    title: Ensure Azure Function apps use private endpoints
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.web.apps.where(kind == /functionapp/).all(privateEndpointConnections.length > 0)
    docs:
      desc: |
        This check ensures that Azure Function apps are configured with private endpoints, restricting network access to only traffic from within the virtual network.

        **Why this matters**

        Using private endpoints for Function apps provides several critical benefits:

        - **Network isolation**: Private endpoints ensure that the Function app is only accessible from within a virtual network, removing exposure to the public internet.
        - **Data exfiltration prevention**: By restricting network access to private endpoints, organizations prevent data from being sent to unauthorized destinations outside the virtual network.
        - **Reduced attack surface**: Removing public internet access eliminates a broad class of attacks including DDoS, port scanning, and opportunistic exploitation attempts.
        - **Compliance alignment**: Many regulatory frameworks require that serverless compute resources handling sensitive data are not exposed to the public internet.

        By configuring private endpoints, organizations ensure that their Function apps are only reachable through controlled, private network paths.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Function Apps** in the Azure Portal.
        2. Select a function app.
        3. Go to **Networking** under **Settings**.
        4. Under **Inbound traffic**, verify that **Private endpoints** are configured.

        **Automated Audit with Azure CLI:**

        ```bash
        az functionapp show --resource-group <ResourceGroupName> --name <FunctionAppName> --query "privateEndpointConnections"
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Function Apps** in the Azure Portal.
            2. Select the function app.
            3. Go to **Networking** under **Settings**.
            4. Under **Inbound traffic**, select **Private endpoints**.
            5. Select **Add** to create a new private endpoint.
            6. Configure the virtual network, subnet, and DNS settings.
            7. Select **OK**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network private-endpoint create --resource-group <ResourceGroupName> --name <PrivateEndpointName> --vnet-name <VNetName> --subnet <SubnetName> --private-connection-resource-id <FunctionAppResourceId> --group-id sites --connection-name <ConnectionName>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_private_endpoint" "example" {
              name                = "example-pe"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              subnet_id           = azurerm_subnet.example.id

              private_service_connection {
                name                           = "example-connection"
                private_connection_resource_id = azurerm_linux_function_app.example.id
                subresource_names              = ["sites"]
                is_manual_connection           = false
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/app-service/networking/private-endpoint
        title: Using private endpoints for Azure App Service
  - uid: mondoo-azure-security-redis-min-tls-version
    title: Ensure Azure Cache for Redis uses minimum TLS version 1.2
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cache.redis.all(properties["minimumTlsVersion"] == "1.2")
    docs:
      desc: |
        This check ensures that Azure Cache for Redis instances are configured to require a minimum TLS version of 1.2 for all connections, preventing the use of older, vulnerable TLS versions.

        **Why this matters**

        Enforcing TLS 1.2 as the minimum version provides several critical benefits:

        - **Protection against known vulnerabilities**: TLS 1.0 and 1.1 have known vulnerabilities such as BEAST, POODLE, and others that can be exploited to intercept or manipulate encrypted traffic.
        - **Stronger encryption**: TLS 1.2 provides stronger cipher suites and encryption algorithms, ensuring that data transmitted to and from Redis is well protected.
        - **Compliance alignment**: Many regulatory standards including PCI DSS, HIPAA, and NIST require the use of TLS 1.2 or later for encryption of data in transit.
        - **Industry deprecation**: Major browsers and cloud providers have deprecated TLS 1.0 and 1.1, and Microsoft recommends TLS 1.2 as the minimum version for Azure services.

        By enforcing TLS 1.2, organizations ensure that Redis connections use modern, secure encryption protocols.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cache for Redis** in the Azure Portal.
        2. Select a Redis cache instance.
        3. Go to **Advanced settings**.
        4. Verify that **Minimum TLS version** is set to **1.2**.

        **Automated Audit with Azure CLI:**

        ```bash
        az redis list --query "[].{Name:name, ResourceGroup:resourceGroup, MinTlsVersion:minimumTlsVersion}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzRedisCache | Select-Object Name, ResourceGroupName, MinimumTlsVersion
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cache for Redis** in the Azure Portal.
            2. Select the Redis cache instance.
            3. Go to **Advanced settings**.
            4. Set **Minimum TLS version** to **1.2**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az redis update --name <RedisCacheName> --resource-group <ResourceGroupName> --set minimumTlsVersion=1.2
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzRedisCache -ResourceGroupName <ResourceGroupName> -Name <RedisCacheName> -MinimumTlsVersion "1.2"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_redis_cache" "example" {
              name                = "example-redis"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              capacity            = 1
              family              = "C"
              sku_name            = "Standard"
              minimum_tls_version = "1.2"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/cache-remove-tls-10-11
        title: Remove TLS 1.0 and 1.1 from use with Azure Cache for Redis
  - uid: mondoo-azure-security-redis-latest-version
    title: Ensure Azure Cache for Redis uses a supported version
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc7-1-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-8
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cache.redis.all(semver(redisVersion) >= semver("6"))
    docs:
      desc: |
        This check ensures that Azure Cache for Redis instances are running a supported version (version 6 or later), as older versions may lack important security patches and features.

        **Why this matters**

        Using a supported Redis version provides several critical benefits:

        - **Security patches**: Older, unsupported Redis versions no longer receive security patches, leaving them vulnerable to known exploits and attacks.
        - **Modern security features**: Redis 6 introduced important security improvements including ACL-based authentication, which provides fine-grained access control compared to the single-password model of older versions.
        - **TLS improvements**: Newer Redis versions include improved TLS support and performance optimizations for encrypted connections.
        - **Compliance alignment**: Many security frameworks require the use of supported and actively maintained software versions to ensure timely access to security updates.

        By ensuring Redis instances use a supported version, organizations maintain access to critical security updates and benefit from modern security capabilities.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cache for Redis** in the Azure Portal.
        2. Select a Redis cache instance.
        3. On the **Overview** page, verify the **Redis version** is 6 or later.

        **Automated Audit with Azure CLI:**

        ```bash
        az redis list --query "[].{Name:name, ResourceGroup:resourceGroup, RedisVersion:redisVersion}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzRedisCache | Select-Object Name, ResourceGroupName, RedisVersion
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cache for Redis** in the Azure Portal.
            2. Select the Redis cache instance.
            3. Go to **Advanced settings**.
            4. Select **Redis version 6** or later.
            5. Select **Save**.

            Note: Upgrading the Redis version may require a brief period of downtime. Plan the upgrade during a maintenance window.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az redis update --name <RedisCacheName> --resource-group <ResourceGroupName> --set redisVersion=6
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzRedisCache -ResourceGroupName <ResourceGroupName> -Name <RedisCacheName> -RedisVersion "6"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_redis_cache" "example" {
              name                = "example-redis"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              capacity            = 1
              family              = "C"
              sku_name            = "Standard"
              redis_version       = "6"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/cache-overview
        title: About Azure Cache for Redis
  - uid: mondoo-azure-security-storage-cross-tenant-replication-disabled
    title: Ensure cross-tenant replication is disabled for Azure Storage accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-7
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties["allowCrossTenantReplication"] == false
    docs:
      desc: |
        This check ensures that cross-tenant replication is disabled for Azure Storage accounts, preventing data from being replicated to storage accounts in different Microsoft Entra ID tenants.

        **Why this matters**

        Disabling cross-tenant replication provides several critical benefits:

        - **Data sovereignty**: Prevents storage account data from being replicated outside the organization's tenant boundary, ensuring data stays within trusted environments.
        - **Reduced data exfiltration risk**: Cross-tenant replication could be exploited to copy data to unauthorized tenants, enabling data theft or leakage.
        - **Compliance alignment**: Many regulatory frameworks require strict controls over where data is stored and replicated, especially across organizational boundaries.
        - **Least privilege access**: Restricting replication to within the same tenant follows the principle of least privilege by limiting data movement to only trusted environments.

        By disabling cross-tenant replication, organizations can ensure that their storage account data remains within their Microsoft Entra ID tenant, reducing the risk of unauthorized data movement.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage accounts** in the Azure Portal.
        2. Select the storage account.
        3. Go to **Configuration** under **Settings**.
        4. Verify that **Allow cross-tenant replication** is set to **Disabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az storage account show --name <StorageAccountName> --resource-group <ResourceGroupName> --query "allowCrossTenantReplication"
        ```

        **Using PowerShell**

        ```powershell
        Get-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> | Select-Object AllowCrossTenantReplication
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage accounts** in the Azure Portal.
            2. Select the storage account.
            3. Go to **Configuration** under **Settings**.
            4. Set **Allow cross-tenant replication** to **Disabled**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az storage account update --name <StorageAccountName> --resource-group <ResourceGroupName> --allow-cross-tenant-replication false
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> -AllowCrossTenantReplication $false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
              name                            = "examplestorageaccount"
              resource_group_name             = azurerm_resource_group.example.name
              location                        = azurerm_resource_group.example.location
              account_tier                    = "Standard"
              account_replication_type        = "LRS"
              cross_tenant_replication_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/storage-security-guide
        title: Azure Storage Security Guide
  - uid: mondoo-azure-security-storage-sftp-disabled
    title: Ensure SFTP is disabled on Azure Storage accounts unless required
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-6
      compliance/iso-27001-2022: iso-27001-2022-a-8-9
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties["isSftpEnabled"] == false
    docs:
      desc: |
        This check ensures that SFTP (SSH File Transfer Protocol) is disabled on Azure Storage accounts unless there is a specific business requirement for it, reducing the attack surface.

        **Why this matters**

        Disabling SFTP when not required provides several critical benefits:

        - **Reduced attack surface**: SFTP opens an additional access vector to your storage account that can be targeted by attackers through brute-force or credential-based attacks.
        - **Unnecessary exposure**: If SFTP is not actively used, leaving it enabled provides an unnecessary entry point into storage resources.
        - **Authentication risks**: SFTP supports local user authentication with passwords or SSH keys, bypassing Azure AD-based access controls and conditional access policies.
        - **Compliance alignment**: Security best practices recommend disabling unused services and protocols to minimize potential attack vectors.

        By disabling SFTP when not required, organizations can reduce the attack surface of their storage accounts and ensure that only necessary access methods are available.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage accounts** in the Azure Portal.
        2. Select the storage account.
        3. Go to **SFTP** under **Settings**.
        4. Verify that **SFTP** is set to **Disabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az storage account show --name <StorageAccountName> --resource-group <ResourceGroupName> --query "isSftpEnabled"
        ```

        **Using PowerShell**

        ```powershell
        Get-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> | Select-Object EnableSftp
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage accounts** in the Azure Portal.
            2. Select the storage account.
            3. Go to **SFTP** under **Settings**.
            4. Set **SFTP** to **Disabled**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az storage account update --name <StorageAccountName> --resource-group <ResourceGroupName> --enable-sftp false
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> -EnableSftp $false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
              name                     = "examplestorageaccount"
              resource_group_name      = azurerm_resource_group.example.name
              location                 = azurerm_resource_group.example.location
              account_tier             = "Standard"
              account_replication_type = "LRS"
              sftp_enabled             = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/blobs/secure-file-transfer-protocol-support
        title: SSH File Transfer Protocol (SFTP) support for Azure Blob Storage
  - uid: mondoo-azure-security-storage-shared-key-access-disabled
    title: Ensure shared key access is disabled for Azure Storage accounts
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-9
      compliance/iso-27001-2022: iso-27001-2022-a-5-17
    filters: |
      asset.platform == "azure-storage-account"
    mql: |
      azure.subscription.storage.account.properties["allowSharedKeyAccess"] == false
    docs:
      desc: |
        This check ensures that shared key access is disabled for Azure Storage accounts, requiring all requests to be authorized using Microsoft Entra ID.

        **Why this matters**

        Disabling shared key access provides several critical benefits:

        - **Stronger authentication**: Azure AD provides identity-based authentication with features like multi-factor authentication, conditional access, and fine-grained RBAC that shared keys cannot offer.
        - **Reduced credential exposure**: Shared keys grant full access to the storage account and are difficult to rotate and audit; disabling them eliminates this risk.
        - **Auditability**: Azure AD authentication provides detailed logs of who accessed what resources, unlike shared key access which only identifies the key used.
        - **Compliance alignment**: Many security frameworks recommend or require identity-based authentication over shared secrets for cloud resource access.

        By disabling shared key access, organizations can enforce Azure AD-based authentication for all storage account operations, improving security posture and auditability.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Storage accounts** in the Azure Portal.
        2. Select the storage account.
        3. Go to **Configuration** under **Settings**.
        4. Verify that **Allow storage account key access** is set to **Disabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az storage account show --name <StorageAccountName> --resource-group <ResourceGroupName> --query "allowSharedKeyAccess"
        ```

        **Using PowerShell**

        ```powershell
        Get-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> | Select-Object AllowSharedKeyAccess
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Storage accounts** in the Azure Portal.
            2. Select the storage account.
            3. Go to **Configuration** under **Settings**.
            4. Set **Allow storage account key access** to **Disabled**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az storage account update --name <StorageAccountName> --resource-group <ResourceGroupName> --allow-shared-key-access false
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzStorageAccount -ResourceGroupName <ResourceGroupName> -Name <StorageAccountName> -AllowSharedKeyAccess $false
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_storage_account" "example" {
              name                      = "examplestorageaccount"
              resource_group_name       = azurerm_resource_group.example.name
              location                  = azurerm_resource_group.example.location
              account_tier              = "Standard"
              account_replication_type  = "LRS"
              shared_access_key_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/storage/common/shared-key-authorization-prevent
        title: Prevent Shared Key authorization for an Azure Storage account
  - uid: mondoo-azure-security-compute-vm-no-public-ip
    title: Ensure virtual machines do not have public IP addresses directly attached
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-compute-vm-api"
    mql: |
      azure.subscription.compute.vm.publicIpAddresses.length == 0
    docs:
      desc: |
        This check ensures that Azure virtual machines do not have public IP addresses directly attached, reducing the exposure of compute resources to the public internet.

        **Why this matters**

        Avoiding direct public IP attachment to virtual machines provides several critical security benefits:

        - **Reduced attack surface**: Public IP addresses make VMs directly reachable from the internet, exposing them to port scanning, brute force attacks, and exploitation of unpatched vulnerabilities.
        - **Defense in depth**: Using load balancers, Azure Firewall, or Azure Bastion instead of direct public IPs adds additional layers of security and traffic inspection.
        - **Network segmentation**: Without public IPs, VMs must be accessed through controlled entry points, enforcing proper network architecture and access controls.
        - **Compliance alignment**: Many security frameworks and regulatory standards recommend or require that compute resources are not directly accessible from the public internet.

        By ensuring VMs do not have public IP addresses directly attached, this check helps to minimize the attack surface, enforce proper network architecture, and enhance the overall security posture of Azure virtual machines.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Virtual machines** in the Azure Portal.
        2. Select a virtual machine and access **Networking** under the Settings menu.
        3. Review the network interface configurations and verify that no public IP addresses are directly attached.

        **Automated Audit with Azure CLI:**

        List all VMs and their public IP addresses:

        ```bash
        az vm list-ip-addresses --query "[].{VMName:virtualMachine.name, PublicIPs:virtualMachine.network.publicIpAddresses[].ipAddress}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzVM | ForEach-Object { $vm = $_; $nics = Get-AzNetworkInterface -ResourceId $vm.NetworkProfile.NetworkInterfaces.Id; $nics | ForEach-Object { $_.IpConfigurations | Where-Object { $_.PublicIpAddress } } } | Select-Object Name, PublicIpAddress
        ```

        Ensure no VMs have public IP addresses directly attached.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Virtual machines** in the Azure Portal.
            2. Select the virtual machine with a public IP address.
            3. Go to **Networking** under the Settings menu.
            4. Select the network interface and then select the IP configuration.
            5. Under **Public IP address**, select **Disassociate**.
            6. Save the changes.
            7. Consider using Azure Bastion, a load balancer, or Azure Firewall for secure access.
        - id: cli
          desc: |
            **Using Azure CLI**

            Disassociate a public IP from a VM's network interface:

            ```bash
            az network nic ip-config update --resource-group <ResourceGroupName> --nic-name <NICName> --name <IPConfigName> --remove PublicIpAddress
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $nic = Get-AzNetworkInterface -ResourceGroupName <ResourceGroupName> -Name <NICName>
            $nic.IpConfigurations[0].PublicIpAddress = $null
            Set-AzNetworkInterface -NetworkInterface $nic
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the network interface does not include a public IP address:

            ```hcl
            resource "azurerm_network_interface" "example" {
              name                = "example-nic"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name

              ip_configuration {
                name                          = "internal"
                subnet_id                     = azurerm_subnet.example.id
                private_ip_address_allocation = "Dynamic"
                # Do not include public_ip_address_id
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/virtual-machines/ip-services/associate-public-ip-address-vm
        title: Associate a public IP address to a virtual machine
  - uid: mondoo-azure-security-compute-managed-disks-only
    title: Ensure virtual machines use managed disks
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc7-1-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-9
    filters: |
      asset.platform == "azure-compute-vm-api"
    mql: |
      azure.subscription.compute.vm.osDisk.properties.managedDisk != empty
    docs:
      desc: |
        This check ensures that Azure virtual machines use managed disks instead of unmanaged disks, providing improved reliability, security, and simplified management.

        **Why this matters**

        Using managed disks for virtual machines provides several critical benefits:

        - **Improved security**: Managed disks support Azure Disk Encryption and server-side encryption by default, and they are isolated in Azure Storage to prevent unauthorized access through shared storage accounts.
        - **Higher availability**: Managed disks are designed for 99.999% availability, with automatic replication within the Azure datacenter to protect against hardware failures.
        - **Simplified management**: Managed disks eliminate the need to manage storage accounts, VHD files, and storage account limits, reducing operational complexity.
        - **Scalability**: Managed disks remove the limitations of storage account IOPS and capacity limits that apply to unmanaged disks.
        - **Compliance alignment**: Many security standards recommend using managed disks for their built-in security features and simplified access control.

        By ensuring virtual machines use managed disks, this check helps to improve reliability, simplify management, and enhance the security posture of Azure compute resources.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Virtual machines** in the Azure Portal.
        2. Select a virtual machine and access **Disks** under the Settings menu.
        3. Verify that the OS disk shows a managed disk resource and is not using a VHD in a storage account.

        **Automated Audit with Azure CLI:**

        List all VMs and check for managed disk usage:

        ```bash
        az vm list --query "[].{VMName:name, ResourceGroup:resourceGroup, OSDiskManagedId:storageProfile.osDisk.managedDisk.id}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzVM | Select-Object Name, ResourceGroupName, @{Name="ManagedDisk";Expression={$_.StorageProfile.OsDisk.ManagedDisk.Id}} | Format-Table
        ```

        Ensure the ManagedDisk property is populated for all VMs.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Virtual machines** in the Azure Portal.
            2. Stop (deallocate) the virtual machine.
            3. Select **Disks** under the Settings menu.
            4. Select **Migrate to managed disks** at the top of the blade.
            5. Follow the prompts to complete the migration.
            6. Restart the virtual machine.
        - id: cli
          desc: |
            **Using Azure CLI**

            Convert a VM to use managed disks:

            ```bash
            az vm deallocate --resource-group <ResourceGroupName> --name <VMName>
            az vm convert --resource-group <ResourceGroupName> --name <VMName>
            az vm start --resource-group <ResourceGroupName> --name <VMName>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Stop-AzVM -ResourceGroupName <ResourceGroupName> -Name <VMName> -Force
            ConvertTo-AzVMManagedDisk -ResourceGroupName <ResourceGroupName> -VMName <VMName>
            Start-AzVM -ResourceGroupName <ResourceGroupName> -Name <VMName>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure VMs are configured with managed disks:

            ```hcl
            resource "azurerm_linux_virtual_machine" "example" {
              name                = "example-machine"
              resource_group_name = azurerm_resource_group.example.name
              location            = azurerm_resource_group.example.location

              ...

              os_disk {
                caching              = "ReadWrite"
                storage_account_type = "Standard_LRS"
                # Managed disks are used by default in azurerm provider
              }

              ...
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview
        title: Introduction to Azure managed disks
  - uid: mondoo-azure-security-compute-unattached-disks-encrypted
    title: Ensure unattached disks are encrypted with Customer Managed Keys
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-10
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.compute.disks.where(properties.diskState == "Unattached").all(properties.encryption.type == "EncryptionAtRestWithCustomerKey")
    docs:
      desc: |
        This check ensures that unattached Azure managed disks are encrypted with Customer Managed Keys (CMK), protecting data at rest even when disks are not attached to any virtual machine.

        **Why this matters**

        Encrypting unattached disks with Customer Managed Keys provides several critical benefits:

        - **Data protection**: Unattached disks may contain sensitive data from previous workloads. Without encryption, this data is vulnerable to unauthorized access if the disk is improperly accessed or shared.
        - **Enhanced control**: Using CMK allows organizations to manage their own encryption keys via Azure Key Vault, enabling key rotation and revocation capabilities.
        - **Compliance alignment**: Many regulatory standards require encryption of all data at rest, including data on disks that are not currently in use.
        - **Risk mitigation**: Unattached disks are often overlooked during security reviews. Ensuring they are encrypted reduces the risk of data exposure from forgotten or orphaned resources.

        By ensuring unattached disks are encrypted with Customer Managed Keys, this check helps protect sensitive data on idle resources, meet compliance requirements, and reduce the risk of data exposure.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Disks** in the Azure Portal.
        2. Filter disks by **Disk state** to show only **Unattached** disks.
        3. For each unattached disk, verify that the encryption type is set to **Customer-managed keys**.

        **Automated Audit with Azure CLI:**

        ```bash
        az disk list --query "[?diskState=='Unattached'].{Name:name, ResourceGroup:resourceGroup, EncryptionType:encryption.type}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzDisk | Where-Object { $_.DiskState -eq "Unattached" } | Select-Object Name, ResourceGroupName, @{Name="EncryptionType";Expression={$_.Encryption.Type}}
        ```

        Ensure all unattached disks have the EncryptionType set to EncryptionAtRestWithCustomerKey.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Disks** in the Azure Portal.
            2. Select the unattached disk you wish to encrypt.
            3. In the **Encryption** section, set **Encryption type** to **Customer-managed keys**.
            4. Specify the Azure Key Vault and select the appropriate key.
            5. Save the changes.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az disk update --resource-group <ResourceGroupName> --name <DiskName> --encryption-type EncryptionAtRestWithCustomerKey --disk-encryption-set <DiskEncryptionSetId>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $disk = Get-AzDisk -ResourceGroupName <ResourceGroupName> -DiskName <DiskName>
            $disk.Encryption = New-Object Microsoft.Azure.Management.Compute.Models.Encryption
            $disk.Encryption.Type = "EncryptionAtRestWithCustomerKey"
            $disk.Encryption.DiskEncryptionSetId = "<DiskEncryptionSetId>"
            Update-AzDisk -ResourceGroupName <ResourceGroupName> -DiskName <DiskName> -Disk $disk
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_managed_disk" "example" {
              name                   = "example-unattached-disk"
              location               = azurerm_resource_group.example.location
              resource_group_name    = azurerm_resource_group.example.name
              storage_account_type   = "Standard_LRS"
              create_option          = "Empty"
              disk_size_gb           = 128
              disk_encryption_set_id = azurerm_disk_encryption_set.example.id
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/virtual-machines/disk-encryption-overview
        title: Overview of managed disk encryption options
  - uid: mondoo-azure-security-network-ddos-protection-enabled
    title: Ensure DDoS Protection is enabled on virtual networks
    impact: 40
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.virtualNetworks.all(enableDdosProtection == true)
    docs:
      desc: |
        This check ensures that Azure DDoS Protection is enabled on all virtual networks to defend against distributed denial-of-service attacks.

        **Why this matters**

        Enabling DDoS Protection on virtual networks provides several critical benefits:

        - **Attack mitigation**: Azure DDoS Protection provides always-on monitoring and automatic network attack mitigation, protecting resources from volumetric, protocol, and application layer attacks.
        - **Adaptive tuning**: The protection is automatically tuned to the specific Azure resources in the virtual network, providing customized protection profiles based on traffic patterns.
        - **Cost protection**: DDoS Protection Standard includes cost protection to cover resource costs incurred during a documented DDoS attack.
        - **Compliance alignment**: Many security frameworks and industry regulations require DDoS protection for internet-facing services and critical infrastructure.
        - **Integrated monitoring**: Provides attack analytics, telemetry, and integration with Azure Monitor for real-time visibility into attack patterns.

        By enabling DDoS Protection on virtual networks, organizations can protect their Azure resources from DDoS attacks, maintain service availability, and meet compliance requirements.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Virtual networks** in the Azure Portal.
        2. Select a virtual network.
        3. Under **Overview** or **DDoS protection**, verify that DDoS Protection is set to **Enabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az network vnet list --query "[].{Name:name, ResourceGroup:resourceGroup, DDoSProtection:enableDdosProtection}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzVirtualNetwork | Select-Object Name, ResourceGroupName, EnableDdosProtection | Format-Table
        ```

        Ensure all virtual networks have EnableDdosProtection set to True.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Virtual networks** in the Azure Portal.
            2. Select the virtual network.
            3. Select **DDoS protection** under **Settings**.
            4. Set DDoS Protection to **Enabled** and select a DDoS protection plan.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network vnet update --resource-group <ResourceGroupName> --name <VNetName> --ddos-protection true --ddos-protection-plan <DDoSProtectionPlanId>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $vnet = Get-AzVirtualNetwork -ResourceGroupName <ResourceGroupName> -Name <VNetName>
            $vnet.EnableDdosProtection = $true
            $vnet.DdosProtectionPlan = New-Object Microsoft.Azure.Commands.Network.Models.PSResourceId
            $vnet.DdosProtectionPlan.Id = "<DDoSProtectionPlanId>"
            Set-AzVirtualNetwork -VirtualNetwork $vnet
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_network_ddos_protection_plan" "example" {
              name                = "example-ddos-plan"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
            }

            resource "azurerm_virtual_network" "example" {
              name                = "example-vnet"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              address_space       = ["10.0.0.0/16"]

              ddos_protection_plan {
                id     = azurerm_network_ddos_protection_plan.example.id
                enable = true
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/ddos-protection/ddos-protection-overview
        title: Azure DDoS Protection overview
  - uid: mondoo-azure-security-network-subnet-default-outbound-disabled
    title: Ensure default outbound access is disabled on subnets
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-5
      compliance/iso-27001-2022: iso-27001-2022-a-8-22
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.virtualNetworks.all(subnets.all(properties["defaultOutboundAccess"] == false))
    docs:
      desc: |
        This check ensures that default outbound access is disabled on all subnets within Azure virtual networks, enforcing explicit outbound connectivity configurations.

        **Why this matters**

        Disabling default outbound access on subnets provides several critical benefits:

        - **Reduced attack surface**: Default outbound access allows all resources in a subnet to reach the internet without explicit configuration, which can be exploited by compromised resources for data exfiltration or command-and-control communication.
        - **Explicit connectivity**: Disabling default outbound access requires organizations to explicitly define outbound paths using NAT gateways, Azure Firewall, or other network virtual appliances, ensuring all outbound traffic is intentional and controlled.
        - **Improved visibility**: When outbound access must be explicitly configured, organizations gain better visibility and control over which resources can communicate externally.
        - **Compliance alignment**: Many security frameworks require explicit outbound access controls to prevent unauthorized data flows and reduce the risk of data exfiltration.

        By disabling default outbound access on subnets, organizations can enforce the principle of least privilege for network connectivity and improve their overall security posture.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Virtual networks** in the Azure Portal.
        2. Select a virtual network and go to **Subnets**.
        3. For each subnet, verify that default outbound access is disabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az network vnet subnet list --resource-group <ResourceGroupName> --vnet-name <VNetName> --query "[].{Name:name, DefaultOutboundAccess:defaultOutboundAccess}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzVirtualNetwork | ForEach-Object { $vnet = $_; $_.Subnets | Select-Object @{Name="VNet";Expression={$vnet.Name}}, Name, DefaultOutboundAccess }
        ```

        Ensure all subnets have DefaultOutboundAccess set to False.
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Virtual networks** in the Azure Portal.
            2. Select the virtual network.
            3. Go to **Subnets** and select the subnet.
            4. Under subnet settings, set **Default outbound access** to **Disabled**.
            5. Configure explicit outbound connectivity using a NAT gateway, Azure Firewall, or load balancer with outbound rules.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network vnet subnet update --resource-group <ResourceGroupName> --vnet-name <VNetName> --name <SubnetName> --default-outbound false
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $vnet = Get-AzVirtualNetwork -ResourceGroupName <ResourceGroupName> -Name <VNetName>
            $subnet = Get-AzVirtualNetworkSubnetConfig -VirtualNetwork $vnet -Name <SubnetName>
            $subnet.DefaultOutboundAccess = $false
            Set-AzVirtualNetwork -VirtualNetwork $vnet
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_subnet" "example" {
              name                   = "example-subnet"
              resource_group_name    = azurerm_resource_group.example.name
              virtual_network_name   = azurerm_virtual_network.example.name
              address_prefixes       = ["10.0.1.0/24"]
              default_outbound_access_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/virtual-network/ip-services/default-outbound-access
        title: Default outbound access in Azure
  - uid: mondoo-azure-security-network-database-ports-restricted
    title: Ensure database ports are restricted from the internet
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure-network-security-group"
    props:
      - uid: mondooAzureSecurityDisallowedPortsDB
        title: A list of disallowed TCP database ports. Add more ports as needed.
        mql: |
          return [
            1433,
            3306,
            5432,
            27017,
          ]
    mql: |
      allNsgTCP = azure.subscription.network.securityGroup.securityRules
        .where(
          properties.access == 'Allow'
            && direction == 'Inbound'
            && properties.protocol == /TCP|\*/i
            && properties.sourceAddressPrefix == /\*|0\.0\.0\.0|<nw>\/0|\/0|internet|any/
        )
      allNsgTCP.all(properties.destinationPortRange != "*")
      props.mondooAzureSecurityDisallowedPortsDB {
        disallowedPortDB = _
        disallowedPortDB
        allNsgTCP.none(destinationPortRange.any(fromPort <= disallowedPortDB && toPort >= disallowedPortDB))
      }
    docs:
      desc: |
        This check ensures that common database ports are restricted from direct internet access to prevent unauthorized access to database services.

        **Why this matters**

        Exposing database ports to the internet can lead to significant security risks:

        - **Unauthorized access**: Database services are prime targets for brute force attacks, credential stuffing, and exploitation of unpatched vulnerabilities.
        - **Data exfiltration**: Direct internet access to databases makes it easier for attackers to extract sensitive data once they gain access.
        - **Increased attack surface**: Open database ports (MSSQL 1433, MySQL 3306, PostgreSQL 5432, MongoDB 27017) provide direct entry points for attackers to target database-specific vulnerabilities.
        - **Compliance risks**: Security standards such as PCI DSS, HIPAA, and SOC 2 explicitly require that database services are not directly accessible from the public internet.

        By ensuring database ports are restricted from internet access, this check helps to protect sensitive data, reduce the attack surface, and align with security best practices and compliance requirements.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Log into the Azure Portal.
        2. Navigate to **Network security groups** under the Networking menu or directly through the search bar.
        3. For each NSG, access the **Inbound security rules**.
        4. Review each rule to identify any that allow inbound traffic on database ports (1433, 3306, 5432, 27017):
          - Check for rules where the protocol is set to `TCP` or `*`.
          - The destination port or port range includes any of the database ports.
          - The source address prefix is too broad, such as 'Any', '0.0.0.0', '<nw>/0', '/0', 'internet', or 'any'.

        **Automated Audit with Azure CLI:**

        List NSGs and check for database port access rules:

        ```bash
        az network nsg list --query "[].{NSG: name, Rules: securityRules[?access=='Allow' && protocol=='Tcp' && direction=='Inbound' && (destinationPortRange=='1433' || destinationPortRange=='3306' || destinationPortRange=='5432' || destinationPortRange=='27017') && (sourceAddressPrefix=='*' || sourceAddressPrefix=='0.0.0.0' || sourceAddressPrefix=='<nw>/0' || sourceAddressPrefix=='/0' || sourceAddressPrefix=='internet' || sourceAddressPrefix=='any')]}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzNetworkSecurityGroup | ForEach-Object { $nsg = $_; $_.SecurityRules | Where-Object { $_.Access -eq "Allow" -and $_.Direction -eq "Inbound" -and ($_.DestinationPortRange -in @("1433","3306","5432","27017")) -and ($_.SourceAddressPrefix -in @("*","0.0.0.0","<nw>/0","/0","internet","any")) } | Select-Object @{Name="NSG";Expression={$nsg.Name}}, Name, DestinationPortRange }
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Log into the Azure Portal and navigate to **Network Security Groups**.
            2. Select the NSG associated with your resources.
            3. Review the **Inbound security rules** and modify or delete any rules that allow internet access to database ports (1433, 3306, 5432, 27017).
            4. Change the `source_address_prefix` to more restrictive settings, such as a specific IP range, virtual network, or private endpoint.
        - id: cli
          desc: |
            **Using Azure CLI**

            Update or create NSG rules to restrict database port access:

            ```bash
            az network nsg rule create --resource-group <ResourceGroupName> --nsg-name <NSGName> --name RestrictDBPorts --priority 1001 --direction Inbound --access Deny --protocol Tcp --source-address-prefixes "*" --destination-port-ranges 1433 3306 5432 27017
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            New-AzNetworkSecurityRuleConfig -Name RestrictDBPorts -Protocol Tcp -Direction Inbound -Priority 1001 -SourceAddressPrefix * -SourcePortRange * -DestinationAddressPrefix * -DestinationPortRange 1433,3306,5432,27017 -Access Deny
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Ensure database ports are not exposed to the internet

            resource "azurerm_network_security_group" "example" {
              name                = "example-db-security"
              location            = azurerm_resource_group.rg.location
              resource_group_name = azurerm_resource_group.rg.name

              security_rule {
                name                       = "DenyDBFromInternet"
                priority                   = 1001
                direction                  = "Inbound"
                access                     = "Deny"
                protocol                   = "Tcp"
                source_port_range          = "*"
                destination_port_ranges    = ["1433", "3306", "5432", "27017"]
                source_address_prefix      = "*"
                destination_address_prefix = "*"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/security/fundamentals/network-best-practices
        title: Azure Network Security Best Practices
  - uid: mondoo-azure-security-defender-for-cosmosdb-enabled
    title: Ensure Microsoft Defender for Cosmos DB is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForCosmosDb["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for Cosmos DB is enabled to detect threats targeting Azure Cosmos DB accounts.

        **Why this matters**

        Enabling Defender for Cosmos DB provides several critical benefits:

        - **Threat detection**: Detects potential SQL injection attacks, known suspicious access patterns, and anomalous query execution patterns targeting Cosmos DB accounts.
        - **Anomalous access detection**: Identifies unusual access from unexpected locations, suspicious IP addresses, or unusual user agents that could indicate compromised credentials.
        - **Data exfiltration monitoring**: Monitors for unusual data extraction patterns that could indicate data theft or unauthorized data access.
        - **Compliance alignment**: Many security frameworks require advanced threat protection for database services containing sensitive data.

        By enabling Defender for Cosmos DB, organizations can detect and respond to threats targeting their NoSQL database infrastructure and protect the data it contains.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Cosmos DB** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name CosmosDbs --query "pricingTier"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzSecurityPricing -Name CosmosDbs | Select-Object Name, PricingTier
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Cosmos DB** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name CosmosDbs --tier Standard
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzSecurityPricing -Name CosmosDbs -PricingTier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "cosmos_db" {
              tier          = "Standard"
              resource_type = "CosmosDbs"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-databases-introduction
        title: Overview of Microsoft Defender for Databases
  - uid: mondoo-azure-security-defender-for-open-source-databases-enabled
    title: Ensure Microsoft Defender for open-source relational databases is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderForOpenSourceDatabases["enabled"] == true
    docs:
      desc: |
        This check ensures that Microsoft Defender for open-source relational databases is enabled to provide threat protection for Azure Database for MySQL, PostgreSQL, and MariaDB.

        **Why this matters**

        Enabling Defender for open-source relational databases provides several critical benefits:

        - **Anomalous access detection**: Identifies unusual login patterns, access from unexpected locations, and brute force attacks targeting open-source database services.
        - **SQL injection detection**: Detects potential SQL injection attacks and anomalous query patterns that could indicate exploitation attempts.
        - **Vulnerability alerts**: Monitors for known vulnerabilities and suspicious activities specific to MySQL, PostgreSQL, and MariaDB database engines.
        - **Compliance alignment**: Many security standards require advanced threat detection for all database services, including open-source relational databases.

        By enabling Defender for open-source relational databases, organizations can detect and respond to threats targeting their MySQL, PostgreSQL, and MariaDB database infrastructure.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Open-source relational databases** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name OpenSourceRelationalDatabases --query "pricingTier"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzSecurityPricing -Name OpenSourceRelationalDatabases | Select-Object Name, PricingTier
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Open-source relational databases** to **On**.
            4. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name OpenSourceRelationalDatabases --tier Standard
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzSecurityPricing -Name OpenSourceRelationalDatabases -PricingTier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "open_source_dbs" {
              tier          = "Standard"
              resource_type = "OpenSourceRelationalDatabases"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-databases-introduction
        title: Overview of Microsoft Defender for Databases
  - uid: mondoo-azure-security-defender-cspm-enabled
    title: Ensure Microsoft Defender Cloud Security Posture Management is enabled
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-16
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cloudDefender.defenderCSPM.enabled == true
    docs:
      desc: |
        This check ensures that Microsoft Defender Cloud Security Posture Management (CSPM) is enabled to provide advanced security posture capabilities beyond the foundational CSPM features.

        **Why this matters**

        Enabling Defender CSPM provides several critical benefits:

        - **Attack path analysis**: Identifies potential attack paths across your cloud environment by analyzing the relationships between resources, identities, and network configurations to find exploitable patterns.
        - **Cloud security explorer**: Provides a graph-based query engine to explore security relationships across cloud resources and identify risks that traditional tools may miss.
        - **Agentless scanning**: Performs vulnerability assessment and secret scanning without requiring agents, reducing operational overhead while improving coverage.
        - **Governance and compliance**: Offers enhanced governance capabilities including regulatory compliance dashboards and the ability to assign security recommendations to resource owners.
        - **Data-aware security posture**: Discovers and classifies sensitive data across cloud storage services, enabling risk prioritization based on data sensitivity.

        By enabling Defender CSPM, organizations can gain comprehensive visibility into their cloud security posture, identify complex attack paths, and prioritize remediation efforts based on actual risk.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
        2. Select **Environment settings** and choose the subscription.
        3. Under **Defender plans**, verify that **Defender CSPM** is set to **On**.

        **Automated Audit with Azure CLI:**

        ```bash
        az security pricing show --name CloudPosture --query "pricingTier"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzSecurityPricing -Name CloudPosture | Select-Object Name, PricingTier
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Microsoft Defender for Cloud** in the Azure Portal.
            2. Select **Environment settings** and choose the subscription.
            3. Under **Defender plans**, set **Defender CSPM** to **On**.
            4. Configure the desired extensions (agentless scanning, attack path analysis, etc.).
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az security pricing create --name CloudPosture --tier Standard
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzSecurityPricing -Name CloudPosture -PricingTier Standard
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_security_center_subscription_pricing" "cspm" {
              tier          = "Standard"
              resource_type = "CloudPosture"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/defender-for-cloud/concept-cloud-security-posture-management
        title: Cloud Security Posture Management (CSPM)
  - uid: mondoo-azure-security-cosmosdb-public-access-disabled
    title: Ensure public network access is disabled for Azure Cosmos DB accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.all(properties["publicNetworkAccess"] == "Disabled")
    docs:
      desc: |
        This check ensures that public network access is disabled on Azure Cosmos DB accounts, requiring all connections to go through private endpoints or approved virtual networks.

        **Why this matters**

        Disabling public network access provides several critical benefits:

        - **Reduced attack surface**: Disabling public access ensures that the Cosmos DB account is not reachable from the public internet, eliminating a major attack vector.
        - **Network isolation**: All access must go through private endpoints within the virtual network, providing strong network-level isolation for sensitive data.
        - **Data protection**: Private endpoints ensure that Cosmos DB traffic stays within the Azure backbone network, reducing the risk of data interception.
        - **Compliance alignment**: Many regulatory standards and security frameworks require that database services containing sensitive data are not accessible from the public internet.

        By disabling public network access, organizations can ensure that their Cosmos DB accounts are only accessible from trusted, internal networks.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Public network access** is set to **Disabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb list --query "[].{Name:name, ResourceGroup:resourceGroup, PublicNetworkAccess:publicNetworkAccess}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount | Select-Object Name, ResourceGroupName, PublicNetworkAccess
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Networking** under **Settings**.
            4. Set **Public network access** to **Disabled**.
            5. Configure a private endpoint for the Cosmos DB account.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb update --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --enable-public-network false
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -PublicNetworkAccess "Disabled"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                          = "example-cosmosdb"
              location                      = azurerm_resource_group.example.location
              resource_group_name           = azurerm_resource_group.example.name
              offer_type                    = "Standard"
              public_network_access_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-configure-firewall
        title: Configure IP firewall in Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-local-auth-disabled
    title: Ensure local authentication is disabled for Azure Cosmos DB accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-5
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.all(properties["disableLocalAuth"] == true)
    docs:
      desc: |
        This check ensures that local authentication (key-based access) is disabled on Azure Cosmos DB accounts, requiring the use of Microsoft Entra ID (formerly Azure Active Directory) for authentication.

        **Why this matters**

        Disabling local authentication provides several critical benefits:

        - **Centralized identity management**: Forcing Microsoft Entra ID authentication ensures all access is managed through a central identity provider with support for MFA and conditional access.
        - **Reduced credential exposure**: Primary and secondary keys are long-lived static credentials that can be leaked or compromised. Disabling local auth eliminates this risk.
        - **Improved auditability**: Entra ID authentication provides detailed audit logs of who accessed the account and when, which is not possible with shared key authentication.
        - **Compliance alignment**: Many security frameworks require the use of centralized identity management and prohibit the use of shared keys for database access.

        By disabling local authentication, organizations enforce the use of Entra ID-based role assignments for all Cosmos DB access.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Keys** under **Settings**.
        4. Verify that local authentication is disabled and Entra ID authentication is enforced.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb list --query "[].{Name:name, ResourceGroup:resourceGroup, DisableLocalAuth:disableLocalAuth}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount | Select-Object Name, ResourceGroupName, DisableLocalAuth
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Keys** under **Settings**.
            4. Set **Disable local authentication** to **Enabled**.
            5. Ensure Entra ID role assignments are configured for all users and applications.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az resource update --ids <CosmosDBResourceId> --set properties.disableLocalAuth=true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -DisableLocalAuth $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                          = "example-cosmosdb"
              location                      = azurerm_resource_group.example.location
              resource_group_name           = azurerm_resource_group.example.name
              offer_type                    = "Standard"
              local_authentication_disabled = true
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-setup-rbac
        title: Configure role-based access control with Azure AD for Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-vnet-filter-enabled
    title: Ensure virtual network filtering is enabled for Azure Cosmos DB accounts
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-22
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.where(properties["publicNetworkAccess"] != "Disabled").all(properties["isVirtualNetworkFilterEnabled"] == true)
    docs:
      desc: |
        This check ensures that virtual network filtering is enabled on Azure Cosmos DB accounts, restricting access to traffic from approved virtual networks and subnets.

        **Why this matters**

        Enabling virtual network filtering provides several critical benefits:

        - **Network-level access control**: Virtual network filtering restricts access to Cosmos DB from only approved virtual networks and subnets, preventing unauthorized access from other networks.
        - **Defense in depth**: Adding network-layer restrictions provides an additional security boundary beyond authentication and authorization controls.
        - **Reduced attack surface**: By limiting which networks can reach the Cosmos DB account, the exposure to potential attacks from untrusted networks is minimized.
        - **Compliance alignment**: Many security frameworks require network segmentation and access controls for database services to protect sensitive data.

        By enabling virtual network filtering, organizations can enforce network-level restrictions that limit Cosmos DB access to only trusted virtual networks.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Virtual network filtering** is enabled and approved subnets are configured.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb list --query "[].{Name:name, ResourceGroup:resourceGroup, VNetFilterEnabled:isVirtualNetworkFilterEnabled}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount | Select-Object Name, ResourceGroupName, IsVirtualNetworkFilterEnabled
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Networking** under **Settings**.
            4. Enable **Accept connections from within public Azure datacenters** or add specific virtual network rules.
            5. Add the approved virtual networks and subnets.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb update --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --enable-virtual-network true
            az cosmosdb network-rule add --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --virtual-network <VNetName> --subnet <SubnetName>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -EnableVirtualNetwork $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                              = "example-cosmosdb"
              location                          = azurerm_resource_group.example.location
              resource_group_name               = azurerm_resource_group.example.name
              offer_type                        = "Standard"
              is_virtual_network_filter_enabled = true

              virtual_network_rule {
                id = azurerm_subnet.example.id
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-configure-vnet-service-endpoint
        title: Configure access from virtual networks for Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-key-based-metadata-write-disabled
    title: Ensure key-based metadata write access is disabled for Azure Cosmos DB accounts
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-9
      compliance/iso-27001-2022: iso-27001-2022-a-8-3
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.all(properties["disableKeyBasedMetadataWriteAccess"] == true)
    docs:
      desc: |
        This check ensures that key-based metadata write access is disabled on Azure Cosmos DB accounts, preventing clients using account keys from modifying databases, containers, and throughput settings.

        **Why this matters**

        Disabling key-based metadata write access provides several critical benefits:

        - **Prevent accidental changes**: Disabling metadata write access through account keys prevents clients from accidentally creating, replacing, or deleting databases and containers.
        - **Infrastructure as code enforcement**: When metadata writes are restricted to ARM, Terraform, or Bicep, infrastructure changes must go through controlled deployment pipelines.
        - **Separation of concerns**: Data plane operations (read/write data) are separated from control plane operations (manage resources), following the principle of least privilege.
        - **Compliance alignment**: Many security frameworks require that infrastructure changes go through change management processes, which key-based metadata writes bypass.

        By disabling key-based metadata write access, organizations enforce that structural changes to Cosmos DB resources are made only through approved infrastructure management tools.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Keys** under **Settings**.
        4. Verify that key-based metadata write access is disabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb list --query "[].{Name:name, ResourceGroup:resourceGroup, DisableKeyBasedMetadataWrite:disableKeyBasedMetadataWriteAccess}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount | Select-Object Name, ResourceGroupName, DisableKeyBasedMetadataWriteAccess
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Keys** under **Settings**.
            4. Set **Disable key-based metadata write access** to **Enabled**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb update --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --disable-key-based-metadata-write-access true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -DisableKeyBasedMetadataWriteAccess $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                               = "example-cosmosdb"
              location                           = azurerm_resource_group.example.location
              resource_group_name                = azurerm_resource_group.example.name
              offer_type                         = "Standard"
              access_key_metadata_writes_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/role-based-access-control
        title: Role-based access control in Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-automatic-failover-enabled
    title: Ensure automatic failover is enabled for Azure Cosmos DB accounts
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc9-1-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-14
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.where(properties["locations"].length > 1).all(properties["enableAutomaticFailover"] == true)
    docs:
      desc: |
        This check ensures that automatic failover is enabled on Azure Cosmos DB accounts, providing high availability by automatically failing over to a secondary region during an outage.

        **Why this matters**

        Enabling automatic failover provides several critical benefits:

        - **High availability**: Automatic failover ensures that the Cosmos DB account remains available during a regional outage by automatically promoting a secondary region to primary.
        - **Reduced downtime**: Without automatic failover, manual intervention is required to restore service during a regional failure, significantly increasing recovery time.
        - **Business continuity**: Automatic failover supports business continuity requirements by ensuring data remains accessible even during major infrastructure failures.
        - **Compliance alignment**: Many security and reliability frameworks require high availability configurations for critical data services, including automatic failover capabilities.

        By enabling automatic failover, organizations can ensure their Cosmos DB accounts remain available and resilient during regional outages.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Replicate data globally** under **Settings**.
        4. Verify that **Automatic Failover** is enabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb list --query "[].{Name:name, ResourceGroup:resourceGroup, AutomaticFailover:enableAutomaticFailover}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount | Select-Object Name, ResourceGroupName, EnableAutomaticFailover
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Replicate data globally** under **Settings**.
            4. Enable **Automatic Failover**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb update --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --enable-automatic-failover true
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -EnableAutomaticFailover $true
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                      = "example-cosmosdb"
              location                  = azurerm_resource_group.example.location
              resource_group_name       = azurerm_resource_group.example.name
              offer_type                = "Standard"
              enable_automatic_failover = true

              geo_location {
                location          = "eastus"
                failover_priority = 0
              }

              geo_location {
                location          = "westus"
                failover_priority = 1
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/high-availability
        title: High availability in Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-min-tls-version
    title: Ensure Azure Cosmos DB accounts use minimum TLS version 1.2
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-7-2
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.all(properties["minimalTlsVersion"] == "Tls12")
    docs:
      desc: |
        This check ensures that Azure Cosmos DB accounts are configured to require a minimum TLS version of 1.2 for all connections, rejecting clients that attempt to connect using older, insecure TLS versions.

        **Why this matters**

        Requiring TLS 1.2 as the minimum version provides several critical benefits:

        - **Protocol security**: TLS 1.0 and 1.1 have known vulnerabilities (BEAST, POODLE, and other attacks) that can be exploited to decrypt traffic. TLS 1.2 addresses these weaknesses.
        - **Data protection**: Enforcing modern TLS ensures that all data in transit between clients and Cosmos DB is protected with strong encryption algorithms.
        - **Compliance alignment**: PCI DSS, NIST, and other regulatory frameworks mandate TLS 1.2 as the minimum acceptable version for encrypting sensitive data in transit.
        - **Industry standard**: Microsoft and major cloud providers recommend TLS 1.2 as the minimum version for all services handling production data.

        The default `minimalTlsVersion` for Cosmos DB accounts is `Tls` (TLS 1.0), which is insecure. It should be explicitly set to `Tls12`.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Minimum TLS version** is set to **1.2**.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb show --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --query "minimalTlsVersion"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> | Select-Object Name, MinimalTlsVersion
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Networking** under **Settings**.
            4. Set **Minimum TLS version** to **1.2**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb update --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --minimal-tls-version Tls12
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -MinimalTlsVersion "Tls12"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                = "example-cosmosdb"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              offer_type          = "Standard"
              minimal_tls_version = "Tls12"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/security-controls-policy
        title: Azure security baseline for Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-network-acl-bypass-none
    title: Ensure Azure Cosmos DB network ACL bypass is set to None
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.all(properties["networkAclBypass"] == "None")
    docs:
      desc: |
        This check ensures that Azure Cosmos DB accounts have the network ACL bypass set to `None`, preventing Azure services from bypassing firewall rules.

        **Why this matters**

        Setting network ACL bypass to None provides several critical benefits:

        - **Strict network controls**: When set to `AzureServices`, any Azure service (including those in other tenants) can bypass the Cosmos DB firewall rules, potentially allowing unauthorized access.
        - **Lateral movement prevention**: A compromised Azure service in any tenant could use the `AzureServices` bypass to access Cosmos DB accounts, creating a lateral movement path across tenant boundaries.
        - **Defense in depth**: Removing the bypass ensures that all traffic, including from Azure services, must pass through the configured firewall and VNet rules.
        - **Compliance alignment**: Many security frameworks require that all access to data stores is subject to network-level access controls without exceptions.

        By setting `networkAclBypass` to `None`, organizations ensure that their firewall and network rules are enforced for all traffic without exception.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Networking** under **Settings**.
        4. Under **Exceptions**, verify that **Allow access from Azure Portal** and other Azure service bypasses are not enabled.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb show --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --query "networkAclBypass"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> | Select-Object Name, NetworkAclBypass
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Networking** under **Settings**.
            4. Under **Exceptions**, uncheck all Azure service bypass options.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb update --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --network-acl-bypass None
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Update-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> -NetworkAclBypass "None"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                = "example-cosmosdb"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              offer_type          = "Standard"
              network_acl_bypass  = "None"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-configure-firewall
        title: Configure IP firewall in Azure Cosmos DB
  - uid: mondoo-azure-security-cosmosdb-cmk-encryption
    title: Ensure Azure Cosmos DB accounts use customer-managed keys for encryption
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-10
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.cosmosDb.accounts.all(properties["keyVaultKeyUri"] != empty)
    docs:
      desc: |
        This check ensures that Azure Cosmos DB accounts are configured with customer-managed keys (CMK) via Azure Key Vault for data-at-rest encryption, rather than relying on the default Microsoft-managed keys.

        **Why this matters**

        Using customer-managed keys provides several critical benefits:

        - **Encryption control**: Customer-managed keys give organizations full control over the encryption keys used to protect their Cosmos DB data, including the ability to rotate, revoke, and audit key usage.
        - **Key lifecycle management**: Organizations can enforce key rotation policies, set expiration dates, and revoke keys immediately if a breach is suspected, instantly rendering the data inaccessible.
        - **Separation of duties**: CMK enables a separation between the data administrator and the encryption key administrator, supporting the principle of least privilege.
        - **Compliance alignment**: Many regulatory frameworks (HIPAA, FedRAMP, SOC 2, PCI DSS) require or strongly recommend customer-managed encryption keys for data classified as sensitive or regulated.

        By configuring customer-managed keys, organizations maintain control over their encryption posture and can respond quickly to security incidents by revoking key access.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Azure Cosmos DB** in the Azure Portal.
        2. Select a Cosmos DB account.
        3. Go to **Encryption** under **Settings**.
        4. Verify that encryption is configured with a **Customer-managed key** from Azure Key Vault.

        **Automated Audit with Azure CLI:**

        ```bash
        az cosmosdb show --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --query "keyVaultKeyUri"
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzCosmosDBAccount -ResourceGroupName <ResourceGroupName> -Name <CosmosDBAccountName> | Select-Object Name, KeyVaultKeyUri
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Azure Cosmos DB** in the Azure Portal.
            2. Select the Cosmos DB account.
            3. Go to **Encryption** under **Settings**.
            4. Select **Customer-managed key**.
            5. Configure the Azure Key Vault, key, and version.
            6. Assign a managed identity with access to the Key Vault.
            7. Select **Save**.

            **Note**: Customer-managed key encryption must be configured at account creation time. Existing accounts using Microsoft-managed keys may need to be recreated.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az cosmosdb create --name <CosmosDBAccountName> --resource-group <ResourceGroupName> --key-uri "https://<KeyVaultName>.vault.azure.net/keys/<KeyName>/<KeyVersion>" --assign-identity "<ManagedIdentityResourceId>" --default-identity "UserAssignedIdentity=<ManagedIdentityResourceId>"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_cosmosdb_account" "example" {
              name                = "example-cosmosdb"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              offer_type          = "Standard"
              key_vault_key_id    = azurerm_key_vault_key.example.id

              identity {
                type = "SystemAssigned"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-setup-cmk
        title: Configure customer-managed keys for your Azure Cosmos DB account
  - uid: mondoo-azure-security-firewall-threat-intel-deny
    title: Ensure Azure Firewall threat intelligence is set to Deny mode
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.firewalls.all(threatIntelMode == "Deny")
    docs:
      desc: |
        This check ensures that Azure Firewall threat intelligence-based filtering is set to Deny mode, actively blocking traffic from and to known malicious IP addresses and domains.

        **Why this matters**

        Setting threat intelligence to Deny mode provides several critical benefits:

        - **Active threat blocking**: Deny mode actively blocks traffic from known malicious IP addresses and fully qualified domain names, rather than just alerting on them.
        - **Proactive defense**: Threat intelligence feeds from Microsoft are continuously updated, providing protection against the latest known threats without manual intervention.
        - **Reduced incident response burden**: By automatically blocking malicious traffic, the volume of security incidents requiring manual investigation is significantly reduced.
        - **Compliance alignment**: Many security frameworks require active blocking of known malicious traffic, not just detection and alerting.

        By setting threat intelligence to Deny mode, organizations ensure that known malicious traffic is automatically blocked at the firewall level.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Firewalls** in the Azure Portal.
        2. Select an Azure Firewall instance.
        3. Go to **Threat intelligence** under **Settings**.
        4. Verify that the mode is set to **Alert and deny**.

        **Automated Audit with Azure CLI:**

        ```bash
        az network firewall list --query "[].{Name:name, ResourceGroup:resourceGroup, ThreatIntelMode:threatIntelMode}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzFirewall | Select-Object Name, ResourceGroupName, ThreatIntelMode
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Firewalls** in the Azure Portal.
            2. Select the Azure Firewall instance.
            3. Go to **Threat intelligence** under **Settings**.
            4. Set the mode to **Alert and deny**.
            5. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network firewall update --name <FirewallName> --resource-group <ResourceGroupName> --threat-intel-mode Deny
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $firewall = Get-AzFirewall -Name <FirewallName> -ResourceGroupName <ResourceGroupName>
            $firewall.ThreatIntelMode = "Deny"
            Set-AzFirewall -AzureFirewall $firewall
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_firewall" "example" {
              name                = "example-firewall"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              sku_name            = "AZFW_VNet"
              sku_tier            = "Premium"
              threat_intel_mode   = "Deny"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/firewall/threat-intel
        title: Azure Firewall threat intelligence-based filtering
  - uid: mondoo-azure-security-firewall-premium-sku
    title: Ensure Azure Firewall uses Premium SKU for advanced threat protection
    impact: 40
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.firewalls.all(skuTier == "Premium")
    docs:
      desc: |
        This check ensures that Azure Firewall instances use the Premium SKU, which provides advanced threat protection capabilities beyond what the Standard SKU offers.

        **Why this matters**

        Using the Premium SKU provides several critical benefits:

        - **TLS inspection**: Premium SKU supports TLS inspection, allowing the firewall to decrypt and inspect encrypted traffic for threats that would otherwise be hidden.
        - **IDPS capabilities**: The Premium SKU includes a signature-based Intrusion Detection and Prevention System (IDPS) that can detect and block known attack patterns.
        - **URL filtering**: Enhanced URL filtering with the ability to filter entire URLs including the path, not just domain names.
        - **Web categories**: Allows administrators to control user access to website categories such as gambling, social media, and others, providing granular content filtering.

        By using the Premium SKU, organizations gain access to advanced security features that significantly enhance the firewall's ability to detect and prevent sophisticated threats.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Firewalls** in the Azure Portal.
        2. Select an Azure Firewall instance.
        3. Go to **Overview**.
        4. Verify that the **SKU tier** is set to **Premium**.

        **Automated Audit with Azure CLI:**

        ```bash
        az network firewall list --query "[].{Name:name, ResourceGroup:resourceGroup, SkuTier:sku.tier}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzFirewall | Select-Object Name, ResourceGroupName, @{N="SkuTier";E={$_.Sku.Tier}}
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Firewalls** in the Azure Portal.
            2. Select the Azure Firewall instance.
            3. Note: Upgrading from Standard to Premium requires redeployment. Create a new firewall with Premium SKU and migrate rules.
            4. Select **Premium** as the SKU tier during creation.
            5. Migrate existing firewall rules and policies to the new Premium firewall.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network firewall create --name <FirewallName> --resource-group <ResourceGroupName> --location <Location> --sku AZFW_VNet --tier Premium
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            New-AzFirewall -Name <FirewallName> -ResourceGroupName <ResourceGroupName> -Location <Location> -SkuName "AZFW_VNet" -SkuTier "Premium"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_firewall" "example" {
              name                = "example-firewall"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              sku_name            = "AZFW_VNet"
              sku_tier            = "Premium"
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/firewall/premium-features
        title: Azure Firewall Premium features
  - uid: mondoo-azure-security-firewall-policy-configured
    title: Ensure Azure Firewall has a firewall policy attached
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.firewalls.all(policy != empty)
    docs:
      desc: |
        This check ensures that Azure Firewall instances have a firewall policy attached, providing centralized rule management and consistent security posture across firewalls.

        **Why this matters**

        Attaching a firewall policy provides several critical benefits:

        - **Centralized management**: Firewall policies provide a central location to manage rules across multiple firewalls, reducing configuration drift and administrative overhead.
        - **Policy inheritance**: Policies support hierarchical structures where child policies inherit rules from parent policies, enabling consistent baseline rules across the organization.
        - **Rule organization**: Policies organize rules into rule collection groups, making it easier to manage complex firewall configurations with proper prioritization.
        - **Compliance alignment**: Centralized policy management ensures consistent enforcement of security rules across all firewall instances, supporting compliance requirements for uniform security controls.

        By ensuring a firewall policy is attached, organizations can maintain consistent, centrally managed firewall rules across their Azure environment.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Firewalls** in the Azure Portal.
        2. Select an Azure Firewall instance.
        3. Go to **Overview**.
        4. Verify that a **Firewall policy** is associated with the firewall.

        **Automated Audit with Azure CLI:**

        ```bash
        az network firewall list --query "[].{Name:name, ResourceGroup:resourceGroup, FirewallPolicy:firewallPolicy.id}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzFirewall | Select-Object Name, ResourceGroupName, @{N="FirewallPolicy";E={$_.FirewallPolicy.Id}}
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Firewalls** in the Azure Portal.
            2. Select the Azure Firewall instance.
            3. Go to **Firewall policy** under **Settings**.
            4. Click **Associate a firewall policy**.
            5. Select an existing policy or create a new one.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network firewall update --name <FirewallName> --resource-group <ResourceGroupName> --firewall-policy <PolicyResourceId>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $policy = Get-AzFirewallPolicy -Name <PolicyName> -ResourceGroupName <ResourceGroupName>
            $firewall = Get-AzFirewall -Name <FirewallName> -ResourceGroupName <ResourceGroupName>
            $firewall.FirewallPolicy = $policy.Id
            Set-AzFirewall -AzureFirewall $firewall
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_firewall_policy" "example" {
              name                = "example-policy"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
            }

            resource "azurerm_firewall" "example" {
              name                = "example-firewall"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              sku_name            = "AZFW_VNet"
              sku_tier            = "Premium"
              firewall_policy_id  = azurerm_firewall_policy.example.id
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/firewall/policy-rule-sets
        title: Azure Firewall Policy rule sets
  - uid: mondoo-azure-security-firewall-idps-enabled
    title: Ensure Azure Firewall Policy has IDPS set to Deny mode
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.network.firewallPolicies.all(
        properties["intrusionDetection"] != null &&
        properties["intrusionDetection"]["mode"] == "Deny"
      )
    docs:
      desc: |
        This check ensures that Azure Firewall Policy has Intrusion Detection and Prevention System (IDPS) set to Deny mode, providing signature-based detection and active blocking of known attack patterns. Alert-only mode logs threats but does not prevent them from reaching protected resources.

        **Why this matters**

        Enabling IDPS provides several critical benefits:

        - **Attack detection**: IDPS uses a comprehensive set of signatures to detect known attack patterns, including malware, botnets, and exploit attempts in network traffic.
        - **Active prevention**: When set to Alert and Deny mode, IDPS can actively block detected threats, preventing malicious traffic from reaching protected resources.
        - **Encrypted traffic inspection**: Combined with TLS inspection in Premium SKU, IDPS can inspect encrypted traffic for threats that would otherwise be hidden.
        - **Compliance alignment**: Many security frameworks require intrusion detection and prevention capabilities for network perimeter security controls.

        By enabling IDPS, organizations can detect and block known attack patterns at the network level, providing an essential layer of defense against sophisticated threats.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Firewall Policies** in the Azure Portal.
        2. Select a firewall policy.
        3. Go to **IDPS** under **Settings**.
        4. Verify that IDPS mode is set to **Alert and deny**.

        **Automated Audit with Azure CLI:**

        ```bash
        az network firewall policy list --query "[].{Name:name, ResourceGroup:resourceGroup, IDPSMode:intrusionDetection.mode}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzFirewallPolicy | Select-Object Name, ResourceGroupName, @{N="IDPSMode";E={$_.IntrusionDetection.Mode}}
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Firewall Policies** in the Azure Portal.
            2. Select the firewall policy.
            3. Go to **IDPS** under **Settings**.
            4. Set the IDPS mode to **Alert and deny**.
            5. Configure signature rules as needed.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az network firewall policy update --name <PolicyName> --resource-group <ResourceGroupName> --idps-mode Deny
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            $policy = Get-AzFirewallPolicy -Name <PolicyName> -ResourceGroupName <ResourceGroupName>
            $policy.IntrusionDetection = New-AzFirewallPolicyIntrusionDetection -Mode "Deny"
            Set-AzFirewallPolicy -InputObject $policy
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_firewall_policy" "example" {
              name                = "example-policy"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name
              sku                 = "Premium"

              intrusion_detection {
                mode = "Deny"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/firewall/premium-features
        title: Azure Firewall Premium features
  - uid: mondoo-azure-security-batch-public-access-disabled
    title: Ensure public network access is disabled for Azure Batch accounts
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-6-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-20
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.batch.accounts.all(publicNetworkAccess == "Disabled")
    docs:
      desc: |
        This check ensures that public network access is disabled on Azure Batch accounts, requiring all connections to go through private endpoints.

        **Why this matters**

        Disabling public network access provides several critical benefits:

        - **Reduced attack surface**: Disabling public access ensures that the Batch account is not reachable from the public internet, eliminating a major attack vector for compute workloads.
        - **Network isolation**: All access must go through private endpoints within the virtual network, providing strong network-level isolation for batch processing jobs.
        - **Data protection**: Private endpoints ensure that Batch management traffic stays within the Azure backbone network, reducing the risk of data interception.
        - **Compliance alignment**: Many regulatory standards require that compute services processing sensitive data are not accessible from the public internet.

        By disabling public network access, organizations can ensure that their Batch accounts are only accessible from trusted, internal networks.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Batch accounts** in the Azure Portal.
        2. Select a Batch account.
        3. Go to **Networking** under **Settings**.
        4. Verify that **Public network access** is set to **Disabled**.

        **Automated Audit with Azure CLI:**

        ```bash
        az batch account list --query "[].{Name:name, ResourceGroup:resourceGroup, PublicNetworkAccess:publicNetworkAccess}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzBatchAccount | Select-Object AccountName, ResourceGroupName, PublicNetworkAccess
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Batch accounts** in the Azure Portal.
            2. Select the Batch account.
            3. Go to **Networking** under **Settings**.
            4. Set **Public network access** to **Disabled**.
            5. Configure a private endpoint for the Batch account.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az batch account update --name <BatchAccountName> --resource-group <ResourceGroupName> --public-network-access Disabled
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzBatchAccount -AccountName <BatchAccountName> -ResourceGroupName <ResourceGroupName> -PublicNetworkAccess "Disabled"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_batch_account" "example" {
              name                          = "examplebatch"
              location                      = azurerm_resource_group.example.location
              resource_group_name           = azurerm_resource_group.example.name
              public_network_access_enabled = false
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/batch/private-connectivity
        title: Use private endpoints with Azure Batch accounts
  - uid: mondoo-azure-security-batch-aad-auth-only
    title: Ensure Azure Batch accounts use Entra ID authentication
    impact: 80
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-4
      compliance/iso-27001-2022: iso-27001-2022-a-8-5
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.batch.accounts.all(
        allowedAuthenticationModes.length > 0 &&
        allowedAuthenticationModes.none(_ == "SharedKey") &&
        allowedAuthenticationModes.any(_ == "AAD")
      )
    docs:
      desc: |
        This check ensures that Azure Batch accounts do not allow Shared Key authentication, requiring the use of Entra ID (Azure Active Directory) for all authentication operations.

        **Why this matters**

        Enforcing Entra ID authentication provides several critical benefits:

        - **Centralized identity management**: Entra ID authentication ensures all access is managed through a central identity provider with support for MFA and conditional access policies.
        - **Reduced credential exposure**: Shared Key authentication uses static credentials that can be leaked or compromised. Removing Shared Key eliminates this risk.
        - **Improved auditability**: Entra ID authentication provides detailed audit logs of who accessed the account and when, enabling better security monitoring and incident response.
        - **Compliance alignment**: Many security frameworks require the use of centralized identity management and prohibit the use of shared keys for service access.

        By disabling Shared Key authentication, organizations enforce the use of Entra ID-based authentication for all Batch account operations.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Batch accounts** in the Azure Portal.
        2. Select a Batch account.
        3. Go to **Keys** under **Settings**.
        4. Verify that the allowed authentication modes do not include **Shared Key**.

        **Automated Audit with Azure CLI:**

        ```bash
        az batch account list --query "[].{Name:name, ResourceGroup:resourceGroup, AllowedAuthModes:allowedAuthenticationModes}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzBatchAccount | Select-Object AccountName, ResourceGroupName, AllowedAuthenticationModes
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Batch accounts** in the Azure Portal.
            2. Select the Batch account.
            3. Go to **Keys** under **Settings**.
            4. Remove **Shared Key** from the allowed authentication modes.
            5. Ensure Entra ID authentication is enabled.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az batch account update --name <BatchAccountName> --resource-group <ResourceGroupName> --allowed-authentication-modes AAD
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzBatchAccount -AccountName <BatchAccountName> -ResourceGroupName <ResourceGroupName> -AllowedAuthenticationMode "AAD"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_batch_account" "example" {
              name                = "examplebatch"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name

              allowed_authentication_modes = ["AAD"]
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/batch/batch-aad-auth
        title: Authenticate Azure Batch services with Azure Active Directory
  - uid: mondoo-azure-security-batch-encryption-configured
    title: Ensure Azure Batch accounts use customer-managed encryption keys
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc6-1-10
      compliance/iso-27001-2022: iso-27001-2022-a-8-24
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.batch.accounts.all(encryption["keySource"] == "Microsoft.KeyVault")
    docs:
      desc: |
        This check ensures that Azure Batch accounts have encryption configured, protecting data at rest with either platform-managed or customer-managed encryption keys.

        **Why this matters**

        Configuring encryption provides several critical benefits:

        - **Data protection**: Encryption at rest ensures that Batch account data, including metadata and job data, is protected from unauthorized access if storage media is compromised.
        - **Customer-managed keys**: Using customer-managed keys (CMK) provides additional control over encryption, allowing organizations to manage key lifecycle, rotation, and access policies.
        - **Key Vault integration**: CMK encryption integrates with Azure Key Vault, providing centralized key management with audit logging and access controls.
        - **Compliance alignment**: Many regulatory standards require encryption of data at rest, and customer-managed keys provide the additional control needed for stricter compliance requirements.

        By ensuring encryption is configured, organizations protect sensitive Batch account data and maintain compliance with data protection requirements.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Batch accounts** in the Azure Portal.
        2. Select a Batch account.
        3. Go to **Encryption** under **Settings**.
        4. Verify that encryption is configured and review the key source (Microsoft-managed or Customer-managed).

        **Automated Audit with Azure CLI:**

        ```bash
        az batch account list --query "[].{Name:name, ResourceGroup:resourceGroup, Encryption:encryption}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzBatchAccount | Select-Object AccountName, ResourceGroupName, Encryption
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Batch accounts** in the Azure Portal.
            2. Select the Batch account.
            3. Go to **Encryption** under **Settings**.
            4. Select **Customer-managed keys** as the encryption key source.
            5. Select the Key Vault and key to use for encryption.
            6. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az batch account update --name <BatchAccountName> --resource-group <ResourceGroupName> --encryption-key-source Microsoft.KeyVault --encryption-key-identifier <KeyVaultKeyId>
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzBatchAccount -AccountName <BatchAccountName> -ResourceGroupName <ResourceGroupName> -EncryptionKeySource "Microsoft.KeyVault" -EncryptionKeyIdentifier <KeyVaultKeyId>
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_batch_account" "example" {
              name                = "examplebatch"
              location            = azurerm_resource_group.example.location
              resource_group_name = azurerm_resource_group.example.name

              encryption {
                key_vault_key_id = azurerm_key_vault_key.example.id
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/batch/batch-customer-managed-key
        title: Configure customer-managed keys for Azure Batch
  - uid: mondoo-azure-security-batch-diagnostic-settings-enabled
    title: Ensure Azure Batch accounts have diagnostic settings enabled
    impact: 60
    tags:
      compliance/soc2-2017: soc2-control-cc7-2-1
      compliance/iso-27001-2022: iso-27001-2022-a-8-15
    filters: |
      asset.platform == "azure"
    mql: |
      azure.subscription.batch.accounts.all(diagnosticSettings.length > 0)
    docs:
      desc: |
        This check ensures that diagnostic settings are enabled on Azure Batch accounts, providing visibility into service operations, errors, and security events through centralized logging.

        **Why this matters**

        Enabling diagnostic settings provides several critical benefits:

        - **Operational visibility**: Diagnostic logs provide insight into Batch account operations, including job and task execution, pool management, and resource allocation events.
        - **Security monitoring**: Audit logs capture authentication attempts, authorization decisions, and configuration changes, enabling detection of suspicious activity.
        - **Incident response**: Centralized logging through Log Analytics, Storage Accounts, or Event Hubs enables efficient investigation and response to security incidents.
        - **Compliance alignment**: Many regulatory standards require centralized logging and monitoring for compute services, including retention of audit logs for specified periods.

        By enabling diagnostic settings, organizations can monitor Batch account activity, detect security issues, and meet compliance requirements for logging.
      audit: |
        **Manual Audit via Azure Portal:**

        1. Navigate to **Batch accounts** in the Azure Portal.
        2. Select a Batch account.
        3. Go to **Diagnostic settings** under **Monitoring**.
        4. Verify that at least one diagnostic setting is configured with appropriate log categories and a destination.

        **Automated Audit with Azure CLI:**

        ```bash
        az monitor diagnostic-settings list --resource <BatchAccountResourceId> --query "[].{Name:name, Logs:logs}" -o table
        ```

        **Automated Audit with PowerShell:**

        ```powershell
        Get-AzDiagnosticSetting -ResourceId <BatchAccountResourceId> | Select-Object Name, Logs
        ```
      remediation:
        - id: portal
          desc: |
            **Using Azure Portal**

            1. Navigate to **Batch accounts** in the Azure Portal.
            2. Select the Batch account.
            3. Go to **Diagnostic settings** under **Monitoring**.
            4. Click **Add diagnostic setting**.
            5. Select the log categories to collect (ServiceLog, AuditLog).
            6. Choose a destination (Log Analytics workspace, Storage account, or Event Hub).
            7. Select **Save**.
        - id: cli
          desc: |
            **Using Azure CLI**

            ```bash
            az monitor diagnostic-settings create --name <SettingName> --resource <BatchAccountResourceId> --workspace <LogAnalyticsWorkspaceId> --logs '[{"category":"ServiceLog","enabled":true},{"category":"AuditLog","enabled":true}]'
            ```
        - id: powershell
          desc: |
            **Using PowerShell**

            ```powershell
            Set-AzDiagnosticSetting -ResourceId <BatchAccountResourceId> -Name <SettingName> -WorkspaceId <LogAnalyticsWorkspaceId> -Enabled $true -Category "ServiceLog","AuditLog"
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "azurerm_monitor_diagnostic_setting" "example" {
              name                       = "example-diagnostics"
              target_resource_id         = azurerm_batch_account.example.id
              log_analytics_workspace_id = azurerm_log_analytics_workspace.example.id

              enabled_log {
                category = "ServiceLog"
              }

              enabled_log {
                category = "AuditLog"
              }
            }
            ```
    refs:
      - url: https://learn.microsoft.com/en-us/azure/batch/monitor-batch
        title: Monitor Azure Batch
