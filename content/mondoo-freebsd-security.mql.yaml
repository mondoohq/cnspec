# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-freebsd-security
    name: Mondoo FreeBSD Security
    version: 1.0.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: freebsd
    require:
      - provider: os
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |-
        The Mondoo FreeBSD Security policy identifies misconfigurations that could leave FreeBSD systems vulnerable to unauthorized access, privilege escalation, and data exfiltration. Improperly hardened systems can enable attackers to gain initial access, move laterally across networks, and maintain persistent access to critical infrastructure.

        This policy validates security controls across FreeBSD systems by:
          - Hardening kernel and process security settings
          - Identifying dangerous services that should not be running
          - Ensuring proper SSH server configuration
          - Hardening network stack kernel parameters
          - Verifying correct file permissions on sensitive system files
          - Ensuring users and groups are securely configured
          - Validating logging configuration
          - Checking privilege escalation controls

        ## Remote scan

        Remotely scan a FreeBSD host without installing an agent.

        ### Prerequisites

        Remote scans of FreeBSD hosts require authentication such as SSH keys.

        ### Scan a remote FreeBSD host (SSH authentication)

        ```bash
        cnspec scan ssh <user>@<IP_ADDRESS> -i /path/to/ssh_key
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Kernel and Process Hardening
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-aslr-is-enabled
          - uid: mondoo-freebsd-security-core-dump-backtraces-are-disabled
          - uid: mondoo-freebsd-security-core-dump-storage-is-disabled
      - title: Network Stack
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-ip-forwarding-is-disabled
          - uid: mondoo-freebsd-security-packet-redirect-sending-is-disabled
          - uid: mondoo-freebsd-security-icmp-redirects-are-not-accepted
          - uid: mondoo-freebsd-security-source-routed-packets-are-not-accepted
          - uid: mondoo-freebsd-security-tcp-syn-cookies-is-enabled
          - uid: mondoo-freebsd-security-ipv6-router-advertisements-are-not-accepted
          - uid: mondoo-freebsd-security-broadcast-icmp-requests-are-ignored
      - title: Sensitive Services
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-ftp-server-is-not-enabled
          - uid: mondoo-freebsd-security-telnet-server-is-not-enabled
          - uid: mondoo-freebsd-security-nis-server-is-not-enabled
          - uid: mondoo-freebsd-security-rpcbind-is-not-enabled
          - uid: mondoo-freebsd-security-nfs-server-is-not-enabled
          - uid: mondoo-freebsd-security-snmp-server-is-not-enabled
          - uid: mondoo-freebsd-security-tftp-server-is-not-enabled
          - uid: mondoo-freebsd-security-imap-and-pop3-server-is-not-enabled
          - uid: mondoo-freebsd-security-web-proxy-server-is-not-enabled
          - uid: mondoo-freebsd-security-mail-transfer-agent-is-configured-for-local-only-mode
      - title: SSH Server Configuration
        filters: |
          asset.platform == "freebsd"
          file("/etc/ssh/sshd_config").exists
        checks:
          - uid: mondoo-freebsd-security-permissions-on-sshd-config-are-configured
          - uid: mondoo-freebsd-security-permissions-on-ssh-private-host-key-files-are-configured
          - uid: mondoo-freebsd-security-permissions-on-ssh-public-host-key-files-are-configured
          - uid: mondoo-freebsd-security-only-strong-ciphers-are-used
          - uid: mondoo-freebsd-security-only-strong-mac-algorithms-are-used
          - uid: mondoo-freebsd-security-only-strong-kex-algorithms-are-used
          - uid: mondoo-freebsd-security-ssh-root-login-is-disabled
          - uid: mondoo-freebsd-security-ssh-permitemptypasswords-is-disabled
          - uid: mondoo-freebsd-security-ssh-hostbasedauthentication-is-disabled
          - uid: mondoo-freebsd-security-ssh-permituserenvironment-is-disabled
          - uid: mondoo-freebsd-security-ssh-ignorerhosts-is-enabled
          - uid: mondoo-freebsd-security-ssh-maxauthtries-is-set-to-4-or-less
          - uid: mondoo-freebsd-security-ssh-logingracetime-is-configured
          - uid: mondoo-freebsd-security-ssh-loglevel-is-appropriate
          - uid: mondoo-freebsd-security-ssh-idle-timeout-interval-is-configured
          - uid: mondoo-freebsd-security-ssh-disableforwarding-is-enabled
          - uid: mondoo-freebsd-security-ssh-usepam-is-enabled
      - title: Sensitive Files
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-permissions-on-etc-passwd-are-configured
          - uid: mondoo-freebsd-security-permissions-on-etc-group-are-configured
          - uid: mondoo-freebsd-security-permissions-on-etc-master-passwd-are-configured
          - uid: mondoo-freebsd-security-permissions-on-etc-shells-are-configured
          - uid: mondoo-freebsd-security-permissions-on-bootloader-config-are-configured
      - title: Users and Groups
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-root-is-the-only-uid-0-account
          - uid: mondoo-freebsd-security-no-duplicate-uids-exist
          - uid: mondoo-freebsd-security-no-duplicate-gids-exist
          - uid: mondoo-freebsd-security-no-duplicate-user-names-exist
          - uid: mondoo-freebsd-security-no-duplicate-group-names-exist
          - uid: mondoo-freebsd-security-all-groups-in-passwd-exist-in-group
      - title: Logging
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-syslogd-is-enabled-and-running
          - uid: mondoo-freebsd-security-syslogd-is-not-accepting-remote-messages

      - title: Privilege Escalation
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-sudo-is-installed
          - uid: mondoo-freebsd-security-sudo-commands-use-pty
          - uid: mondoo-freebsd-security-sudo-nopasswd-is-not-configured
      - title: Firewall
        filters: |
          asset.platform == "freebsd"
        checks:
          - uid: mondoo-freebsd-security-firewall-is-enabled
    scoring_system: highest impact
queries:
  #
  # Kernel and Process Hardening
  #
  - uid: mondoo-freebsd-security-aslr-is-enabled
    title: Ensure address space layout randomization (ASLR) is enabled
    impact: 90
    mql: |
      kernel.parameters["kern.elf64.aslr.enable"] == 1
    docs:
      desc: |
        This check verifies that Address Space Layout Randomization (ASLR) is enabled on FreeBSD by confirming that the kernel parameter `kern.elf64.aslr.enable` is set to 1.

        **Why this matters**

        ASLR randomizes the memory layout of a process, making it significantly harder for attackers to exploit memory corruption vulnerabilities such as buffer overflows. Without ASLR, attackers can reliably predict memory addresses and craft exploits targeting known locations of critical functions and data structures.

        Enabling ASLR is one of the most effective exploit mitigation techniques available and should be enabled on all FreeBSD systems.
      refs:
        - title: FreeBSD Security Mitigations
          url: https://man.freebsd.org/cgi/man.cgi?query=mitigations&sektion=7
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Enable ASLR immediately:

                ```bash
                sysctl kern.elf64.aslr.enable=1
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                kern.elf64.aslr.enable=1
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Enabling ASLR..."
            sysctl kern.elf64.aslr.enable=1

            if grep -q '^kern.elf64.aslr.enable' /etc/sysctl.conf 2>/dev/null; then
              sed -i '' 's/^kern.elf64.aslr.enable=.*/kern.elf64.aslr.enable=1/' /etc/sysctl.conf
            else
              echo 'kern.elf64.aslr.enable=1' >> /etc/sysctl.conf
            fi

            echo "ASLR enabled."
            ```
  - uid: mondoo-freebsd-security-core-dump-backtraces-are-disabled
    title: Ensure core dump backtraces are disabled
    impact: 75
    mql: |
      service("savecore").running == false
      service("savecore").enabled == false
    docs:
      desc: |
        This check verifies that the `savecore` service is not running or enabled. Core dumps capture the memory contents of a process at crash time, potentially exposing sensitive information such as passwords, cryptographic keys, or application data.

        **Why this matters**

        If unrestricted, core dumps can be exploited to extract secrets from crashed privileged processes. Disabling the `savecore` service prevents the system from automatically saving crash dumps, reducing the risk of sensitive data exposure.
      refs:
        - title: FreeBSD savecore(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=savecore&sektion=8
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable the `savecore` service:

            ```bash
            sysrc savecore_enable="NO"
            service savecore stop
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling savecore service..."
            sysrc savecore_enable="NO"
            service savecore onestop 2>/dev/null || true

            echo "savecore service disabled."
            ```
  - uid: mondoo-freebsd-security-core-dump-storage-is-disabled
    title: Ensure core dump storage is disabled
    impact: 75
    mql: |
      command('sysrc -n dumpdev').stdout.trim == "NO"
    docs:
      desc: |
        This check verifies that `dumpdev` is set to `NO`, disabling kernel crash dump storage. Crash dumps can contain sensitive kernel memory contents.

        **Why this matters**

        Kernel crash dumps may expose sensitive data from kernel memory, including credentials and cryptographic material. Unless crash dumps are specifically needed for debugging, they should be disabled.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable crash dump device:

            ```bash
            sysrc dumpdev="NO"
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling crash dump storage..."
            sysrc dumpdev="NO"

            echo "Crash dump storage disabled."
            ```
  #
  # Network Stack
  #
  - uid: mondoo-freebsd-security-ip-forwarding-is-disabled
    title: Ensure IP forwarding is disabled
    impact: 75
    mql: |
      kernel.parameters["net.inet.ip.forwarding"] == 0
      kernel.parameters["net.inet6.ip6.forwarding"] == 0
    docs:
      desc: |
        This check verifies that both IPv4 and IPv6 forwarding are disabled, preventing the system from acting as a network router.

        **Why this matters**

        IP forwarding allows a system to route traffic between network interfaces. Unless the system is specifically intended to function as a router or firewall, forwarding should be disabled to prevent the system from being used to relay traffic between network segments, which could bypass network security controls.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Disable forwarding immediately:

                ```bash
                sysctl net.inet.ip.forwarding=0
                sysctl net.inet6.ip6.forwarding=0
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet.ip.forwarding=0
                net.inet6.ip6.forwarding=0
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling IP forwarding..."
            sysctl net.inet.ip.forwarding=0
            sysctl net.inet6.ip6.forwarding=0

            for param in net.inet.ip.forwarding=0 net.inet6.ip6.forwarding=0; do
              key=$(echo "$param" | cut -d= -f1)
              if grep -q "^${key}" /etc/sysctl.conf 2>/dev/null; then
                sed -i '' "s/^${key}=.*/${param}/" /etc/sysctl.conf
              else
                echo "$param" >> /etc/sysctl.conf
              fi
            done

            echo "IP forwarding disabled."
            ```
  - uid: mondoo-freebsd-security-packet-redirect-sending-is-disabled
    title: Ensure packet redirect sending is disabled
    impact: 75
    mql: |
      kernel.parameters["net.inet.ip.redirect"] == 0
      kernel.parameters["net.inet6.ip6.redirect"] == 0
    docs:
      desc: |
        This check verifies that ICMP redirect sending is disabled for both IPv4 and IPv6, preventing the system from sending routing redirect messages.

        **Why this matters**

        ICMP redirects are used by routers to inform hosts of more efficient routes. An attacker could craft fraudulent ICMP redirect messages to corrupt the routing table of a target system, potentially redirecting traffic through a malicious system for interception or modification.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Disable redirect sending immediately:

                ```bash
                sysctl net.inet.ip.redirect=0
                sysctl net.inet6.ip6.redirect=0
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet.ip.redirect=0
                net.inet6.ip6.redirect=0
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling packet redirect sending..."
            sysctl net.inet.ip.redirect=0
            sysctl net.inet6.ip6.redirect=0

            for param in net.inet.ip.redirect=0 net.inet6.ip6.redirect=0; do
              key=$(echo "$param" | cut -d= -f1)
              if grep -q "^${key}" /etc/sysctl.conf 2>/dev/null; then
                sed -i '' "s/^${key}=.*/${param}/" /etc/sysctl.conf
              else
                echo "$param" >> /etc/sysctl.conf
              fi
            done

            echo "Packet redirect sending disabled."
            ```
  - uid: mondoo-freebsd-security-icmp-redirects-are-not-accepted
    title: Ensure ICMP redirects are not accepted
    impact: 75
    mql: |
      kernel.parameters["net.inet.icmp.drop_redirect"] == 1
      kernel.parameters["net.inet6.icmp6.rediraccept"] == 0
    docs:
      desc: |
        This check verifies that the system drops ICMP redirects for IPv4 and does not accept them for IPv6, preventing outsiders from updating the system's routing tables.

        **Why this matters**

        Accepting ICMP redirects from untrusted sources can allow attackers to manipulate the system's routing table, potentially redirecting traffic through a malicious host for man-in-the-middle attacks. Systems that are not routers should not accept routing instructions from ICMP redirects.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Drop ICMP redirects immediately:

                ```bash
                sysctl net.inet.icmp.drop_redirect=1
                sysctl net.inet6.icmp6.rediraccept=0
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet.icmp.drop_redirect=1
                net.inet6.icmp6.rediraccept=0
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Configuring ICMP redirect rejection..."
            sysctl net.inet.icmp.drop_redirect=1
            sysctl net.inet6.icmp6.rediraccept=0

            for param in net.inet.icmp.drop_redirect=1 net.inet6.icmp6.rediraccept=0; do
              key=$(echo "$param" | cut -d= -f1)
              if grep -q "^${key}" /etc/sysctl.conf 2>/dev/null; then
                sed -i '' "s/^${key}=.*/${param}/" /etc/sysctl.conf
              else
                echo "$param" >> /etc/sysctl.conf
              fi
            done

            echo "ICMP redirect rejection configured."
            ```
  - uid: mondoo-freebsd-security-source-routed-packets-are-not-accepted
    title: Ensure source routed packets are not accepted
    impact: 75
    mql: |
      kernel.parameters["net.inet.ip.accept_sourceroute"] == 0
    docs:
      desc: |
        This check verifies that source routed packets are not accepted, preventing attackers from specifying the route a packet takes through the network.

        **Why this matters**

        Source routing allows the sender to specify the path a packet takes to its destination. Attackers can use source routing to bypass network security devices and access systems on private or protected networks. Disabling acceptance of source routed packets prevents this attack vector.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Disable source routing immediately:

                ```bash
                sysctl net.inet.ip.accept_sourceroute=0
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet.ip.accept_sourceroute=0
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling source routed packets..."
            sysctl net.inet.ip.accept_sourceroute=0

            if grep -q '^net.inet.ip.accept_sourceroute' /etc/sysctl.conf 2>/dev/null; then
              sed -i '' 's/^net.inet.ip.accept_sourceroute=.*/net.inet.ip.accept_sourceroute=0/' /etc/sysctl.conf
            else
              echo 'net.inet.ip.accept_sourceroute=0' >> /etc/sysctl.conf
            fi

            echo "Source routed packets disabled."
            ```
  - uid: mondoo-freebsd-security-tcp-syn-cookies-is-enabled
    title: Ensure TCP SYN cookies are enabled
    impact: 75
    mql: |
      kernel.parameters["net.inet.tcp.syncookies"] == 1
    docs:
      desc: |
        This check verifies that TCP SYN cookies are enabled to protect against SYN flood denial-of-service attacks.

        **Why this matters**

        SYN flood attacks exhaust server resources by sending a large number of SYN packets without completing the TCP handshake. SYN cookies allow the system to continue servicing legitimate connections during a SYN flood by encoding connection state in the SYN-ACK response, eliminating the need to maintain state for half-open connections.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Enable SYN cookies immediately:

                ```bash
                sysctl net.inet.tcp.syncookies=1
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet.tcp.syncookies=1
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Enabling TCP SYN cookies..."
            sysctl net.inet.tcp.syncookies=1

            if grep -q '^net.inet.tcp.syncookies' /etc/sysctl.conf 2>/dev/null; then
              sed -i '' 's/^net.inet.tcp.syncookies=.*/net.inet.tcp.syncookies=1/' /etc/sysctl.conf
            else
              echo 'net.inet.tcp.syncookies=1' >> /etc/sysctl.conf
            fi

            echo "TCP SYN cookies enabled."
            ```
  - uid: mondoo-freebsd-security-ipv6-router-advertisements-are-not-accepted
    title: Ensure IPv6 router advertisements are not accepted
    impact: 75
    mql: |
      kernel.parameters["net.inet6.ip6.accept_rtadv"] == 0
    docs:
      desc: |
        This check verifies that IPv6 router advertisements are not accepted, preventing rogue router advertisement attacks.

        **Why this matters**

        Rogue IPv6 router advertisements can be used in man-in-the-middle attacks by directing traffic through an attacker-controlled system. Unless the system specifically requires IPv6 autoconfiguration, router advertisements should be disabled.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Disable router advertisements immediately:

                ```bash
                sysctl net.inet6.ip6.accept_rtadv=0
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet6.ip6.accept_rtadv=0
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling IPv6 router advertisements..."
            sysctl net.inet6.ip6.accept_rtadv=0

            if grep -q '^net.inet6.ip6.accept_rtadv' /etc/sysctl.conf 2>/dev/null; then
              sed -i '' 's/^net.inet6.ip6.accept_rtadv=.*/net.inet6.ip6.accept_rtadv=0/' /etc/sysctl.conf
            else
              echo 'net.inet6.ip6.accept_rtadv=0' >> /etc/sysctl.conf
            fi

            echo "IPv6 router advertisements disabled."
            ```
  - uid: mondoo-freebsd-security-broadcast-icmp-requests-are-ignored
    title: Ensure broadcast and multicast ICMP requests are ignored
    impact: 75
    mql: |
      kernel.parameters["net.inet.icmp.bmcastecho"] == 0
    docs:
      desc: |
        This check verifies that the system ignores ICMP echo requests sent to broadcast and multicast addresses, preventing Smurf-style amplification attacks.

        **Why this matters**

        Responding to ICMP broadcast requests can be leveraged in network amplification attacks (Smurf attacks), where an attacker sends ICMP echo requests with a spoofed source address to the broadcast address, causing all hosts on the network to respond to the victim. Ignoring these requests eliminates this attack vector.
      refs:
        - title: FreeBSD sysctl(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=8
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Ignore broadcast ICMP requests immediately:

                ```bash
                sysctl net.inet.icmp.bmcastecho=0
                ```

            2. Make the change permanent by adding to `/etc/sysctl.conf`:

                ```ini
                net.inet.icmp.bmcastecho=0
                ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling broadcast ICMP echo responses..."
            sysctl net.inet.icmp.bmcastecho=0

            if grep -q '^net.inet.icmp.bmcastecho' /etc/sysctl.conf 2>/dev/null; then
              sed -i '' 's/^net.inet.icmp.bmcastecho=.*/net.inet.icmp.bmcastecho=0/' /etc/sysctl.conf
            else
              echo 'net.inet.icmp.bmcastecho=0' >> /etc/sysctl.conf
            fi

            echo "Broadcast ICMP echo responses disabled."
            ```
  #
  # Sensitive Services
  #
  - uid: mondoo-freebsd-security-ftp-server-is-not-enabled
    title: Ensure FTP server is not enabled
    impact: 100
    mql: |
      file("/etc/inetd.conf").exists == false || file("/etc/inetd.conf").content.lines.none(_ == /^ftp/)
    docs:
      desc: |
        This check verifies that FTP is not enabled in `/etc/inetd.conf`. FTP transmits authentication credentials and data in cleartext.

        **Why this matters**

        FTP is an insecure protocol that sends usernames, passwords, and file contents in plaintext over the network. Attackers with network access can trivially intercept credentials and data. Use SSH/SFTP or SCP for secure file transfers instead.
      refs:
        - title: FreeBSD inetd(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=inetd&sektion=8
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Comment out or remove FTP entries from `/etc/inetd.conf`:

            ```bash
            sed -i '' 's/^ftp/#ftp/' /etc/inetd.conf
            ```

            If `inetd` is not needed at all, disable it:

            ```bash
            sysrc inetd_enable="NO"
            service inetd stop
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling FTP server..."
            if [ -f /etc/inetd.conf ]; then
              sed -i '' 's/^ftp/#ftp/' /etc/inetd.conf
              echo "FTP entries commented out in /etc/inetd.conf."
            fi

            echo "FTP server disabled."
            ```
  - uid: mondoo-freebsd-security-telnet-server-is-not-enabled
    title: Ensure telnet server is not enabled
    impact: 100
    mql: |
      file("/etc/inetd.conf").exists == false || file("/etc/inetd.conf").content.lines.none(_ == /^telnet/)
    docs:
      desc: |
        This check verifies that the telnet service is not enabled. Telnet transmits all data, including passwords, in cleartext.

        **Why this matters**

        Telnet provides no encryption for sessions or credentials, making it trivial for attackers with network access to intercept login credentials and session data. SSH should be used for all remote administration instead.
      refs:
        - title: FreeBSD inetd(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=inetd&sektion=8
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Comment out or remove telnet entries from `/etc/inetd.conf`:

            ```bash
            sed -i '' 's/^telnet/#telnet/' /etc/inetd.conf
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling telnet server..."
            if [ -f /etc/inetd.conf ]; then
              sed -i '' 's/^telnet/#telnet/' /etc/inetd.conf
              echo "Telnet entries commented out in /etc/inetd.conf."
            fi

            echo "Telnet server disabled."
            ```
  - uid: mondoo-freebsd-security-nis-server-is-not-enabled
    title: Ensure NIS server is not enabled
    impact: 100
    mql: |
      service("ypserv").running == false
      service("ypserv").enabled == false
    docs:
      desc: |
        This check verifies that the NIS (Network Information Service) server `ypserv` is not running or enabled.

        **Why this matters**

        NIS is an inherently insecure protocol that transmits unencrypted authentication data over the network. It is trivially exploitable by attackers who can sniff network traffic. Modern alternatives such as LDAP with TLS should be used instead.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable and stop the NIS server:

            ```bash
            sysrc nis_server_enable="NO"
            service ypserv stop
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling NIS server..."
            sysrc nis_server_enable="NO"
            service ypserv onestop 2>/dev/null || true

            echo "NIS server disabled."
            ```
  - uid: mondoo-freebsd-security-rpcbind-is-not-enabled
    title: Ensure rpcbind is not enabled
    impact: 100
    mql: |
      service("rpcbind").running == false
      service("rpcbind").enabled == false
    docs:
      desc: |
        This check verifies that `rpcbind` is not running or enabled. The `rpcbind` service maps RPC program numbers to network addresses.

        **Why this matters**

        The `rpcbind` service is required for NFS and NIS and has historically been a target for DDoS amplification attacks and information disclosure. If NFS and NIS are not required, `rpcbind` should be disabled to reduce the attack surface.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable and stop `rpcbind`:

            ```bash
            sysrc rpcbind_enable="NO"
            service rpcbind stop
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling rpcbind..."
            sysrc rpcbind_enable="NO"
            service rpcbind onestop 2>/dev/null || true

            echo "rpcbind disabled."
            ```
  - uid: mondoo-freebsd-security-nfs-server-is-not-enabled
    title: Ensure NFS server is not enabled
    impact: 75
    mql: |
      service("nfsd").running == false
      service("nfsd").enabled == false
    docs:
      desc: |
        This check verifies that the NFS daemon is not running or enabled.

        **Why this matters**

        NFS allows file sharing over the network. If not properly configured, NFS can expose sensitive data to unauthorized users. Unless NFS is specifically required, the service should be disabled to reduce the attack surface.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
        - title: FreeBSD Handbook - Network Servers
          url: https://docs.freebsd.org/en/books/handbook/network-servers/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable and stop the NFS daemon:

            ```bash
            sysrc nfs_server_enable="NO"
            service nfsd stop
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling NFS server..."
            sysrc nfs_server_enable="NO"
            service nfsd onestop 2>/dev/null || true

            echo "NFS server disabled."
            ```
  - uid: mondoo-freebsd-security-snmp-server-is-not-enabled
    title: Ensure SNMP server is not enabled
    impact: 85
    mql: |
      service("snmpd").running == false && service("snmpd").enabled == false
        || package("net-snmp").installed == false
    docs:
      desc: |
        This check verifies that `snmpd` is not running and not enabled, or that the `net-snmp` package is not installed.

        **Why this matters**

        SNMPv1 and SNMPv2 transmit community strings and data in cleartext, making them vulnerable to interception. Even SNMPv3 can be misconfigured. Unless SNMP monitoring is specifically required and properly configured with SNMPv3, the SNMP service should be disabled.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable and stop the SNMP daemon:

            ```bash
            sysrc snmpd_enable="NO"
            service snmpd stop
            ```

            Or remove the package entirely:

            ```bash
            pkg delete net-snmp
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling SNMP server..."
            sysrc snmpd_enable="NO" 2>/dev/null || true
            service snmpd onestop 2>/dev/null || true

            echo "SNMP server disabled."
            ```
  - uid: mondoo-freebsd-security-tftp-server-is-not-enabled
    title: Ensure TFTP server is not enabled
    impact: 100
    mql: |
      file("/etc/inetd.conf").exists == false || file("/etc/inetd.conf").content.lines.none(_ == /^tftp/)
    docs:
      desc: |
        This check verifies that TFTP is not enabled in `/etc/inetd.conf`. TFTP has no built-in encryption or authentication.

        **Why this matters**

        TFTP is a protocol designed for simplicity with no authentication or encryption. Any user on the network can read or write files via TFTP. Unless specifically required for network booting infrastructure, TFTP should be disabled.
      refs:
        - title: FreeBSD inetd(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=inetd&sektion=8
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Comment out or remove TFTP entries from `/etc/inetd.conf`:

            ```bash
            sed -i '' 's/^tftp/#tftp/' /etc/inetd.conf
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling TFTP server..."
            if [ -f /etc/inetd.conf ]; then
              sed -i '' 's/^tftp/#tftp/' /etc/inetd.conf
              echo "TFTP entries commented out in /etc/inetd.conf."
            fi

            echo "TFTP server disabled."
            ```
  - uid: mondoo-freebsd-security-imap-and-pop3-server-is-not-enabled
    title: Ensure IMAP and POP3 server is not enabled
    impact: 100
    mql: |
      service("dovecot").running == false
      service("dovecot").enabled == false
      service("cyrus_imapd").running == false
      service("cyrus_imapd").enabled == false
    docs:
      desc: |
        This check verifies that IMAP/POP3 mail access services (`dovecot` and `cyrus_imapd`) are not running or enabled.

        **Why this matters**

        Unless the system is intended to be a mail server, IMAP and POP3 services unnecessarily expand the attack surface. These services, if misconfigured, can expose email contents and credentials.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable and stop mail access services:

            ```bash
            sysrc dovecot_enable="NO"
            service dovecot stop
            sysrc cyrus_imapd_enable="NO"
            service cyrus_imapd stop
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling IMAP and POP3 services..."
            sysrc dovecot_enable="NO" 2>/dev/null || true
            service dovecot onestop 2>/dev/null || true
            sysrc cyrus_imapd_enable="NO" 2>/dev/null || true
            service cyrus_imapd onestop 2>/dev/null || true

            echo "IMAP and POP3 services disabled."
            ```
  - uid: mondoo-freebsd-security-web-proxy-server-is-not-enabled
    title: Ensure web proxy server is not enabled
    impact: 100
    mql: |
      service("squid").running == false && service("squid").enabled == false
        || package("squid").installed == false
    docs:
      desc: |
        This check verifies that the `squid` web proxy server is not running and not enabled, or that the package is not installed.

        **Why this matters**

        A web proxy server, if misconfigured, can allow unauthorized users to relay traffic through the system, bypass network security controls, or access internal resources. Unless proxy functionality is specifically required, it should be disabled.
      refs:
        - title: FreeBSD rc.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=rc.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Disable and stop the proxy server:

            ```bash
            sysrc squid_enable="NO"
            service squid stop
            ```

            Or remove the package entirely:

            ```bash
            pkg delete squid
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Disabling web proxy server..."
            sysrc squid_enable="NO" 2>/dev/null || true
            service squid onestop 2>/dev/null || true

            echo "Web proxy server disabled."
            ```
  - uid: mondoo-freebsd-security-mail-transfer-agent-is-configured-for-local-only-mode
    title: Ensure mail transfer agent is configured for local-only mode
    impact: 85
    filters: |
      package("postfix").installed
    mql: |
      file("/usr/local/etc/postfix/main.cf").content.lines.where(_ == /^\s*inet_interfaces\s*=/).all(_ == /localhost/)
    docs:
      desc: |
        This check verifies that Postfix, if installed, is configured to only process local mail by setting `inet_interfaces` to `localhost`.

        **Why this matters**

        A mail transfer agent that listens on all network interfaces can be used as an open relay for spam or as an attack vector. Unless the system is intended to be a mail server, the MTA should only accept mail from the local system.
      refs:
        - title: FreeBSD Handbook - Network Servers
          url: https://docs.freebsd.org/en/books/handbook/network-servers/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/usr/local/etc/postfix/main.cf` and set:

            ```ini
            inet_interfaces = localhost
            ```

            Then restart Postfix:

            ```bash
            service postfix restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            POSTFIX_CONF="/usr/local/etc/postfix/main.cf"

            if [ ! -f "$POSTFIX_CONF" ]; then
              echo "Postfix configuration not found at $POSTFIX_CONF. Skipping."
              exit 0
            fi

            echo "Configuring Postfix for local-only mode..."
            if grep -q '^inet_interfaces' "$POSTFIX_CONF" 2>/dev/null; then
              sed -i '' 's/^inet_interfaces.*/inet_interfaces = localhost/' "$POSTFIX_CONF"
            else
              echo 'inet_interfaces = localhost' >> "$POSTFIX_CONF"
            fi

            service postfix restart 2>/dev/null || true

            echo "Postfix configured for local-only mode."
            ```
  #
  # SSH Server Configuration
  #
  - uid: mondoo-freebsd-security-permissions-on-sshd-config-are-configured
    title: Ensure permissions on /etc/ssh/sshd_config are configured
    impact: 80
    mql: |
      file("/etc/ssh/sshd_config") {
        user.name == 'root'
        group.name == 'wheel'
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that `/etc/ssh/sshd_config` is owned by `root:wheel` and is not readable by group or other users.

        **Why this matters**

        The SSH daemon configuration file controls how remote access to the system is handled. If this file is readable by unauthorized users, they can learn about the system's SSH configuration and potentially identify weaknesses. If writable, an attacker could weaken the SSH configuration.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions:

            ```bash
            chown root:wheel /etc/ssh/sshd_config
            chmod 0600 /etc/ssh/sshd_config
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on /etc/ssh/sshd_config..."
            chown root:wheel /etc/ssh/sshd_config
            chmod 0600 /etc/ssh/sshd_config

            echo "Permissions on /etc/ssh/sshd_config configured."
            ```
  - uid: mondoo-freebsd-security-permissions-on-ssh-private-host-key-files-are-configured
    title: Ensure permissions on SSH private host key files are configured
    impact: 100
    mql: |
      files.find(from: "/etc/ssh", type: "file").where(path == /ssh_host_.*key$/).list {
        path
        user.name == 'root'
        permissions.user_executable == false
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that SSH private host key files under `/etc/ssh/` are owned by root with mode 0600 or more restrictive.

        **Why this matters**

        SSH private host keys are used to authenticate the server to clients. If these keys are exposed to unauthorized users, an attacker could impersonate the server, enabling man-in-the-middle attacks. Private keys must be accessible only to root.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions on all SSH private host key files:

            ```bash
            find /etc/ssh -name 'ssh_host_*key' -exec chown root:wheel {} \;
            find /etc/ssh -name 'ssh_host_*key' -exec chmod 0600 {} \;
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on SSH private host key files..."
            find /etc/ssh -name 'ssh_host_*key' ! -name '*.pub' -exec chown root:wheel {} \;
            find /etc/ssh -name 'ssh_host_*key' ! -name '*.pub' -exec chmod 0600 {} \;

            echo "SSH private host key file permissions configured."
            ```
  - uid: mondoo-freebsd-security-permissions-on-ssh-public-host-key-files-are-configured
    title: Ensure permissions on SSH public host key files are configured
    impact: 70
    mql: |
      files.find(from: "/etc/ssh", type: "file").where(path == /ssh_host_.*key\.pub$/).list {
        path
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that SSH public host key files have no write or execute permissions for group or other.

        **Why this matters**

        While public keys are not secret, unauthorized modification of public host key files could lead to authentication failures or allow an attacker to substitute their own key. Public key files should be writable only by root.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct permissions on all SSH public host key files:

            ```bash
            find /etc/ssh -name 'ssh_host_*key.pub' -exec chown root:wheel {} \;
            find /etc/ssh -name 'ssh_host_*key.pub' -exec chmod 0644 {} \;
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on SSH public host key files..."
            find /etc/ssh -name 'ssh_host_*key.pub' -exec chown root:wheel {} \;
            find /etc/ssh -name 'ssh_host_*key.pub' -exec chmod 0644 {} \;

            echo "SSH public host key file permissions configured."
            ```
  - uid: mondoo-freebsd-security-only-strong-ciphers-are-used
    title: Ensure only strong ciphers are used
    impact: 100
    mql: |
      sshd.config.ciphers != empty
      sshd.config.ciphers.containsOnly(["chacha20-poly1305@openssh.com","aes256-gcm@openssh.com","aes128-gcm@openssh.com","aes256-ctr","aes192-ctr","aes128-ctr"])
    docs:
      desc: |
        This check verifies that the SSH server is configured to use only strong, modern ciphers and that no weak ciphers such as 3DES, Blowfish, CAST128, or CBC-mode AES are permitted.

        **Why this matters**

        Weak ciphers can be exploited to decrypt SSH traffic. CBC-mode ciphers are vulnerable to plaintext recovery attacks, and legacy ciphers like 3DES have insufficient key lengths for modern security requirements. Only authenticated encryption modes (GCM) and strong stream ciphers (CTR, ChaCha20) should be used.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"
            CIPHERS="chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr"

            echo "Configuring strong SSH ciphers..."
            if grep -q '^Ciphers' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' "s/^Ciphers.*/Ciphers ${CIPHERS}/" "$SSHD_CONFIG"
            else
              echo "Ciphers ${CIPHERS}" >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "Strong SSH ciphers configured."
            ```
  - uid: mondoo-freebsd-security-only-strong-mac-algorithms-are-used
    title: Ensure only strong MAC algorithms are used
    impact: 80
    mql: |
      sshd.config.macs != empty
      sshd.config.macs.containsOnly(["umac-128-etm@openssh.com","hmac-sha2-256-etm@openssh.com","hmac-sha2-512-etm@openssh.com","umac-128@openssh.com","hmac-sha2-256","hmac-sha2-512"])
    docs:
      desc: |
        This check verifies that the SSH server uses only strong Message Authentication Code (MAC) algorithms and that weak algorithms such as MD5, SHA1-96, RIPEMD160, and UMAC-64 variants are not permitted.

        **Why this matters**

        MAC algorithms ensure the integrity of data transmitted over SSH. Weak MAC algorithms can be exploited to tamper with SSH traffic without detection. Only SHA-256/SHA-512 based MACs and UMAC-128 should be used.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            MACs umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"
            MACS="umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512"

            echo "Configuring strong SSH MAC algorithms..."
            if grep -q '^MACs' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' "s/^MACs.*/MACs ${MACS}/" "$SSHD_CONFIG"
            else
              echo "MACs ${MACS}" >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "Strong SSH MAC algorithms configured."
            ```
  - uid: mondoo-freebsd-security-only-strong-kex-algorithms-are-used
    title: Ensure only strong key exchange algorithms are used
    impact: 100
    mql: |
      sshd.config.kexs != empty
      sshd.config.kexs.containsOnly(["sntrup761x25519-sha512@openssh.com","curve25519-sha256@libssh.org","curve25519-sha256","diffie-hellman-group18-sha512","diffie-hellman-group16-sha512"])
    docs:
      desc: |
        This check verifies that the SSH server uses only strong key exchange algorithms and that weak algorithms such as diffie-hellman-group1-sha1 and diffie-hellman-group14-sha1 are not permitted.

        **Why this matters**

        The key exchange algorithm determines the shared secret used to encrypt the SSH session. Weak key exchange algorithms may be vulnerable to eavesdropping or man-in-the-middle attacks. Only modern, strong algorithms based on Curve25519 or large Diffie-Hellman groups with SHA-512 should be used.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            KexAlgorithms sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,curve25519-sha256,diffie-hellman-group18-sha512,diffie-hellman-group16-sha512
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"
            KEXS="sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,curve25519-sha256,diffie-hellman-group18-sha512,diffie-hellman-group16-sha512"

            echo "Configuring strong SSH key exchange algorithms..."
            if grep -q '^KexAlgorithms' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' "s/^KexAlgorithms.*/KexAlgorithms ${KEXS}/" "$SSHD_CONFIG"
            else
              echo "KexAlgorithms ${KEXS}" >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "Strong SSH key exchange algorithms configured."
            ```
  - uid: mondoo-freebsd-security-ssh-root-login-is-disabled
    title: Ensure SSH root login is disabled
    impact: 100
    mql: |
      sshd.config.params["PermitRootLogin"] == "no" || sshd.config.params["PermitRootLogin"] == "prohibit-password" || sshd.config.params["PermitRootLogin"] == "without-password"
    docs:
      desc: |
        This check verifies that direct root login via SSH is disabled or restricted to key-based authentication only.

        **Why this matters**

        Allowing direct root login over SSH provides attackers with a known username to target in brute force attacks. Disabling root login forces administrators to authenticate as individual users first and then escalate privileges, improving accountability and reducing the attack surface.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            PermitRootLogin no
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Disabling SSH root login..."
            if grep -q '^PermitRootLogin' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^PermitRootLogin.*/PermitRootLogin no/' "$SSHD_CONFIG"
            elif grep -q '^#PermitRootLogin' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#PermitRootLogin.*/PermitRootLogin no/' "$SSHD_CONFIG"
            else
              echo 'PermitRootLogin no' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH root login disabled."
            ```
  - uid: mondoo-freebsd-security-ssh-permitemptypasswords-is-disabled
    title: Ensure SSH PermitEmptyPasswords is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitEmptyPasswords"] == "no"
    docs:
      desc: |
        This check verifies that SSH does not allow authentication with empty passwords.

        **Why this matters**

        Accounts with empty passwords provide trivial access to any attacker who discovers or guesses the username. SSH should never allow authentication without a password or key.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            PermitEmptyPasswords no
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Disabling SSH empty passwords..."
            if grep -q '^PermitEmptyPasswords' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' "$SSHD_CONFIG"
            elif grep -q '^#PermitEmptyPasswords' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/' "$SSHD_CONFIG"
            else
              echo 'PermitEmptyPasswords no' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH empty passwords disabled."
            ```
  - uid: mondoo-freebsd-security-ssh-hostbasedauthentication-is-disabled
    title: Ensure SSH HostbasedAuthentication is disabled
    impact: 70
    mql: |
      sshd.config.params["HostbasedAuthentication"] == "no"
    docs:
      desc: |
        This check verifies that host-based authentication is disabled in SSH.

        **Why this matters**

        Host-based authentication trusts the connecting host rather than the individual user, similar to the insecure `.rhosts` mechanism. An attacker who compromises a trusted host can access all systems that trust it. User-based authentication (passwords or keys) should be used instead.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            HostbasedAuthentication no
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Disabling SSH host-based authentication..."
            if grep -q '^HostbasedAuthentication' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^HostbasedAuthentication.*/HostbasedAuthentication no/' "$SSHD_CONFIG"
            elif grep -q '^#HostbasedAuthentication' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#HostbasedAuthentication.*/HostbasedAuthentication no/' "$SSHD_CONFIG"
            else
              echo 'HostbasedAuthentication no' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH host-based authentication disabled."
            ```
  - uid: mondoo-freebsd-security-ssh-permituserenvironment-is-disabled
    title: Ensure SSH PermitUserEnvironment is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitUserEnvironment"] == "no"
    docs:
      desc: |
        This check verifies that users cannot set environment variables through SSH.

        **Why this matters**

        Allowing users to set environment variables via SSH can bypass security restrictions. For example, an attacker could set `LD_PRELOAD` to load a malicious shared library or modify `PATH` to execute malicious commands. Disabling this option prevents environment-based privilege escalation.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            PermitUserEnvironment no
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Disabling SSH PermitUserEnvironment..."
            if grep -q '^PermitUserEnvironment' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^PermitUserEnvironment.*/PermitUserEnvironment no/' "$SSHD_CONFIG"
            elif grep -q '^#PermitUserEnvironment' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#PermitUserEnvironment.*/PermitUserEnvironment no/' "$SSHD_CONFIG"
            else
              echo 'PermitUserEnvironment no' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH PermitUserEnvironment disabled."
            ```
  - uid: mondoo-freebsd-security-ssh-ignorerhosts-is-enabled
    title: Ensure SSH IgnoreRhosts is enabled
    impact: 60
    mql: |
      sshd.config.params["IgnoreRhosts"] == "yes"
    docs:
      desc: |
        This check verifies that SSH ignores `.rhosts` and `.shosts` files for authentication.

        **Why this matters**

        The `.rhosts` mechanism provides a trust relationship based on hostname and username, which is inherently insecure. An attacker who controls DNS or compromises a trusted host can exploit this to gain unauthorized access. SSH should always ignore these files.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            IgnoreRhosts yes
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Enabling SSH IgnoreRhosts..."
            if grep -q '^IgnoreRhosts' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^IgnoreRhosts.*/IgnoreRhosts yes/' "$SSHD_CONFIG"
            elif grep -q '^#IgnoreRhosts' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#IgnoreRhosts.*/IgnoreRhosts yes/' "$SSHD_CONFIG"
            else
              echo 'IgnoreRhosts yes' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH IgnoreRhosts enabled."
            ```
  - uid: mondoo-freebsd-security-ssh-maxauthtries-is-set-to-4-or-less
    title: Ensure SSH MaxAuthTries is set to 4 or less
    impact: 75
    mql: |
      sshd.config.params["MaxAuthTries"] <= 4
    docs:
      desc: |
        This check verifies that the SSH `MaxAuthTries` is set to 4 or less to limit the number of authentication attempts per connection.

        **Why this matters**

        Limiting the number of authentication attempts reduces the effectiveness of brute force attacks. With a low `MaxAuthTries` value, an attacker must establish a new connection for each set of attempts, slowing down automated attacks and making them easier to detect.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            MaxAuthTries 4
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Setting SSH MaxAuthTries to 4..."
            if grep -q '^MaxAuthTries' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^MaxAuthTries.*/MaxAuthTries 4/' "$SSHD_CONFIG"
            elif grep -q '^#MaxAuthTries' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#MaxAuthTries.*/MaxAuthTries 4/' "$SSHD_CONFIG"
            else
              echo 'MaxAuthTries 4' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH MaxAuthTries set to 4."
            ```
  - uid: mondoo-freebsd-security-ssh-logingracetime-is-configured
    title: Ensure SSH LoginGraceTime is configured
    impact: 80
    mql: |
      sshd.config.params["LoginGraceTime"] >= 1
      sshd.config.params["LoginGraceTime"] <= 60
    docs:
      desc: |
        This check verifies that `LoginGraceTime` is set between 1 and 60 seconds, limiting the time allowed for authentication.

        **Why this matters**

        A long `LoginGraceTime` allows an attacker to keep unauthenticated connections open, consuming server resources and potentially facilitating brute force attacks. Setting this to 60 seconds or less ensures that idle unauthenticated connections are quickly terminated.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            LoginGraceTime 60
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Setting SSH LoginGraceTime to 60..."
            if grep -q '^LoginGraceTime' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^LoginGraceTime.*/LoginGraceTime 60/' "$SSHD_CONFIG"
            elif grep -q '^#LoginGraceTime' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#LoginGraceTime.*/LoginGraceTime 60/' "$SSHD_CONFIG"
            else
              echo 'LoginGraceTime 60' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH LoginGraceTime set to 60."
            ```
  - uid: mondoo-freebsd-security-ssh-loglevel-is-appropriate
    title: Ensure SSH LogLevel is appropriate
    impact: 60
    mql: |
      sshd.config.params["LogLevel"] == /^(INFO|VERBOSE)$/
    docs:
      desc: |
        This check verifies that the SSH `LogLevel` is set to `INFO` or `VERBOSE`, providing an adequate audit trail.

        **Why this matters**

        Logging SSH authentication events is essential for detecting and investigating unauthorized access attempts. The `INFO` level records login attempts, source addresses, and authentication methods. The `VERBOSE` level adds additional detail useful for forensic analysis. Lower levels may miss important security events.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            LogLevel VERBOSE
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Setting SSH LogLevel to VERBOSE..."
            if grep -q '^LogLevel' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^LogLevel.*/LogLevel VERBOSE/' "$SSHD_CONFIG"
            elif grep -q '^#LogLevel' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#LogLevel.*/LogLevel VERBOSE/' "$SSHD_CONFIG"
            else
              echo 'LogLevel VERBOSE' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH LogLevel set to VERBOSE."
            ```
  - uid: mondoo-freebsd-security-ssh-idle-timeout-interval-is-configured
    title: Ensure SSH idle timeout interval is configured
    impact: 60
    mql: |
      sshd.config.params["ClientAliveInterval"] >= 1
      sshd.config.params["ClientAliveInterval"] <= 300
      sshd.config.params["ClientAliveCountMax"] <= 3
    docs:
      desc: |
        This check verifies that `ClientAliveInterval` is between 1 and 300 seconds and `ClientAliveCountMax` is 3 or less, ensuring idle SSH sessions are terminated.

        **Why this matters**

        Idle SSH sessions left unattended can be hijacked by an attacker with local access to the terminal. Configuring an idle timeout ensures that inactive sessions are automatically disconnected, reducing the window of opportunity for session hijacking.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            ClientAliveInterval 300
            ClientAliveCountMax 3
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Configuring SSH idle timeout..."

            # Set ClientAliveInterval
            if grep -q '^ClientAliveInterval' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^ClientAliveInterval.*/ClientAliveInterval 300/' "$SSHD_CONFIG"
            elif grep -q '^#ClientAliveInterval' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#ClientAliveInterval.*/ClientAliveInterval 300/' "$SSHD_CONFIG"
            else
              echo 'ClientAliveInterval 300' >> "$SSHD_CONFIG"
            fi

            # Set ClientAliveCountMax
            if grep -q '^ClientAliveCountMax' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^ClientAliveCountMax.*/ClientAliveCountMax 3/' "$SSHD_CONFIG"
            elif grep -q '^#ClientAliveCountMax' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#ClientAliveCountMax.*/ClientAliveCountMax 3/' "$SSHD_CONFIG"
            else
              echo 'ClientAliveCountMax 3' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH idle timeout configured."
            ```
  - uid: mondoo-freebsd-security-ssh-disableforwarding-is-enabled
    title: Ensure SSH DisableForwarding is enabled
    impact: 75
    mql: |
      sshd.config.params["DisableForwarding"] == "yes"
    docs:
      desc: |
        This check verifies that SSH forwarding (X11, TCP, agent, and StreamLocal) is disabled.

        **Why this matters**

        SSH forwarding features can be used to tunnel traffic through the SSH server, potentially bypassing network security controls and firewalls. Disabling forwarding prevents the SSH server from being used as a proxy for unauthorized traffic and data exfiltration.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            DisableForwarding yes
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Enabling SSH DisableForwarding..."
            if grep -q '^DisableForwarding' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^DisableForwarding.*/DisableForwarding yes/' "$SSHD_CONFIG"
            elif grep -q '^#DisableForwarding' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#DisableForwarding.*/DisableForwarding yes/' "$SSHD_CONFIG"
            else
              echo 'DisableForwarding yes' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH DisableForwarding enabled."
            ```
  - uid: mondoo-freebsd-security-ssh-usepam-is-enabled
    title: Ensure SSH UsePAM is enabled
    impact: 75
    mql: |
      sshd.config.params["UsePAM"] == "yes"
    docs:
      desc: |
        This check verifies that SSH is configured to use PAM (Pluggable Authentication Modules).

        **Why this matters**

        PAM provides a flexible framework for authentication, session management, and account controls. When UsePAM is disabled, SSH cannot enforce PAM-based policies such as password complexity requirements, account lockout, or session limits. Enabling PAM ensures consistent enforcement of the system's authentication policies.
      refs:
        - title: OpenSSH sshd_config(5)
          url: https://www.openssh.com/cgi-bin/man.cgi?query=sshd_config
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit `/etc/ssh/sshd_config` and set:

            ```
            UsePAM yes
            ```

            Then restart the SSH daemon:

            ```bash
            service sshd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SSHD_CONFIG="/etc/ssh/sshd_config"

            echo "Enabling SSH UsePAM..."
            if grep -q '^UsePAM' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^UsePAM.*/UsePAM yes/' "$SSHD_CONFIG"
            elif grep -q '^#UsePAM' "$SSHD_CONFIG" 2>/dev/null; then
              sed -i '' 's/^#UsePAM.*/UsePAM yes/' "$SSHD_CONFIG"
            else
              echo 'UsePAM yes' >> "$SSHD_CONFIG"
            fi

            service sshd restart

            echo "SSH UsePAM enabled."
            ```
  #
  # Sensitive Files
  #
  - uid: mondoo-freebsd-security-permissions-on-etc-passwd-are-configured
    title: Ensure permissions on /etc/passwd are configured
    impact: 100
    mql: |
      file("/etc/passwd") {
        user.name == 'root'
        group.name == 'wheel'
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that `/etc/passwd` is owned by `root:wheel` and has mode 0644 or more restrictive.

        **Why this matters**

        The `/etc/passwd` file contains user account information. If writable by unauthorized users, an attacker could add or modify accounts to gain access to the system. Proper ownership and permissions ensure only root can modify this critical file.
      refs:
        - title: FreeBSD passwd(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=passwd&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions:

            ```bash
            chown root:wheel /etc/passwd
            chmod 0644 /etc/passwd
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on /etc/passwd..."
            chown root:wheel /etc/passwd
            chmod 0644 /etc/passwd

            echo "Permissions on /etc/passwd configured."
            ```
  - uid: mondoo-freebsd-security-permissions-on-etc-group-are-configured
    title: Ensure permissions on /etc/group are configured
    impact: 100
    mql: |
      file("/etc/group") {
        user.name == 'root'
        group.name == 'wheel'
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that `/etc/group` is owned by `root:wheel` and has mode 0644 or more restrictive.

        **Why this matters**

        The `/etc/group` file defines group membership, which is used for access control. If writable by unauthorized users, an attacker could add themselves to privileged groups and escalate their access.
      refs:
        - title: FreeBSD group(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=group&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions:

            ```bash
            chown root:wheel /etc/group
            chmod 0644 /etc/group
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on /etc/group..."
            chown root:wheel /etc/group
            chmod 0644 /etc/group

            echo "Permissions on /etc/group configured."
            ```
  - uid: mondoo-freebsd-security-permissions-on-etc-master-passwd-are-configured
    title: Ensure permissions on /etc/master.passwd are configured
    impact: 100
    mql: |
      file("/etc/master.passwd") {
        user.name == 'root'
        group.name == 'wheel'
        permissions.user_executable == false
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that `/etc/master.passwd` is owned by `root:wheel` and has mode 0600 or more restrictive. This is the FreeBSD equivalent of `/etc/shadow` and contains password hashes.

        **Why this matters**

        The `/etc/master.passwd` file contains hashed passwords for all user accounts. If readable by unauthorized users, an attacker can obtain password hashes and attempt offline cracking attacks. This file must be accessible only to root.
      refs:
        - title: FreeBSD passwd(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=passwd&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions:

            ```bash
            chown root:wheel /etc/master.passwd
            chmod 0600 /etc/master.passwd
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on /etc/master.passwd..."
            chown root:wheel /etc/master.passwd
            chmod 0600 /etc/master.passwd

            echo "Permissions on /etc/master.passwd configured."
            ```
  - uid: mondoo-freebsd-security-permissions-on-etc-shells-are-configured
    title: Ensure permissions on /etc/shells are configured
    impact: 75
    mql: |
      file("/etc/shells") {
        user.name == 'root'
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that `/etc/shells` is owned by root and has mode 0644 or more restrictive.

        **Why this matters**

        The `/etc/shells` file lists valid login shells. If writable by unauthorized users, an attacker could add a malicious shell that would be accepted by programs like `chsh`, `ftpd`, and other services that validate shells against this file.
      refs:
        - title: FreeBSD shells(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=shells&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions:

            ```bash
            chown root:wheel /etc/shells
            chmod 0644 /etc/shells
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on /etc/shells..."
            chown root:wheel /etc/shells
            chmod 0644 /etc/shells

            echo "Permissions on /etc/shells configured."
            ```
  - uid: mondoo-freebsd-security-permissions-on-bootloader-config-are-configured
    title: Ensure permissions on bootloader config are configured
    impact: 90
    mql: |
      file("/boot/loader.conf") {
        user.name == 'root'
        group.name == 'wheel'
        permissions.user_executable == false
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check verifies that `/boot/loader.conf` is owned by `root:wheel` and has mode 0600 or more restrictive.

        **Why this matters**

        The bootloader configuration file controls kernel parameters and module loading at boot time. If readable by unauthorized users, it may expose sensitive configuration such as bootloader passwords. If writable, an attacker could modify boot parameters to bypass security controls, boot into single-user mode, or load malicious kernel modules.
      refs:
        - title: FreeBSD loader.conf(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=loader.conf&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Set the correct ownership and permissions:

            ```bash
            chown root:wheel /boot/loader.conf
            chmod 0600 /boot/loader.conf
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Setting permissions on /boot/loader.conf..."
            chown root:wheel /boot/loader.conf
            chmod 0600 /boot/loader.conf

            echo "Permissions on /boot/loader.conf configured."
            ```
  #
  # Users and Groups
  #
  - uid: mondoo-freebsd-security-root-is-the-only-uid-0-account
    title: Ensure root is the only UID 0 account
    impact: 75
    mql: |
      users.where( uid == 0 ).all( name == "root" )
    docs:
      desc: |
        This check verifies that only the `root` account has UID 0.

        **Why this matters**

        Any account with UID 0 has unrestricted access to the entire system. Multiple UID 0 accounts make it impossible to determine which administrator performed a given action, undermining accountability. The `toor` account, while traditional on FreeBSD, should be removed if not needed.
      refs:
        - title: FreeBSD passwd(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=passwd&sektion=5
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Identify all UID 0 accounts:

            ```bash
            awk -F: '$3 == 0 { print $1 }' /etc/passwd
            ```

            Remove or change the UID of any account other than `root` that has UID 0.
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking for non-root UID 0 accounts..."
            EXTRA_UID0=$(awk -F: '$3 == 0 && $1 != "root" { print $1 }' /etc/passwd)

            if [ -n "$EXTRA_UID0" ]; then
              echo "WARNING: The following non-root accounts have UID 0:"
              echo "$EXTRA_UID0"
              echo "Please manually remove these accounts or change their UID."
              exit 1
            fi

            echo "Only root has UID 0. No action needed."
            ```
  - uid: mondoo-freebsd-security-no-duplicate-uids-exist
    title: Ensure no duplicate UIDs exist
    impact: 80
    mql: |
      users.list.duplicates(uid).none(uid != 0)
    docs:
      desc: |
        This check verifies that no two non-root users share the same UID.

        **Why this matters**

        Duplicate UIDs break the assumption that each UID maps to a unique user. Files owned by one user would appear to be owned by another, creating accountability gaps and making it impossible to reliably audit user actions or enforce per-user access controls.
      refs:
        - title: FreeBSD passwd(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=passwd&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Identify duplicate UIDs and assign unique UIDs to each user:

            ```bash
            awk -F: '{print $3}' /etc/passwd | sort -n | uniq -d
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking for duplicate UIDs..."
            DUPES=$(awk -F: '{print $3}' /etc/passwd | sort -n | uniq -d)

            if [ -n "$DUPES" ]; then
              echo "WARNING: Duplicate UIDs found:"
              for uid in $DUPES; do
                echo "  UID $uid used by: $(awk -F: -v u="$uid" '$3 == u { print $1 }' /etc/passwd | tr '\n' ' ')"
              done
              echo "Please manually assign unique UIDs to each user."
              exit 1
            fi

            echo "No duplicate UIDs found."
            ```
  - uid: mondoo-freebsd-security-no-duplicate-gids-exist
    title: Ensure no duplicate GIDs exist
    impact: 80
    mql: |
      groups.list.duplicates(gid).none()
    docs:
      desc: |
        This check verifies that no two groups share the same GID.

        **Why this matters**

        Duplicate GIDs create ambiguity in group-based access controls. Files with group ownership may inadvertently grant access to users in an unintended group, leading to unauthorized data access.
      refs:
        - title: FreeBSD group(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=group&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Identify duplicate GIDs and assign unique GIDs to each group:

            ```bash
            awk -F: '{print $3}' /etc/group | sort -n | uniq -d
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking for duplicate GIDs..."
            DUPES=$(awk -F: '{print $3}' /etc/group | sort -n | uniq -d)

            if [ -n "$DUPES" ]; then
              echo "WARNING: Duplicate GIDs found:"
              for gid in $DUPES; do
                echo "  GID $gid used by: $(awk -F: -v g="$gid" '$3 == g { print $1 }' /etc/group | tr '\n' ' ')"
              done
              echo "Please manually assign unique GIDs to each group."
              exit 1
            fi

            echo "No duplicate GIDs found."
            ```
  - uid: mondoo-freebsd-security-no-duplicate-user-names-exist
    title: Ensure no duplicate user names exist
    impact: 80
    mql: |
      users.list.duplicates(name).none()
    docs:
      desc: |
        This check verifies that no duplicate user names exist in `/etc/passwd`.

        **Why this matters**

        Duplicate user names create confusion in access control enforcement and auditing. If two entries share the same username, only one can be reliably used for authentication, while the other may have different UID and group memberships, creating unpredictable behavior.
      refs:
        - title: FreeBSD passwd(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=passwd&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Identify and resolve duplicate user names:

            ```bash
            awk -F: '{print $1}' /etc/passwd | sort | uniq -d
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking for duplicate user names..."
            DUPES=$(awk -F: '{print $1}' /etc/passwd | sort | uniq -d)

            if [ -n "$DUPES" ]; then
              echo "WARNING: Duplicate user names found:"
              echo "$DUPES"
              echo "Please manually resolve duplicate user names."
              exit 1
            fi

            echo "No duplicate user names found."
            ```
  - uid: mondoo-freebsd-security-no-duplicate-group-names-exist
    title: Ensure no duplicate group names exist
    impact: 80
    mql: |
      groups.list.duplicates(name).none()
    docs:
      desc: |
        This check verifies that no duplicate group names exist in `/etc/group`.

        **Why this matters**

        Duplicate group names create ambiguity in group-based access controls. System utilities may resolve a group name to different GIDs depending on which entry is found first, leading to inconsistent and potentially insecure access control behavior.
      refs:
        - title: FreeBSD group(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=group&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Identify and resolve duplicate group names:

            ```bash
            awk -F: '{print $1}' /etc/group | sort | uniq -d
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking for duplicate group names..."
            DUPES=$(awk -F: '{print $1}' /etc/group | sort | uniq -d)

            if [ -n "$DUPES" ]; then
              echo "WARNING: Duplicate group names found:"
              echo "$DUPES"
              echo "Please manually resolve duplicate group names."
              exit 1
            fi

            echo "No duplicate group names found."
            ```
  - uid: mondoo-freebsd-security-all-groups-in-passwd-exist-in-group
    title: Ensure all groups in /etc/passwd exist in /etc/group
    impact: 70
    mql: |
      users.list.all( group != empty )
    docs:
      desc: |
        This check verifies that every user's primary group referenced in `/etc/passwd` has a corresponding entry in `/etc/group`.

        **Why this matters**

        If a user's primary group does not exist in `/etc/group`, the system cannot properly enforce group-based access controls. This can lead to unexpected file permissions and may indicate a corrupted or manually edited system configuration.
      refs:
        - title: FreeBSD passwd(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=passwd&sektion=5
        - title: FreeBSD group(5)
          url: https://man.freebsd.org/cgi/man.cgi?query=group&sektion=5
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Identify users with missing groups and create the missing groups or reassign users:

            ```bash
            pwck -r
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking for users with missing primary groups..."
            MISSING=""
            while IFS=: read -r user _ _ gid _ _ _ _ _; do
              if ! awk -F: -v g="$gid" '$3 == g { found=1 } END { exit !found }' /etc/group 2>/dev/null; then
                MISSING="$MISSING $user(gid=$gid)"
              fi
            done < /etc/passwd

            if [ -n "$MISSING" ]; then
              echo "WARNING: Users with missing primary groups:"
              echo "$MISSING"
              echo "Please create the missing groups or reassign these users."
              exit 1
            fi

            echo "All user groups exist in /etc/group."
            ```
  #
  # Logging
  #
  - uid: mondoo-freebsd-security-syslogd-is-enabled-and-running
    title: Ensure syslogd is enabled and running
    impact: 50
    mql: |
      service("syslogd").enabled
      service("syslogd").running
    docs:
      desc: |
        This check verifies that the `syslogd` service is both enabled and running.

        **Why this matters**

        System logging is critical for security monitoring, incident response, and forensic analysis. Without an active syslog daemon, the system cannot record authentication events, service failures, kernel messages, and other security-relevant events. An attacker could exploit a system without logging to operate undetected.
      refs:
        - title: FreeBSD syslogd(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=syslogd&sektion=8
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Enable and start syslogd:

            ```bash
            sysrc syslogd_enable="YES"
            service syslogd start
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Enabling and starting syslogd..."
            sysrc syslogd_enable="YES"
            service syslogd start 2>/dev/null || service syslogd restart

            echo "syslogd enabled and running."
            ```
  - uid: mondoo-freebsd-security-syslogd-is-not-accepting-remote-messages
    title: Ensure syslogd is not accepting remote messages
    impact: 50
    mql: |
      command('sysrc syslogd_flags').stdout.contains("-s")
    docs:
      desc: |
        This check verifies that `syslogd_flags` contains `-s` (secure mode), so the system does not accept log messages from remote hosts.

        **Why this matters**

        A syslog daemon that accepts remote messages can be targeted with log injection attacks or used in denial-of-service attacks by flooding it with messages. Unless the system is specifically configured as a log aggregation server, it should only process local log messages.
      refs:
        - title: FreeBSD syslogd(8)
          url: https://man.freebsd.org/cgi/man.cgi?query=syslogd&sektion=8
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Enable secure mode for syslogd:

            ```bash
            sysrc syslogd_flags="-s"
            service syslogd restart
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Configuring syslogd secure mode..."
            CURRENT_FLAGS=$(sysrc -n syslogd_flags 2>/dev/null || echo "")
            if echo "$CURRENT_FLAGS" | grep -q -- '-s'; then
              echo "syslogd_flags already contains -s."
            else
              sysrc syslogd_flags="-s"
            fi

            service syslogd restart

            echo "syslogd configured to reject remote messages."
            ```
  #
  # Privilege Escalation
  #
  - uid: mondoo-freebsd-security-sudo-is-installed
    title: Ensure sudo is installed
    impact: 75
    mql: |
      package("sudo").installed
    docs:
      desc: |
        This check verifies that the `sudo` package is installed.

        **Why this matters**

        `sudo` provides granular privilege escalation control, allowing administrators to grant specific users permission to run specific commands as root without sharing the root password. Without `sudo`, privilege escalation typically requires sharing the root password via `su`, which is less secure and less auditable.
      refs:
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Install sudo:

            ```bash
            pkg install sudo
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Installing sudo..."
            if command -v sudo >/dev/null 2>&1; then
              echo "sudo is already installed."
            else
              pkg install -y sudo
              echo "sudo installed."
            fi
            ```
  - uid: mondoo-freebsd-security-sudo-commands-use-pty
    title: Ensure sudo commands use a pseudo terminal
    impact: 75
    filters: |
      package("sudo").installed
    mql: |
      sudoersFiles = files.find(from: "/usr/local/etc/sudoers.d/", type: 'file').list.map(path) + ["/usr/local/etc/sudoers"]
      sudoersFiles.map(file(_).content.lines.where(_ == /^[^#]/)).flat.where(_ == /Defaults/).any(_ == /\s*use_pty/)
    docs:
      desc: |
        This check verifies that sudoers configuration includes `Defaults use_pty`, requiring sudo commands to run in a pseudo terminal.

        **Why this matters**

        When sudo is configured without `use_pty`, a malicious program run via sudo could fork a background process that retains elevated privileges after the sudo command completes. Requiring a pseudo terminal ensures that all child processes are terminated when the terminal session ends, preventing persistent privilege escalation.
      refs:
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit the sudoers file using `visudo` and add:

            ```
            Defaults use_pty
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SUDOERS="/usr/local/etc/sudoers"
            SUDOERS_D="/usr/local/etc/sudoers.d"

            echo "Configuring sudo to use pty..."
            # Check if use_pty is already configured
            HAS_USE_PTY=false
            if grep -q 'use_pty' "$SUDOERS" 2>/dev/null; then
              HAS_USE_PTY=true
            fi
            if [ -d "$SUDOERS_D" ]; then
              for f in "$SUDOERS_D"/*; do
                if [ -f "$f" ] && grep -q 'use_pty' "$f" 2>/dev/null; then
                  HAS_USE_PTY=true
                fi
              done
            fi

            if [ "$HAS_USE_PTY" = false ]; then
              echo 'Defaults use_pty' > "${SUDOERS_D}/99-use-pty"
              chmod 0440 "${SUDOERS_D}/99-use-pty"
              echo "Added 'Defaults use_pty' to ${SUDOERS_D}/99-use-pty."
            else
              echo "'use_pty' is already configured."
            fi
            ```
  - uid: mondoo-freebsd-security-sudo-nopasswd-is-not-configured
    title: Ensure NOPASSWD is not configured in sudoers
    impact: 75
    filters: |
      package("sudo").installed
    mql: |
      sudoerFiles = files.find(from: "/usr/local/etc/sudoers.d", type: "file").map(path) + ["/usr/local/etc/sudoers"]
      sudoerFiles.where(file(_).exists).all(
        file(_).content.lines.where( _ == /^[^#]/ ).where(_ == /nopasswd/i) == []
      )
    docs:
      desc: |
        This check verifies that no sudoers files contain `NOPASSWD` entries, requiring users to authenticate before running commands with elevated privileges.

        **Why this matters**

        `NOPASSWD` entries in sudoers allow users to run commands as root without entering a password. If an attacker compromises a user account with `NOPASSWD` access, they can immediately escalate to root without any additional authentication barrier. Requiring password authentication for sudo adds an important layer of defense.
      refs:
        - title: FreeBSD Handbook - Security
          url: https://docs.freebsd.org/en/books/handbook/security/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit the sudoers file using `visudo` and remove any `NOPASSWD` entries:

            ```bash
            visudo
            ```

            Replace lines containing `NOPASSWD:` with `PASSWD:` or simply remove the `NOPASSWD` tag.
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            SUDOERS="/usr/local/etc/sudoers"
            SUDOERS_D="/usr/local/etc/sudoers.d"

            echo "Checking for NOPASSWD entries in sudoers..."
            FOUND=false

            if grep -i 'nopasswd' "$SUDOERS" 2>/dev/null | grep -v '^#' | grep -qi 'nopasswd'; then
              echo "WARNING: NOPASSWD found in $SUDOERS"
              FOUND=true
            fi

            if [ -d "$SUDOERS_D" ]; then
              for f in "$SUDOERS_D"/*; do
                if [ -f "$f" ] && grep -v '^#' "$f" 2>/dev/null | grep -qi 'nopasswd'; then
                  echo "WARNING: NOPASSWD found in $f"
                  FOUND=true
                fi
              done
            fi

            if [ "$FOUND" = true ]; then
              echo "Please manually edit the sudoers files with 'visudo' to remove NOPASSWD entries."
              exit 1
            fi

            echo "No NOPASSWD entries found in sudoers."
            ```
  #
  # Firewall
  #
  - uid: mondoo-freebsd-security-firewall-is-enabled
    title: Ensure a firewall is enabled
    impact: 60
    mql: |
      service("ipfw").enabled || service("pf").enabled
    docs:
      desc: |
        This check verifies that at least one firewall service (`ipfw` or `pf`) is enabled.

        **Why this matters**

        A firewall is a fundamental network security control that filters incoming and outgoing traffic based on defined rules. Without an active firewall, the system accepts connections on all listening ports, exposing services to potential attacks from the network. FreeBSD supports both `ipfw` and `pf` as firewall options.
      refs:
        - title: FreeBSD Handbook - Firewalls
          url: https://docs.freebsd.org/en/books/handbook/firewalls/
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Enable `ipfw`:

            ```bash
            sysrc firewall_enable="YES"
            sysrc firewall_type="workstation"
            service ipfw start
            ```

            Or enable `pf`:

            ```bash
            sysrc pf_enable="YES"
            service pf start
            ```
        - id: sh
          desc: |
            **Using a Shell Script**

            ```sh
            #!/bin/sh
            set -e

            echo "Checking firewall status..."
            IPFW_ENABLED=$(sysrc -n firewall_enable 2>/dev/null || echo "NO")
            PF_ENABLED=$(sysrc -n pf_enable 2>/dev/null || echo "NO")

            if [ "$IPFW_ENABLED" = "YES" ] || [ "$PF_ENABLED" = "YES" ]; then
              echo "A firewall is already enabled."
            else
              echo "No firewall enabled. Enabling ipfw in workstation mode..."
              sysrc firewall_enable="YES"
              sysrc firewall_type="workstation"
              service ipfw start

              echo "ipfw firewall enabled in workstation mode."
            fi
            ```
