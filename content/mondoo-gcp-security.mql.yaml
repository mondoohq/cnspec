# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-gcp-security
    name: Mondoo Google Cloud (GCP) Security
    version: 3.0.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: gcp,cloud
    require:
      - provider: gcp
      - provider: terraform
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |
        The Mondoo Google Cloud (GCP) Security policy is designed to identify critical misconfigurations that could leave your Google Cloud infrastructure vulnerable to attackers. This policy helps organizations detect and remediate security risks before they can be exploited, reducing the likelihood of unauthorized access, data breaches, privilege escalation, and operational disruptions.

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable. This policy is open-source and we welcome contributions from the community, whether it's adding new checks, refining existing ones, or providing feedback. If you have suggestions to improve this policy, visit our [cnspec repository](https://github.com/mondoohq/cnspec).
    groups:
      - title: Cloud Storage
        checks:
          - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible
          - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled
      - title: Cloud KMS
        checks:
          - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible
          - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days
      - title: Cloud DNS
        checks:
          - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled
          - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used
      - title: Compute Engine Instances
        checks:
          - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys
          - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled
          - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled
          - uid: mondoo-gcp-security-compute-instances-no-default-service-account
          - uid: mondoo-gcp-security-compute-instances-no-public-ip
          - uid: mondoo-gcp-security-compute-instances-oslogin-enabled
          - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled
          - uid: mondoo-gcp-security-compute-instances-vtpm-enabled
          - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account
          - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api
      - title: Cloud SQL
        checks:
          - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls
          - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed
          - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled
          - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled
          - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls
          - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed
          - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled
          - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled
          - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose
          - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls
          - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed
    scoring_system: highest impact
queries:
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account
    title: Ensure that instances are not configured to use the default service account
    impact: 95
    variants:
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-single
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-hcl
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-plan
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Compute Engine instances are not configured to use the default service account (-compute@developer.gserviceaccount.com). Instead, instances should use custom service accounts with only the permissions required for their specific function, adhering to the principle of least privilege.

        **Why this matters**

        When the Compute Engine API is enabled on a new Google Cloud project, Google automatically creates a default Compute Engine service account with the IAM Editor role. This account has broad permissions across many Google Cloud services and is frequently used by default unless explicitly overridden:
          •  Using the default service account grants more privileges than most applications require, increasing the risk of privilege escalation or lateral movement in the event of compromise.
          •  The default service account is shared across all instances in the project, reducing visibility and control over which workloads can access which resources.
          •  Misuse or over-permissioning of default service accounts has been the cause of multiple cloud security incidents, particularly when combined with metadata API access.

        If instances continue to use the default service account, it can lead to:
          •  Excessive permissions, violating least privilege principles and security best practices.
          •  Difficult-to-audit access patterns, as many services share a single identity with broad permissions.
          •  Increased blast radius if the service account credentials are leaked or the instance is compromised.
          •  Non-compliance with security benchmarks such as CIS Google Cloud Platform Foundations Benchmark and NIST 800-53.

        Risk mitigation:
          •  Replace default service accounts with custom service accounts that have narrowly scoped IAM roles tailored to the workload.
          •  Regularly review and audit service account usage to ensure they are aligned with current access needs.
          •  Disable or delete the default service account only after ensuring that no dependent applications or services will be disrupted.
          •  Leverage IAM Conditions and organization policies to prevent the use of default service accounts in new deployments.

        By avoiding the use of the default Compute Engine service account, organizations can enforce better identity isolation, minimize unnecessary permissions, and enhance the overall security posture of their Google Cloud environment.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            To provision or update a compute instance with a custom service account:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ["terraform"]

              service_account {
                email  = "example@example.com"
                scopes = ["user-email", "compute-ro", "storage-ro"]
              }
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            To change the policy using the GCP Console, follow these steps:

            1. Log in to the GCP Console at https://console.cloud.google.com.
            2. Select the Organization and Project where the instance you want to update is running.
            3. Navigate to **Compute Engine**.
            4. Select the compute instance that you want to update.
            5. If the instance is not stopped, select **Stop**. Wait for the instance to stop.
            6. Select **Edit**.
            7. Scroll down to the Service Account section.
            8. Select a different service account.
            9. Select **Save**.
            10. Select **START**.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            To update the service account using the `gcloud` CLI:

            1. Stop the instance:

              ```bash
              gcloud compute instances stop INSTANCE_NAME
              ```

            2. Update the instance:

              ```bash
              gcloud compute instances set-service-account INSTANCE_NAME --service-account=SERVICE_ACCOUNT --scopes [SCOPE1,SCOPE2...]
              ```

            3. Restart the instance:

              ```bash
              gcloud compute instances start INSTANCE_NAME
              ```
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
      gcp.compute.instance.serviceAccounts.none(
        email == /^\d{12}-(compute|cloudservices)@developer\.gserviceaccount\.com$|^[a-z][a-z0-9\-]{4,28}@appspot\.gserviceaccount\.com$/
      )
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(
        nameLabel == 'google_compute_instance'
      ).all(
        blocks.where(
          type == 'service_account'
        ).none(
          arguments.email == /^\d{12}-(compute|cloudservices)@developer\.gserviceaccount\.com$|^[a-z][a-z0-9\-]{4,28}@appspot\.gserviceaccount\.com$/
        )
      )
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(
        type == 'google_compute_instance'
      ).all(
        change.after.service_account.none(
          email == /^\d{12}-(compute|cloudservices)@developer\.gserviceaccount\.com$|^[a-z][a-z0-9\-]{4,28}@appspot\.gserviceaccount\.com$/
        )
      )
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(
        type == 'google_compute_instance'
      ).all(
        values.service_account.none(
          email == /^\d{12}-(compute|cloudservices)@developer\.gserviceaccount\.com$|^[a-z][a-z0-9\-]{4,28}@appspot\.gserviceaccount\.com$/
        )
      )
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api
    title: Ensure instances are not configured to use the default service account with full access to all Cloud APIs
    impact: 90
    variants:
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-single
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-hcl
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-plan
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Compute Engine instances are not provisioned to use the default service account with full access to all Google Cloud APIs. Instead, instances should be assigned custom service accounts with narrowly scoped permissions, adhering to the principle of least privilege.

        **Why this matters**

        By default, when creating a Compute Engine instance, users can assign it “Allow full access to all Cloud APIs”, granting unrestricted access to most Google Cloud services. This setting is overly permissive and introduces significant security risk:
          •  It allows the instance to interact with nearly any Google Cloud API, regardless of the workload's actual needs.
          •  In the event of a compromise, an attacker could use the instance's credentials to access sensitive resources, manipulate cloud infrastructure, or move laterally across services.
          •  The broad access complicates auditing and access management, making it harder to identify excessive privileges or detect misuse.

        If instances are provisioned with full API access, it can lead to:
          •  Privilege escalation and lateral movement, especially if metadata APIs are accessible from within the VM.
          •  Increased blast radius in the event of credential theft or VM compromise.
          •  Violations of least privilege and non-compliance with security frameworks such as CIS GCP Foundations Benchmark, NIST 800-53, and ISO 27001.
          •  Obscured audit trails, since full access allows interactions with multiple services without role-based segmentation.

        Risk mitigation:
          •  Assign custom service accounts to instances with only the specific roles required for their function.
          •  Avoid using the “Allow full access to all Cloud APIs” option during instance creation.
          •  Enforce IAM policies and organizational constraints to block the use of overly permissive API scopes.
          •  Continuously review service account permissions and API scopes as part of your identity and access governance strategy.

        Restricting Compute Engine instances to minimal necessary API access helps contain the impact of security incidents, improves visibility and control, and supports a robust and compliant cloud security posture.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            To provision or update a compute instance with Terraform:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ['terraform']

              service_account {
                # Google recommends custom service accounts with cloud-platform scope and permissions granted via IAM Roles.
                email  = google_service_account.default.email
                scopes = ["cloud-platform"]
              }
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            To change the policy using the Google Cloud Console:

            1. Log in to the GCP Console at https://console.cloud.google.com.
            2. Select the Organization and Project where the instance you want to update is running.
            3. Navigate to **Compute Engine**.
            4. Select the compute instance that you want to update.
            5. If the instance is not stopped, select **Stop**. Wait for the instance to stop.
            6. Select **Edit**.
            7. Scroll down to the Service Account section.
            8. Select a different service account or ensure Allow full access to all Cloud APIs is not selected.
            9. Select **Save**.
            10. Select **START**.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            To update the service account using the `gcloud` CLI:

            1. Stop the instance:

              ```bash
              gcloud compute instances stop INSTANCE_NAME
              ```

            2. Update the instance:

              ```bash
              gcloud compute instances set-service-account INSTANCE_NAME --service-account=SERVICE_ACCOUNT --scopes [SCOPE1,SCOPE2...]
              ```

            3. Restart the instance:

              ```bash
              gcloud compute instances start INSTANCE_NAME
              ```
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.serviceAccounts.contains( email == /^\d{12}-(compute|cloudservices)@developer\.gserviceaccount\.com$|^[a-z][a-z0-9\-]{4,28}@appspot\.gserviceaccount\.com$/ )
      gcp.compute.instance.name != /^gke-/
    mql: |
      gcp.compute.instance.serviceAccounts.none(
        scopes == 'https://www.googleapis.com/auth/cloud-platform'
      )
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(
        nameLabel == 'google_compute_instance'
      ).all(
        blocks.where(
          type == 'service_account' &&
          arguments.email.contains(/^(default|\d{12}-compute@developer\.gserviceaccount\.com)$/)
        ).all(
          arguments.scopes.none(
            _ == /(https?:\/\/www\.googleapis\.com\/auth\/)?cloud-platform/
          )
        )
      )
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(
        type == 'google_compute_instance'
      ).all(
        change.after.service_account.none(
          email == /^(default|\d{12}-compute@developer\.gserviceaccount\.com)$/ &&
          scopes.contains(/(https?:\/\/www\.googleapis\.com\/auth\/)?cloud-platform/)
        )
      )
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(
        type == 'google_compute_instance'
      ).all(
        values.service_account.none(
          email == /^(default|\d{12}-compute@developer\.gserviceaccount\.com)$/ &&
          scopes.contains(/(https?:\/\/www\.googleapis\.com\/auth\/)?cloud-platform/)
        )
      )
  - uid: mondoo-gcp-security-compute-instances-oslogin-enabled
    title: Ensure oslogin is enabled for compute instances
    impact: 70
    variants:
      - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-single
      - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-terraform-state
    docs:
      desc: |
        This check ensures that OS Login is enabled on Google Cloud Platform (GCP) Compute Engine instances to manage SSH access through IAM roles rather than relying on SSH keys stored in project or instance metadata. OS Login improves access control, auditability, and security by centralizing identity-based SSH authentication.

        **Why this matters**

        By default, SSH access to GCP Compute Engine instances is managed using manually added SSH keys in project or instance metadata. This method has several limitations:
          •  SSH keys are difficult to track, audit, and revoke, especially in large or dynamic environments.
          •  Key-based access lacks integration with IAM policies, which makes it harder to enforce centralized identity governance.
          •  Users can retain access indefinitely if SSH keys are not manually removed, creating lingering access risks.

        OS Login solves these issues by integrating SSH access with IAM:
          •  Access is granted or revoked based on IAM roles (roles/compute.osLogin, roles/compute.osAdminLogin).
          •  User access is managed centrally and consistently across all instances.
          •  Login activity is auditable through Cloud Audit Logs and linked to the user's Google identity.

        If OS Login is not enabled, it can lead to:
          •  Stale or orphaned SSH keys, increasing the risk of unauthorized access.
          •  Limited visibility and control over who has access to which instances.
          •  Non-compliance with security best practices and frameworks like CIS GCP Foundations Benchmark, NIST 800-53, and ISO 27001.
          •  Operational complexity, as access changes require manual updates to metadata.

        Risk mitigation:
          •  Enable OS Login by setting the enable-oslogin metadata key to TRUE at the project or instance level.
          •  Use IAM roles to define which users can access which instances, and whether they have standard or administrative privileges.
          •  Leverage OS Login with 2-Step Verification (OS Login 2SV) for enhanced access protection.
          •  Regularly review IAM policies and login activity to ensure appropriate access and detect anomalies.

        Enabling OS Login provides a secure, scalable, and manageable way to control SSH access to Compute Engine instances, aligning with best practices for identity-based access control and centralized policy enforcement in GCP environments.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            To configure OS Login for a project:

            ```hcl
            resource "google_compute_project_metadata" "default" {
              metadata = {
                enable-oslogin = "TRUE"
              }
            }
            ```

            To provision or update a compute instance with Terraform:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ['terraform']

              metadata = {
                "enable-oslogin" = "true"
              }
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            To configure OS Login for a project via Google Cloud Console:

            1. In the Google Cloud console, go to the **Metadata** page.
            2. Select **EDIT**.
            3. Add a metadata entry, setting the key to `enable-oslogin` and the value to `TRUE`.
            4. Select **SAVE** to apply the changes.

            To configure OS Login for an existing instance:

            1. In the Google Cloud console, go to the **Compute Engine**.
            2. Select the name of the instance that you want to enable OS Login on.
            3. On the instance details page, select **EDIT**.
            4. Under **Custom metadata**, add a metadata entry, setting the key to `enable-oslogin` and the value to `TRUE`.
            5. Select **SAVE**.
        - id: console
          desc: |
            **Using Google Cloud CLI**

            To update OS Login for a project using the `gcloud` CLI:

            ```bash
            gcloud compute project-info add-metadata --metadata enable-oslogin=TRUE
            ```

            To update OS Login for an existing instance using the `gcloud` CLI:

            ```bash
            gcloud compute instances add-metadata INSTANCE_NAME --metadata enable-oslogin=TRUE
            ```
  - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-single
    filters: asset.platform == 'gcp-compute-instance'
    mql: gcp.compute.instance.metadata['enable-oslogin'] == true
  - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance' || nameLabel == 'google_compute_project_metadata')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance').all(
        arguments.metadata['enable-oslogin'].upcase  == "TRUE" || arguments.metadata['enable-oslogin'] == true
      )
  - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance' || type == 'google_compute_project_metadata')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance').all(
        change.after.metadata['enable-oslogin'] == true
      )
  - uid: mondoo-gcp-security-compute-instances-oslogin-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance' || type == 'google_compute_project_metadata')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance').all(
        values.metadata['enable-oslogin'] == true
      )
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible
    title: Ensure that Cloud Storage buckets are not anonymously or publicly accessible
    impact: 90
    variants:
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-single
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-hcl
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-plan
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Storage buckets do not have IAM bindings or ACLs that grant access to the allUsers or allAuthenticatedUsers principals. These principals represent unauthenticated and broadly authenticated public access, which significantly increases the risk of unintentional data exposure.

        **Why this matters**

        In Google Cloud, the allUsers principal allows anyone on the internet to access a resource without authentication, while allAuthenticatedUsers allows access to any user with a Google account. Assigning these principals to a Cloud Storage bucket—either directly via IAM roles or indirectly through legacy ACLs—exposes data to a much broader audience than intended.

        This type of access is often misconfigured and can lead to:
          •  Public exposure of sensitive data, including personally identifiable information (PII), internal documents, or application configuration files.
          •  Data misuse or leakage, especially if access is granted with roles beyond read-only permissions.
          •  Non-compliance with regulatory frameworks like GDPR, HIPAA, PCI DSS, ISO 27001, and the CIS GCP Foundations Benchmark.
          •  Audit and incident response challenges, since access by allUsers or allAuthenticatedUsers is not attributable to a specific identity.

        Risk mitigation:
          •  Audit IAM policies and bucket ACLs to detect any bindings involving allUsers or allAuthenticatedUsers.
          •  Remove these principals from bucket policies and replace them with specific identities (e.g., service accounts, groups, or individual users) that require access.
          •  Enable Public Access Prevention to proactively block public access configuration.
          •  Enforce organization policies that restrict or deny the use of these principals across your projects.

        Eliminating access for allUsers and allAuthenticatedUsers on Cloud Storage buckets is a critical step in protecting cloud-resident data, enforcing least privilege access, and ensuring compliance with modern cloud security and privacy standards.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            To update public access configuration using Terraform, ensure `allUsers` and `allAuthenticatedUsers` are not set:

            ```hcl
            resource "google_storage_bucket_iam_binding" "binding" {
              bucket = google_storage_bucket.default.name
              role   = "roles/storage.admin"
              members = [
                "user:jane@example.com",
              ]
            }
            ```

            ```hcl
            resource "google_storage_bucket_iam_member" "member" {
              bucket = google_storage_bucket.default.name
              role   = "roles/storage.admin"
              member = "user:jane@example.com"
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. In the Google Cloud console, go to the **Cloud Storage Bucket** page.
            2. For the bucket you want to enforce public access prevention on, select the more actions menu.
            3. Select **Edit access** from the drop-down menu.
            4. In the Public access card, select **Prevent public access** to enforce public access prevention.
            5. Select **Confirm**.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            To update public access configuration using the `gcloud` cli, ensure `allUsers` and `allAuthenticatedUsers` are not set by removing them:

            ```bash
            # Example: Remove allUsers binding for objectViewer role
            gcloud storage buckets remove-iam-policy-binding gs://BUCKET_NAME --member=allUsers --role=roles/storage.objectViewer

            # Example: Remove allAuthenticatedUsers binding for objectViewer role
            gcloud storage buckets remove-iam-policy-binding gs://BUCKET_NAME --member=allAuthenticatedUsers --role=roles/storage.objectViewer
            ```
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-single
    filters: asset.platform == 'gcp-storage-bucket'
    mql: |
      gcp.storage.bucket.iamPolicy.all(members.none(_ == 'allUsers'))
      gcp.storage.bucket.iamPolicy.all(members.none(_ == 'allAuthenticatedUsers'))
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_storage_bucket_iam_binding' || nameLabel == 'google_storage_bucket_iam_member')
    mql: |
      terraform.resources.where(nameLabel == 'google_storage_bucket_iam_binding').all(
        arguments.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
      terraform.resources.where(nameLabel == 'google_storage_bucket_iam_member').all(
        arguments.member != 'allUsers' && arguments.member != 'allAuthenticatedUsers'
      )
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_storage_bucket_iam_binding' || type == 'google_storage_bucket_iam_member')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_storage_bucket_iam_binding').all(
        change.after.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
      terraform.plan.resourceChanges.where(type == 'google_storage_bucket_iam_member').all(
        change.after.member != 'allUsers' && change.after.member != 'allAuthenticatedUsers'
      )
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_storage_bucket_iam_binding' || type == 'google_storage_bucket_iam_member')
    mql: |
      terraform.state.resources.where(type == 'google_storage_bucket_iam_binding').all(
        values.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
      terraform.state.resources.where(type == 'google_storage_bucket_iam_member').all(
        values.member != 'allUsers' && values.member != 'allAuthenticatedUsers'
      )
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled
    title: Ensure that Cloud Storage buckets have uniform bucket-level access enabled
    impact: 60
    variants:
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-single
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-state
    docs:
      desc: |
        Cloud Storage offers two systems for granting users permission to access your buckets and objects: IAM and Access Control Lists (ACLs). These systems act in parallel - in order for a user to access a Cloud Storage resource, only one of the systems needs to grant the user permission. IAM is used throughout Google Cloud and allows you to grant a variety of permissions at the bucket and project levels. ACLs are used only by Cloud Storage and have limited permission options, but they allow you to grant permissions on a per-object basis.

        It is recommended to enable uniform bucket-level access on Cloud Storage buckets. Uniform bucket-level access is used to unify and simplify how you grant access to your Cloud Storage resources. Cloud Storage offers two systems that act in parallel to grant users permission to access buckets and objects:
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_storage_bucket" "example" {
              name                        = "test-bucket"
              # Enable uniform bucket-level access
              uniform_bucket_level_access = true
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. In the Google Cloud console, go to the **Cloud Storage Buckets** page.
            2. In the list of buckets, select the name of the desired bucket.
            3. Select the **Permissions** tab near the top of the page.
            4. In the **Access control** model section, select **Uniform**.
            5. In the pop-up menu that appears, select **Save**.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            ```bash
            # Enable uniform bucket-level access
            gcloud storage buckets update gs://BUCKET_NAME --uniform-bucket-level-access

            # Alternatively using gsutil
            gsutil uniformbucketlevelaccess set on gs://BUCKET_NAME
            ```
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-single
    filters: asset.platform == 'gcp-storage-bucket'
    mql: gcp.storage.bucket.iamConfiguration.UniformBucketLevelAccess.enabled == true
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_storage_bucket')
    mql: |
      terraform.resources.where(nameLabel == 'google_storage_bucket').all(
        arguments.uniform_bucket_level_access == true
      )
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_storage_bucket')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_storage_bucket').all(
        change.after.uniform_bucket_level_access == true
      )
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_storage_bucket')
    mql: |
      terraform.state.resources.where(type == 'google_storage_bucket').all(
        values.uniform_bucket_level_access == true
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed
    title: Ensure Cloud SQL MySQL instances are not publicly exposed
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-single
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-state
    docs:
      desc: |
        Assigning public IP addresses to Cloud SQL MySQL instances expands the potential attack surface, making databases accessible from the public internet and increasing security risks.

        The recommended practice is to configure instances exclusively with private IP addresses. This enhances security by isolating the database within your VPC network and can reduce latency for internal applications. Be aware that removing a public IP will disrupt existing connections that depend on it; establish and test private connectivity paths before making the change.
      audit: |
        **Using Google Cloud Console**

          1. Navigate to the Cloud SQL Instances page within the Google Cloud Console: https://console.cloud.google.com/sql/instances
          2. Review each MySQL instance listed. For every primary (non-replica) Second Generation instance, examine its networking details to confirm that a Private IP address is assigned and that no Public IP address is present.

        ** Using Google Cloud CLI **

          1. Obtain a list of all your Cloud SQL instances:

            ```bash
            gcloud sql instances list
            ```

          2. For each instance identified as `backendType: SECOND_GEN` and `instanceType: CLOUD_SQL_INSTANCE` (primary instance), retrieve its full configuration details. Read replicas (`instanceType: READ_REPLICA_INSTANCE`) inherit network settings, and First Generation instances do not support private IPs, so they can be skipped for this check.

            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```

          3. Inspect the `ipAddresses` section in the output for the instance. Verify that an entry exists with `type: PRIVATE`. Crucially, ensure there is no entry with `type: PRIMARY`, as this indicates a public IP address. While an instance can technically possess both during transitions, the secure state is having only the `PRIVATE` type assigned.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_sql_database_instance" "example" {
              name             = "example-instance"
              database_version = "MYSQL_8_0"  # Or your preferred version
              region           = "us-central1"  # Replace with your region

              settings {
                tier = "db-f1-micro"

                # Remove public IP by setting ip_configuration.ipv4_enabled to false
                ip_configuration {
                  ipv4_enabled    = false
                  private_network = "projects/PROJECT_ID/global/networks/VPC_NETWORK_NAME"
                }
              }
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page in the Google Cloud Console: https://console.cloud.google.com/sql/instances
            2.  Select the name of the target instance to view its configuration details.
            3.  Navigate to the **Connections** settings tab.
            4.  Under the **Networking** section, locate and uncheck the box labeled **Public IP**.
            5.  Confirm the modification by selecting the **Save** button.

            **Prevention:**

            To proactively enforce that new Cloud SQL instances are not created with public IP addresses, implement the `Restrict Public IP access on Cloud SQL instances` Organization Policy. You can configure this policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1.  Modify the target instance to remove its public IP address and ensure it's associated with a VPC network for private IP access. Replace `INSTANCE_NAME` with the actual instance name and `VPC_NETWORK_NAME` with the desired VPC network name:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --network=VPC_NETWORK_NAME --no-assign-ip
                ```
                *Note: If the instance is already associated with the correct VPC network for private IP, you might only need the `--no-assign-ip` flag.*
            2.  Verify that the public IP address has been removed by inspecting the instance's configuration:
                ```bash
                gcloud sql instances describe INSTANCE_NAME
                ```
                Check the `ipAddresses` section in the output to confirm the absence of an entry with `type: PRIMARY`.
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion.contains(/^MYSQL_/))
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion.contains(/^MYSQL_/)).all(
        ipAddresses.all(
          _.type != "PRIMARY"
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-single
    filters: asset.platform == "gcp-sql-mysql"
    mql: |
      gcp.sql.instance.ipAddresses.all(type != "PRIMARY")
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance')
    mql: |
      terraform.resources.where(nameLabel == "google_sql_database_instance").all(
        blocks.where( type == "settings" ).all(
          blocks.where(type == "ip_configuration").all(arguments.ipv4_enabled == false )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance').all(
        change.after['settings'].all(
          _['ip_configuration'].any(_['ipv4_enabled'] == false)
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance').all(
        values['ip_address'].none(type == 'PRIMARY')
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls
    title: Ensure Cloud SQL MySQL connections require SSL/TLS
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-single
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-state
    docs:
      desc: |
        Requiring SSL/TLS for connections to Cloud SQL MySQL instances encrypts data in transit between the client and the database server. This prevents potential eavesdropping and man-in-the-middle attacks, protecting sensitive data from unauthorized access during transmission.

        It is strongly recommended to configure Cloud SQL instances to enforce SSL/TLS for all incoming connections to maintain data confidentiality and integrity. Note that enabling this setting requires clients to be configured correctly to use SSL/TLS, which might necessitate application updates.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: https://console.cloud.google.com/sql/instances
        2.  Select the name of the MySQL instance you want to audit.
        3.  Select the **Connections** tab.
        4.  Go to the **Security** sub-tab.
        5.  Verify that the checkbox for **Allow only SSL connections** is checked.

        **Using Google Cloud CLI**

        1.  Retrieve the configuration details for the instance:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```
        2.  Inspect the output and locate the `settings.ipConfiguration` section.
        3.  Ensure the value for `sslMode` is set to `ENCRYPTED_ONLY`.

            Example relevant output snippet:
            ```yaml
            settings:
              ipConfiguration:
                sslMode: ENCRYPTED_ONLY
            ```
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page: https://console.cloud.google.com/sql/instances
            2.  Select the name of the target MySQL instance.
            3.  Navigate to the **Connections** tab, then the **Security** sub-tab.
            4.  Check the box labeled **Allow only SSL connections**.
            5.  If it is disabled go to **Security** and check **Allow only SSL connections**
            5.  Select **Save** to apply the change. *Note: This may trigger an instance restart.*

            **Prevention:**

            Always configure new Cloud SQL MySQL instances with the "Allow only SSL connections" option enabled during creation via the Console. Regularly audit instances to ensure compliance.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1.  Enable the SSL Mode to be "ENCRYPTED_ONLY":
                ```bash
                gcloud sql instances patch INSTANCE_NAME --ssl-mode=ENCRYPTED_ONLY
                ```
                *Note: This command may cause the instance to restart.*

            **Prevention:**

            Always configure new Cloud SQL MySQL instances with the `--ssl-mode=ENCRYPTED_ONLY` flag during creation via the CLI. Regularly audit instances to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `ssl_mode` attribute within the `ip_configuration` block is set to `ENCRYPTED_ONLY`:

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-mysql-instance"
              database_version = "MYSQL_8_0"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  ipv4_enabled = true
                  ssl_mode     = "ENCRYPTED_ONLY"
                }
              }
            }
            ```

            **Prevention:**

            Always configure new Cloud SQL MySQL instances with `ssl_mode = "ENCRYPTED_ONLY"` during creation via Terraform. Regularly audit instances to ensure compliance.
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion.contains(/^MYSQL_/))
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion.contains(/^MYSQL_/)).all(
        settings.ipConfiguration.sslMode == 'ENCRYPTED_ONLY'
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-single
    filters: asset.platform == "gcp-sql-mysql"
    mql: |
      gcp.sql.instance.settings.ipConfiguration.sslMode == "ENCRYPTED_ONLY"
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && 
        terraform.resources.contains(nameLabel == 'google_sql_database_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL')).all(
        blocks.where(type == 'settings').all(
          blocks.where(arguments.ssl_mode).all(
            arguments.ssl_mode == "ENCRYPTED_ONLY"
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance').all(
        change.after['settings'].all(
          _['ip_configuration'].all(
            _['ssl_mode'] == 'ENCRYPTED_ONLY'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-state
    filters: |
      asset.platform == 'terraform-state' &&  terraform.state.resources.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance').all(
        values['settings'].all(
          _['ip_configuration'].all(
            _['ssl_mode'] == 'ENCRYPTED_ONLY'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled
    title: Ensure 'skip_show_database' Database Flag for Cloud SQL MySQL Instances is enabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-single
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-state
    docs:
      desc: |
        **Why this matters**

        The 'skip_show_database' flag enhances security by restricting the use of the `SHOW DATABASES` command. When enabled ('on'), only users explicitly granted the `SHOW DATABASES` privilege can execute the command, and they will see all databases. If disabled ('off'), any user can run `SHOW DATABASES`, but they will only see databases for which they possess the `SHOW DATABASES` privilege or other specific privileges. Enabling this flag helps prevent users from discovering the existence of databases they shouldn't access. This setting applies specifically to Cloud SQL for MySQL instances.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a MySQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `skip_show_database` flag is listed and its value is set to `on`.

        **Using Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each MySQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="skip_show_database")|.value'
            ```
            Ensure the output for each MySQL instance is `"on"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(settings.databaseFlags['skip_show_database'] == 'on')"
           ```
           Verify the flag value is `on` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target MySQL instance.
            3.  Select **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, select **Add item**.
            6.  Choose `skip_show_database` from the dropdown and set its value to `on`. If the flag exists but is `off`, change its value to `on`.
            7.  Select **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Update the flag for a specific MySQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags skip_show_database=on
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags skip_show_database=on,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "mysql_instance" {
              name             = "my-mysql-instance"
              database_version = "MYSQL_8_0"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "skip_show_database"
                  value = "on"
                }
                # Include other settings and flags as needed
              }
            }
            ```
    refs:
      - title: Configure database flags
        url: https://docs.cloud.google.com/sql/docs/mysql/flags
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^MYSQL_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(
        settings.databaseFlags['skip_show_database'] == 'on'
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-single
    filters: asset.platform == "gcp-sql-mysql"
    mql: |
      gcp.sql.instance.settings.databaseFlags["skip_show_database"] == "on"
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL'))
    mql: |
      ## Check if a 'skip_show_database' flag exists on all setting blocks of all MySQL instances

      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL')).all(
        blocks.where(type == 'settings').contains(
          blocks.where(type == 'database_flags' && attributes['name'].value == 'skip_show_database') != empty
        )
      )

      ## Check if the 'skip_show_database' flag is set to 'on' for all setting blocks of all MySQL instances

      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'skip_show_database').all(
              arguments['value'] == 'on'
            )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL')) {
        change.after['settings'] {
          _['database_flags'].where(name == 'skip_show_database') {
            _['value'] == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL')) {
        values['settings'] {
          _['database_flags'].where(name == 'skip_show_database') {
            value == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled
    title: Ensure the 'local_infile' Database Flag for Cloud SQL MySQL Instance is disabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-single
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-state
    docs:
      desc: |
        **Why this matters**

        The `local_infile` database flag dictates whether the server permits clients to load data using the `LOAD DATA LOCAL INFILE` statement. Enabling this feature (setting it to `on`) can introduce security vulnerabilities, as a compromised client or a malicious server could potentially access local files on the machine running the client or server, respectively. To mitigate this risk, it is strongly recommended to disable this flag by setting it to `off`. This recommendation applies specifically to Cloud SQL for MySQL instances.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a MySQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `local_infile` flag is listed and its value is set to `off`.

        **Using Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each MySQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="local_infile")|.value'
            ```
            Ensure the output for each MySQL instance is `"off"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(settings.databaseFlags['local_infile'] == 'off')"
           ```
           Verify the flag value is `off` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target MySQL instance.
            3.  Select **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, select **Add item**.
            6.  Choose `local_infile` from the dropdown and set its value to `off`. If the flag exists but is `on`, change its value to `off`.
            7.  Select **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Update the flag for a specific MySQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags local_infile=off
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags local_infile=off,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "mysql_instance" {
              name             = "my-mysql-instance"
              database_version = "MYSQL_8_0"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "local_infile"
                  value = "off"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^MYSQL_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(
        settings.databaseFlags['local_infile'] == 'off'
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-single
    filters: asset.platform == "gcp-sql-mysql"
    mql: |
      gcp.sql.instance.settings.databaseFlags["local_infile"] == "off"
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'local_infile') != empty &&
            blocks.where(type == 'database_flags').where(attributes['name'].value == 'local_infile').all(
              arguments['value'] == 'off'
            )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL')).all(
        change.after['settings'].all(
          _['database_flags'].where(name == 'local_infile').all(
            value == 'off'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL')).all(
        values['settings'].all(
          _['database_flags'].where(name == 'local_infile').all(
            value == 'off'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose
    title: Ensure the 'log_error_verbosity' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'DEFAULT' or 'verbose'
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-single
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-state
    docs:
      desc: |
        **Why this matters**

        The `log_error_verbosity` flag in PostgreSQL controls the level of detail included in server log messages for errors. Possible settings include `terse` (minimal details), `default` (standard details), and `verbose` (includes SQL state codes, source file, function name, and line number). Logging provides essential information for troubleshooting and security analysis. Setting this flag to `default` or `verbose` ensures sufficient detail is captured without being overly sparse. Setting it to `terse` might omit crucial context needed for effective analysis. This recommendation applies specifically to Cloud SQL for PostgreSQL instances.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a PostgreSQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `log_error_verbosity` flag is listed and its value is set to `default` or `verbose`.

        **Using Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each PostgreSQL instance, check the flag's value:
            ```bash
            # This command shows the value, verify it's "default" or "verbose"
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="log_error_verbosity")|.value'
            ```
            Ensure the output for each PostgreSQL instance is `"default"` or `"verbose"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(settings { databaseFlags['log_error_verbosity'] == 'verbose' })"
           ```
           Verify the flag value is `default` or `verbose` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target PostgreSQL instance.
            3.  Select **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, select **Add item**.
            6.  Choose `log_error_verbosity` from the dropdown and set its value to `default` or `verbose`. If the flag exists but is set to `terse`, change its value.
            7.  Select **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Update the flag for a specific PostgreSQL instance (choose `default` or `verbose`):
            ```bash
            # Example using default
            gcloud sql instances patch INSTANCE_NAME --database-flags log_error_verbosity=default

            # Example using VERBOSE
            gcloud sql instances patch INSTANCE_NAME --database-flags log_error_verbosity=verbose
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags log_error_verbosity=default,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting (choose `default` or `verbose`):
            ```hcl
            resource "google_sql_database_instance" "postgres_instance" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "log_error_verbosity"
                  # Choose either "default" or "verbose"
                  value = "default"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^POSTGRES_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings.databaseFlags['log_error_verbosity'] == 'verbose' || settings.databaseFlags['log_error_verbosity'] == 'default'
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-single
    filters: |
      asset.platform == 'gcp-sql-postgresql'
    mql: |
      gcp.project.sql.instance.settings.databaseFlags['log_error_verbosity'] == 'verbose' || gcp.project.sql.instance.settings.databaseFlags['log_error_verbosity'] == 'default'
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_error_verbosity') != empty &&
            blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_error_verbosity').all(
              arguments['value'] == 'verbose' || arguments['value'] == 'default'
            )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-plan
    filters: |
      asset.platform == 'terraform-plan'
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')).all(
        change.after['settings'].all(
          _['database_flags'].where(name == 'log_error_verbosity').all(
            value == 'verbose' || value == 'default'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')).all(
        values['settings'].all(
          _['database_flags'].where(name == 'log_error_verbosity').all(
            value == 'verbose' || value == 'default'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled
    title: Ensure 'log_connections' Database Flag for Cloud SQL PostgreSQL Instances is enabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-single
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-state
    docs:
      desc: |
        **Why this matters**

        By default, PostgreSQL does not log connection attempts. Enabling the `log_connections` flag (setting it to `on`) configures the server to record each attempted connection and successful client authentication. This logging is valuable for security monitoring, allowing administrators to identify unusual connection patterns or potential unauthorized access attempts, and for troubleshooting connectivity issues. This recommendation applies specifically to Cloud SQL for PostgreSQL instances.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a PostgreSQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `log_connections` flag is listed and its value is set to `on`.

        **Using Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each PostgreSQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="log_connections")|.value'
            ```
            Ensure the output for each PostgreSQL instance is `"on"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(settings.databaseFlags['log_connections'] == 'on')"
           ```
           Verify the flag value is `on` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target PostgreSQL instance.
            3.  Select **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, select **Add item**.
            6.  Choose `log_connections` from the dropdown and set its value to `on`. If the flag exists but is `off`, change its value to `on`.
            7.  Select **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Update the flag for a specific PostgreSQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags log_connections=on
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags log_connections=on,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "postgres_instance" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "log_connections"
                  value = "on"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^POSTGRES_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings.databaseFlags['log_connections'] == 'on'
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-single
    filters: |
      asset.platform == 'gcp-sql-postgresql'
    mql: |
      gcp.project.sql.instance.settings.databaseFlags['log_connections'] == 'on'
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_connections') != empty &&
            blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_connections').all(
              arguments['value'] == 'on'
            )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')).all(
        change.after['settings'].all(
          _['database_flags'].where(name == 'log_connections').all(
            value == 'on'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')).all(
        values['settings'].all(
          _['database_flags'].where(name == 'log_connections').all(
            value == 'on'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled
    title: Ensure 'log_disconnections' Database Flag for Cloud SQL PostgreSQL Instances is enabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-single
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-state
    docs:
      desc: |
        **Why this matters**

        PostgreSQL, by default, does not log the end of user sessions or their duration. Enabling the `log_disconnections` flag (setting it to `on`) causes the server to log this information. This data complements the information provided by `log_connections` and is crucial for auditing user activity, identifying long-running or unusual sessions, and troubleshooting connection-related issues. It provides a complete picture of the connection lifecycle. This recommendation applies specifically to Cloud SQL for PostgreSQL instances.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a PostgreSQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `log_disconnections` flag is listed and its value is set to `on`.

        **Using Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each PostgreSQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="log_disconnections")|.value'
            ```
            Ensure the output for each PostgreSQL instance is `"on"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(settings.databaseFlags['log_disconnections'] == 'on')"
           ```
           Verify the flag value is `on` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target PostgreSQL instance.
            3.  Select **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, select **Add item**.
            6.  Choose `log_disconnections` from the dropdown and set its value to `on`. If the flag exists but is `off`, change its value to `on`.
            7.  Select **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Update the flag for a specific PostgreSQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags log_disconnections=on
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags log_disconnections=on,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "postgres_instance" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "log_disconnections"
                  value = "on"
                }
                # Include other settings and flags as needed, e.g., log_connections
                database_flags {
                  name  = "log_connections"
                  value = "on"
                }
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^POSTGRES_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings.databaseFlags['log_disconnections'] == 'on'
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-single
    filters: |
      asset.platform == 'gcp-sql-postgresql'
    mql: |
      gcp.project.sql.instance.settings.databaseFlags['log_disconnections'] == 'on'
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_disconnections') != empty && 
              blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_disconnections').all(
              arguments['value'] == 'on'
            )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')).all(
        change.after['settings'].all(
          _['database_flags'].where(name == 'log_disconnections').all(
            value == 'on'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')).all(
        values['settings'].all(
          _['database_flags'].where(name == 'log_disconnections').all(
            value == 'on'
          )
        )
      )
  - uid: mondoo-gcp-security-compute-instances-no-public-ip
    title: Ensure public IP addresses are not assigned to VM instances
    impact: 75
    variants:
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-single
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-state
    docs:
      desc: |
        Virtual machine (VM) instances within Google Cloud Compute Engine should not be configured with public, external IP addresses.

        **Why this matters**

        Assigning public IP addresses directly to VM instances increases their exposure to potential attacks from the internet. To minimize this attack surface, instances should ideally be placed behind services like Google Cloud Load Balancing, which manage external access securely and efficiently, reducing direct exposure of the VM.

        **Impact:**

        Disabling the external IP address on a Compute instance might disrupt applications or services hosted on that instance if they rely on direct public internet connectivity. Careful planning is required before making this change.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Review the list of VM instances. For each instance, verify that the `External IP` column shows `None`.

        **From Google Cloud CLI**

        Execute the following command to list instances and their network configurations:
        ```
        gcloud compute instances list --format=json
        ```

        1. Examine the JSON output for each instance. Ensure that the `networkInterfaces` array does not contain an `accessConfigs` section. The presence of `accessConfigs` indicates an external IP configuration. Note that the `natIP` field within `accessConfigs` might only appear for running instances or stopped instances with a static external IP. Stopped instances configured for ephemeral IPs might not show `natIP`.

        Example indicating an external IP:
        ```json
        "networkInterfaces": [
         {
          "accessConfigs": [
           {
            "kind": "compute#accessConfig",
            "name": "External NAT",
            "networkTier": "PREMIUM",
            "type": "ONE_TO_ONE_NAT"
           }
          ],
          ...
         }
        ]
        ```

        **Exception:**
        Instances managed by Google Kubernetes Engine (GKE) often require external IPs for node pools or specific services. These instances typically have names starting with `gke-` and possess the label `goog-gke-node`. They should be excluded from this check as their network configuration is managed by GKE.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_compute_instance" "example" {
              name         = "example-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              // Configure the network interface without an access_config block
              // This ensures no external IP is assigned
              network_interface {
                network = "default"
                // No access_config block means no external IP
              }
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Select the name of the target instance to open its details page.
            3. Select the `Edit` button at the top.
            4. Scroll down to the `Network interfaces` section.
            5. For the relevant network interface, select the pencil icon to edit it.
            6. Set the `External IP` dropdown menu to `None`.
            7. Select `Done` to close the network interface settings.
            8. Select `Save` at the bottom of the page to apply the changes.

            **Prevention:**
            Utilize the Organization Policy `constraints/compute.vmExternalIpAccess` to restrict or deny the assignment of external IP addresses to VMs across your organization or specific folders/projects. Configure this policy at: [https://console.cloud.google.com/orgpolicies/compute-vmExternalIpAccess](https://console.cloud.google.com/orgpolicies/compute-vmExternalIpAccess)
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1. First, identify the name of the access configuration associated with the external IP. Describe the instance:
            ```bash
            gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(networkInterfaces[].accessConfigs)'
            ```
            Look for the `name` field within the `accessConfigs` array (e.g., `External NAT`).

            2. Delete the identified access configuration using its name:
            ```bash
            gcloud compute instances delete-access-config INSTANCE_NAME --zone=ZONE --access-config-name="ACCESS_CONFIG_NAME"
            ```
            Replace `INSTANCE_NAME`, `ZONE`, and `ACCESS_CONFIG_NAME` with the appropriate values.
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
      gcp.compute.instance.machineType.name == /n2d-/
    mql: |
      gcp.compute.instance.networkInterfaces.all(accessConfigs == empty)
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-hcl
    filters: |
      asset.platform == "terraform-hcl" && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance').all(
        blocks.where(type == 'network_interface').all(
          blocks.where(type == 'access_config') == empty
        )
      )
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-plan
    filters: |
      asset.platform == "terraform-plan" && terraform.plan.resourceChanges.contains(type == "google_compute_instance")
    mql: |
      terraform.plan.resourceChanges.where(type == "google_compute_instance").all(
        change.after['network_interface'].all(
          _['access_config'] == empty
        )
      )
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-state
    filters: |
      asset.platform == "terraform-state" && terraform.state.resources.contains(type == "google_compute_instance")
    mql: |
      terraform.state.resources.where(type == "google_compute_instance").all(
        values['network_interface'].all(
          _['access_config'] == empty
        )
      )
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account
    title: Ensure the default service account is not used on VM instances
    impact: 80
    variants:
      - uid: mondoo-gcp-security-compute-instances-no-default-service-account-single
      - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-state
    docs:
      desc: |
        VM instances should be configured to use dedicated service accounts instead of the default Compute Engine service account.

        **Why this matters**

        The default Compute Engine service account (`[PROJECT_NUMBER]-compute@developer.gserviceaccount.com`) is automatically granted the highly permissive `Editor` role at the project level. If a VM using this default account is compromised, an attacker could potentially gain broad access to modify resources across the project. To adhere to the principle of least privilege and limit the potential impact of a compromised instance, create and assign custom service accounts with only the necessary permissions required by the VM.

        **Impact:**

        Changing the service account associated with a VM requires stopping and starting the instance. Ensure applications running on the VM can tolerate this brief downtime. Using a custom service account with insufficient permissions might cause applications on the VM to fail if they rely on APIs they can no longer access.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Select on the name of an instance to view its details.
        3. Locate the `API and identity management` section.
        4. Verify that the `Service account` listed is **not** the default Compute Engine service account (which follows the pattern `[PROJECT_NUMBER]-compute@developer.gserviceaccount.com`). Repeat for all relevant instances.

        **From Google Cloud CLI**

        1. List instances along with their associated service account emails:
        ```
        gcloud compute instances list --format='value(name,serviceAccounts[0].email)'
        ```
        Alternatively, for more detailed JSON output:
        ```
        gcloud compute instances list --format=json
        ```
        Then inspect the `serviceAccounts` array for each instance.

        2. For each instance, ensure the listed service account email does not match the default pattern `[PROJECT_NUMBER]-compute@developer.gserviceaccount.com`. You can find your project number using `gcloud projects describe $(gcloud config get-value project) --format='value(projectNumber)'`.

        **Exception:**
        VMs managed by GKE (names starting with `gke-`, labeled `goog-gke-node`) often use specific service accounts managed by GKE itself, which might include the default service account in some configurations. These should typically be excluded from this check unless specific organizational policies dictate otherwise.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            # Create a custom service account with appropriate permissions
            resource "google_service_account" "custom_sa" {
              account_id   = "custom-service-account"
              display_name = "Custom Service Account"
            }

            # Grant necessary roles to the service account
            resource "google_project_iam_member" "service_account_roles" {
              project = "your-project-id"
              role    = "roles/compute.instanceAdmin.v1"
              member  = "serviceAccount:${google_service_account.custom_sa.email}"
              # Add additional role bindings as needed
            }

            # Configure the VM instance to use the custom service account
            resource "google_compute_instance" "example" {
              name         = "example-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              network_interface {
                network = "default"
              }

              # Assign the custom service account to the instance
              service_account {
                email  = google_service_account.custom_sa.email
                scopes = [
                  "https://www.googleapis.com/auth/compute"
                  # Alternatively, you can use more restrictive scopes:
                  # "https://www.googleapis.com/auth/devstorage.read_only",
                  # etc.
                ]
              }
            }
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Select the name of the instance you want to modify.
            3. Select the `STOP` button at the top and confirm. Wait for the instance to stop completely.
            4. Once stopped, Select the `Edit` button.
            5. Scroll down to the `API and identity management` section.
            6. In the `Service account` dropdown, select a suitable custom service account. If needed, create a new service account with appropriate permissions first via the `IAM & Admin` -> `Service Accounts` page.
            7. Select `Save` at the bottom.
            8. Select the `START / RESUME` button at the top to restart the instance.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1. Stop the target instance:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Assign the desired custom service account:
            ```bash
            gcloud compute instances set-service-account INSTANCE_NAME --zone=ZONE --service-account=CUSTOM_SERVICE_ACCOUNT_EMAIL
            ```
            Replace `INSTANCE_NAME`, `ZONE`, and `CUSTOM_SERVICE_ACCOUNT_EMAIL` with the correct values.
            3. Start the instance again:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
      compute_engine_default_service_account_email = gcp.project.number + '-compute@developer.gserviceaccount.com'
      gcp.compute.instance {
        serviceAccounts.none(
          email == compute_engine_default_service_account_email
        )
      }
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-plan
    filters: |
      asset.platform == "terraform-plan" && terraform.plan.resourceChanges.contains(type == "google_compute_instance")
    mql: |
      terraform.plan.resourceChanges.where(type == "google_compute_instance").all(
        change.after['service_account'].all(
          email == /$-compute@developer.gserviceaccount.com/
        )
      )
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-state
    filters: |
      asset.platform == "terraform-state" && terraform.state.resources.contains(type == "google_compute_instance")
    mql: |
      terraform.state.resources.where(type == "google_compute_instance").all(
        values['service_account'].all(
          _['email'] == /$-compute@developer.gserviceaccount.com/
        )
      )
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys
    title: Ensure "Block Project-Wide SSH Keys" is enabled for VM instances
    impact: 80
    variants:
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-single
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-state
    docs:
      desc: |
        Configure VM instances to block project-wide SSH keys, favoring instance-specific keys for access.

        **Why this matters**

        Project-wide SSH keys, managed in the project's metadata, allow users associated with those keys to access *all* VM instances within that project by default. While convenient, this creates a significant security risk: if a project-wide key is compromised, all instances become vulnerable. Enabling the "Block Project-Wide SSH Keys" setting on an instance forces the use of instance-level SSH keys (stored in instance metadata), thereby limiting the scope of access and reducing the blast radius if a key is compromised.

        **Impact:**

        Enabling this setting will prevent users from connecting to the instance using project-wide SSH keys via tools like standard SSH clients. Access using the `gcloud compute ssh` command or the SSH-in-browser feature usually remains unaffected, as these tools often manage temporary or instance-specific keys. Users needing direct SSH access with third-party clients will require instance-specific SSH keys to be added to the VM's metadata.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Select on the name of the instance you want to check.
        3. Scroll down to the `SSH Keys` section.
        4. Verify that the checkbox labeled `Block project-wide SSH keys` is checked. Repeat for all relevant instances.

        **From Google Cloud CLI**

        1. Retrieve the metadata for the instance, specifically looking for the `block-project-ssh-keys` key:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(metadata.items)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Examine the output. Ensure there is an item where `key` is `block-project-ssh-keys` and its corresponding `value` is `true`. If the key is missing or set to `false`, project-wide keys are not blocked.

        Alternatively, list all instances and filter for the metadata key:
        ```
        gcloud compute instances list --format='table(name,zone,metadata.items.filter(key:block-project-ssh-keys).extract(value))'
        ```
        Instances showing `True` in the last column have the setting enabled.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_compute_instance" "example" {
              name         = "example-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              network_interface {
                network = "default"
              }

              # Block project-wide SSH keys
              metadata = {
                block-project-ssh-keys = "true"
              }

              # Other configuration parameters...
            }
            ```
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Select the name of the instance to modify.
            3. Select the `Edit` button at the top.
            4. Scroll down to the `SSH Keys` section (it might be under `Security and access` or a similar heading).
            5. Check the box for `Block project-wide SSH keys`.
            6. Select `Save` at the bottom of the page.
            7. Repeat these steps for all instances where project-wide keys should be blocked.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Enable the setting by adding or updating the instance metadata:
            ```bash
            gcloud compute instances add-metadata INSTANCE_NAME --zone=ZONE --metadata block-project-ssh-keys=true
            ```
            Replace `INSTANCE_NAME` and `ZONE` with the appropriate values. This command will either add the key if it doesn't exist or update its value to `true` if it does.
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
      gcp.compute.instance {
        metadata['block-project-ssh-keys'] == true
      }
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance' && attributes['metadata'] != null)
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance').all(
        attributes['metadata'].value['block-project-ssh-keys'].upcase == "TRUE" || attributes['metadata'].value['block-project-ssh-keys'] == true
      )
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == "google_compute_instance")
    mql: |
      terraform.plan.resourceChanges.where(type == "google_compute_instance").all(
        change.after['metadata']['block-project-ssh-keys'] == true
      )
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == "google_compute_instance")
    mql: |
      terraform.state.resources.where(type == "google_compute_instance").all(
        values['metadata'].all(
          _['block-project-ssh-keys'] == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled
    title: Ensure Confidential VM Service is enabled for all VM instances
    impact: 75
    variants:
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-single
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-state
    docs:
      desc: |
        Enable the Confidential VM service for applicable Compute Engine VM instances to enhance data security during processing.

        **Why this matters**

        While Google Cloud encrypts data at rest and in transit, Confidential Computing adds a layer of protection by encrypting data while it's actively being processed in memory (data-in-use). Confidential VMs utilize hardware-based security features (like AMD) to create an isolated environment where data remains encrypted even during computation. This helps protect sensitive data from potential access by the cloud provider or vulnerabilities in the host system, using hardware-generated, instance-specific keys that are not exportable.

        **Impact:**

        - Confidential VMs currently support specific machine types (primarily N2D series) and may have limitations, such as the lack of support for live migration, meaning instances will be terminated during host maintenance events.
        - Enabling this feature might incur additional costs compared to standard VMs. Refer to the official GCP pricing documentation for details: [https://cloud.google.com/compute/confidential-vm/pricing](https://cloud.google.com/compute/confidential-vm/pricing).
      audit: |
        Note: Confidential Computing is primarily available on N2D machine types. Check current documentation for supported types: [https://cloud.google.com/compute/docs/machine-types#n2d_machine_types](https://cloud.google.com/compute/docs/machine-types#n2d_machine_types)

        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Select the name of an N2D instance (or other supported type) to view its details.
        3. Look for the `Confidential VM service` status indicator within the instance properties.
        4. Ensure the status shows as `Enabled` or `On`.

        **From Google Cloud CLI**

        1. List instances and check their confidential computing configuration:
        ```
        gcloud compute instances list --format='json(name,machineType,confidentialInstanceConfig)'
        ```
        2. For instances using a supported machine type (e.g., containing "n2d-"), verify that the `confidentialInstanceConfig` section exists and the `enableConfidentialCompute` field is set to `true`.

        Example output for a configured instance:
        ```json
        {
         "confidentialInstanceConfig": {
          "enableConfidentialCompute": true
         },
         "machineType": "...",
         "name": "..."
        }
        ```
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_compute_instance" "confidential_vm" {
              name         = "confidential-vm-instance"
              machine_type = "n2d-standard-2"  # Must use an N2D series or other supported machine type
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable Confidential Computing
              confidential_instance_config {
                enable_confidential_compute = true
              }

              # Required setting for Confidential VMs
              scheduling {
                on_host_maintenance = "TERMINATE"
              }

              # Other configuration parameters as needed...
            }
            ```
        - id: console
          desc: |
            The Confidential VM service can only be activated when creating a new VM instance. It cannot be enabled on an existing instance.

            **Using Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Select `CREATE INSTANCE`.
            3. Configure the instance settings (name, region, zone).
            4. Select a supported machine type from the N2D series (or other applicable types) under `Machine configuration`.
            5. Scroll down to the `Confidential VM service` section.
            6. Check the box labeled `Enable the Confidential Computing service on this VM instance`. Note that this usually requires setting the `On host maintenance` policy to `Terminate VM instance`.
            7. Configure other settings as needed (boot disk, networking, etc.).
            8. Select `Create`.
        - id: cli
          desc: |
            The Confidential VM service can only be activated when creating a new VM instance. It cannot be enabled on an existing instance.

            **Using Google Cloud CLI**

            Use the `--confidential-compute` flag during instance creation. You must also set the maintenance policy to `TERMINATE`.

            ```bash
            gcloud compute instances create INSTANCE_NAME \
             --zone=ZONE \
             --machine-type=N2D_MACHINE_TYPE \
             --confidential-compute \
             --maintenance-policy=TERMINATE \
             # Add other necessary flags like --image-project, --image, --network, etc.
            ```

            Replace placeholders like `INSTANCE_NAME`, `ZONE`, and `N2D_MACHINE_TYPE` with appropriate values.
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
      gcp.compute.instance.machineType.name == /n2d-/
    mql: |
      gcp.compute.instance {
        confidentialInstanceConfig['serviceEnabled'] == true
      }
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance').all(
        blocks.where(type == 'confidential_instance_config') != empty && 
          blocks.where(type == 'confidential_instance_config') {
            attributes['enable_confidential_compute'].value == true
          }
      )
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance').all(
        change.after['boot_disk'].all(
          _['initialize_params'].all(
            _['enable_confidential_compute'] == true
          )
        )
      )
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == "google_compute_instance").all(
        values['confidential_instance_config'].all(
          _['enable_confidential_compute'] == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled
    title: Ensure Secure Boot is enabled for all VM instances
    impact: 90
    variants:
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-single
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-state
    docs:
      desc: |
        Enable Secure Boot, a feature of Shielded VMs, on Compute Engine instances to enhance platform security and integrity.

        **Why this matters**

        Shielded VMs provide verifiable integrity for Compute Engine instances, offering protection against boot-level and kernel-level malware and rootkits. Secure Boot is a critical component of this protection. It ensures that the instance boots only with software (like the bootloader and OS kernel) that is digitally signed and trusted. By verifying these signatures against trusted certificates stored in the UEFI firmware, Secure Boot prevents malicious software from taking control during the boot process. Google manages the signing and verification of the firmware itself, establishing a strong root of trust.

        **Impact:**

        Secure Boot requires using a Shielded VM-compatible OS image. Enabling Secure Boot might prevent systems with custom, unsigned kernel drivers or boot components from booting successfully. Ensure all necessary components are properly signed before enabling this feature.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Select the name of the instance you want to check.
        3. In the `VM instance details` page, locate the `Shielded VM` section.
        4. Verify that the `Secure Boot` toggle or status indicator shows `Enabled` or `On`.

        **From Google Cloud CLI**

        1. Describe the instance and check its Shielded VM configuration:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(shieldedInstanceConfig)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Examine the output. Ensure the `shieldedInstanceConfig` object exists and the `enableSecureBoot` field is set to `true`. If `shieldedInstanceConfig` is absent or `enableSecureBoot` is `false`, the feature is not enabled.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_compute_instance" "shielded_vm" {
              name         = "shielded-vm-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  # Use a compatible Shielded VM image
                  image = "gce-uefi-images/ubuntu-2004-focal-v20220419"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable Shielded VM features including Secure Boot
              shielded_instance_config {
                enable_secure_boot          = true
                enable_vtpm                 = true        # Required for Secure Boot
                enable_integrity_monitoring = true        # Recommended with Secure Boot
              }

              # Other configuration parameters as needed...
            }

            # Optional: Enforce Shielded VM at organization level using organization policy
            resource "google_organization_policy" "require_shielded_vm" {
              org_id     = "YOUR_ORGANIZATION_ID"          # Replace with your organization ID
              constraint = "constraints/compute.requireShieldedVm"

              boolean_policy {
                enforced = true
              }
            }
            ```
        - id: console
          desc: |
            Secure Boot can only be enabled on instances using an OS image that supports Shielded VM features.

            **Using Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Select the name of the instance to modify.
            3. If the instance is running, select `STOP` and confirm. Wait for it to stop.
            4. Select `EDIT`.
            5. Scroll to the `Shielded VM` section.
            6. Check the box or toggle the switch to enable `Secure Boot`. Enabling Secure Boot typically requires vTPM and Integrity Monitoring to also be enabled or automatically enabled alongside it.
            7. Select `Save`.
            8. Select `START / RESUME` to restart the instance.

            **Prevention:**
            Enforce the use of Shielded VMs for all new instances by configuring the `constraints/compute.requireShieldedVm` Organization Policy. Manage this policy at: [https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm](https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm). See documentation for details: [https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint](https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint).
        - id: cli
          desc: |
            Secure Boot can only be enabled on instances using an OS image that supports Shielded VM features.

            **Using Google Cloud CLI**

            Ensure the instance uses a compatible image. You can list public Shielded VM images:
            ```bash
            gcloud compute images list --project gce-UEFI-images --no-standard-images --filter="shieldedVmFeatures:(SECURE_BOOT)"
            ```

            1. Stop the instance if it is running:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Update the instance to enable Secure Boot (this command implicitly enables vTPM and Integrity Monitoring as well):
            ```bash
            gcloud compute instances update INSTANCE_NAME --zone=ZONE --shielded-vm-secure-boot
            ```
            3. Start the instance:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance.enableSecureBoot == true
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(
        nameLabel == 'google_compute_instance'
      ).all(
        blocks.where(
          type == 'shielded_instance_config'
        ).all(
           attributes.enable_secure_boot.value == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(
        type == 'google_compute_instance'
      ).all(
        change.after.shielded_instance_config.all(
          enable_secure_boot == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance').all(
        values.shielded_instance_config.all(
          enable_secure_boot == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled
    title: Ensure vTPM is enabled for all VM instances
    impact: 90
    variants:
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-single
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-state
    docs:
      desc: |
        Enable the virtual Trusted Platform Module (vTPM), a feature of Shielded VMs, on Compute Engine instances to support Measured Boot and enhance integrity verification.

        **Why this matters**

        Shielded VMs leverage several security controls to harden instances against threats. The vTPM is a virtualized version of a hardware TPM, providing secure cryptographic functions and secure storage. Its primary role within Shielded VM is to enable Measured Boot. During Measured Boot, the vTPM securely records cryptographic measurements (hashes) of boot components (firmware, bootloader, kernel). This creates a verifiable record of the boot process, forming an integrity policy baseline essential for Integrity Monitoring.

        **Impact:**

        Enabling vTPM is necessary for using Shielded VM's Measured Boot and Integrity Monitoring capabilities. It generally has negligible impact on instance performance and compatibility, but it requires using a Shielded VM-compatible OS image.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Select the name of the instance you want to check.
        3. In the `VM instance details` page, find the `Shielded VM` section.
        4. Verify that the `vTPM` toggle or status indicator shows `Enabled` or `On`.

        **From Google Cloud CLI**

        1. Describe the instance and check its Shielded VM configuration:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(shieldedInstanceConfig)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Look at the output. Ensure the `shieldedInstanceConfig` object is present and the `enableVtpm` field is set to `true`. If `shieldedInstanceConfig` is missing or `enableVtpm` is `false`, the feature is disabled.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_compute_instance" "vtpm_enabled_vm" {
              name         = "vtpm-enabled-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  # Use a compatible Shielded VM image that supports vTPM
                  image = "gce-uefi-images/ubuntu-2004-focal-v20220419"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable vTPM as part of Shielded VM features
              shielded_instance_config {
                enable_vtpm                 = true
                enable_integrity_monitoring = true  # Optional but recommended
                enable_secure_boot          = false # Optional, set to true if needed
              }

              # Other configuration parameters as needed...
            }

            # Optional: Enforce Shielded VM at organization level using organization policy
            resource "google_organization_policy" "require_shielded_vm" {
              org_id     = "YOUR_ORGANIZATION_ID"  # Replace with your organization ID
              constraint = "constraints/compute.requireShieldedVm"

              boolean_policy {
                enforced = true
              }
            }
            ```
        - id: console
          desc: |
            vTPM can only be enabled on instances using an OS image that supports Shielded VM features.

            **Using Google Cloud Console**

            1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Locate and select the instance you want to modify.
            3. If the instance is running, click `STOP` and confirm. Wait until the instance is fully stopped.
            4. Click `EDIT` to modify the instance settings.
            5. Scroll to the `Shielded VM` section.
            6. Enable the `vTPM` option by checking the corresponding box or toggling the switch.
            7. Click `Save` to apply the changes.
            8. Restart the instance by clicking `START / RESUME`.

            **Prevention:**
            Mandate the use of Shielded VMs (which includes vTPM) for new instances via the `constraints/compute.requireShieldedVm` Organization Policy. Configure it at: [https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm](https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm). Refer to documentation: [https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint](https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint).
        - id: cli
          desc: |
            vTPM can only be enabled on instances using an OS image that supports Shielded VM features.

            **Using Google Cloud CLI**

            Ensure the instance uses a compatible image. You can list public Shielded VM images:
            ```bash
            gcloud compute images list --project gce-uefi-images --no-standard-images --filter="shieldedVmFeatures:(VTPM)"
            ```

            1. Stop the instance if it is running:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Update the instance to enable vTPM:
            ```bash
            gcloud compute instances update INSTANCE_NAME --zone=ZONE --shielded-vtpm
            ```
            Note: This command specifically targets vTPM. If Secure Boot or Integrity Monitoring are desired, they might need separate flags (`--shielded-vm-secure-boot`, `--shielded-vm-integrity-monitoring`) or enabling them might implicitly enable vTPM.
            3. Start the instance:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance.enableVtpm == true
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(
        nameLabel == 'google_compute_instance'
      ).all(
        blocks.where(
          type == 'shielded_instance_config'
        ).all(
           attributes.enable_vtpm.value == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(
        type == 'google_compute_instance'
      ).all(
        change.after.shielded_instance_config.all(
          enable_vtpm == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance').all(
        values.shielded_instance_config.all(
          enable_vtpm == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled
    title: Ensure Integrity Monitoring is enabled for all VM instances
    impact: 90
    variants:
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-single
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-state
    docs:
      desc: |
        Enable Integrity Monitoring, a feature of Shielded VMs, on Compute Engine instances to detect potentially malicious modifications to the boot sequence.

        **Why this matters**

        Shielded VMs provide enhanced security for instances. Integrity Monitoring, a key component, leverages the measurements taken by the vTPM during Measured Boot. It compares the boot measurements of the current boot process against a known good baseline established during a previous boot. If discrepancies are detected, it indicates that the bootloader, kernel, or other critical boot components may have been tampered with, potentially by rootkits or boot-level malware. This allows administrators to identify compromised instances and take appropriate action.

        **Impact:**

        Integrity Monitoring requires both a Shielded VM-compatible OS image and vTPM to be enabled. It provides valuable security insights by logging integrity check results to Cloud Logging, with minimal overhead on instance performance.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Select the name of the instance you want to check.
        3. In the `VM instance details` page, locate the `Shielded VM` section.
        4. Verify that the `Integrity Monitoring` toggle or status indicator shows `Enabled` or `On`.

        **From Google Cloud CLI**

        1. Describe the instance and check its Shielded VM configuration:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(shieldedInstanceConfig)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Examine the output. Ensure the `shieldedInstanceConfig` object exists and the `enableIntegrityMonitoring` field is set to `true`. If `shieldedInstanceConfig` is absent or `enableIntegrityMonitoring` is `false`, the feature is not enabled.
      remediation:
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "google_compute_instance" "integrity_monitoring_vm" {
              name         = "integrity-monitoring-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  # Use a compatible Shielded VM image that supports Integrity Monitoring
                  image = "gce-uefi-images/ubuntu-2004-focal-v20220419"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable Integrity Monitoring and vTPM (required) as part of Shielded VM features
              shielded_instance_config {
                enable_integrity_monitoring = true
                enable_vtpm                 = true  # Required for Integrity Monitoring
                enable_secure_boot          = false # Optional, set to true if needed
              }

              # Other configuration parameters as needed...
            }

            # Optional: Enforce Shielded VM at organization level using organization policy
            resource "google_organization_policy" "require_shielded_vm" {
              org_id     = "YOUR_ORGANIZATION_ID"  # Replace with your organization ID
              constraint = "constraints/compute.requireShieldedVm"

              boolean_policy {
                enforced = true
              }
            }
            ```
        - id: console
          desc: |
            Integrity Monitoring requires an instance using an OS image that supports Shielded VM features, and vTPM must also be enabled.

            **Using Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Select the name of the instance to modify.
            3. If the instance is running, select `STOP` and confirm. Wait for it to stop completely.
            4. Click `EDIT`.
            5. Scroll down to the `Shielded VM` section.
            6. Ensure `vTPM` is enabled.
            7. Check the box or toggle the switch to enable `Integrity Monitoring`.
            8. Click `Save`.
            9. Click `START / RESUME` to restart the instance.

            **Prevention:**
            Enforce the use of Shielded VMs (which includes Integrity Monitoring when enabled) for new instances using the `constraints/compute.requireShieldedVm` Organization Policy. Configure this at: [https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm](https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm). See documentation: [https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint](https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint).
        - id: cli
          desc: |
            Integrity Monitoring requires an instance using an OS image that supports Shielded VM features, and vTPM must also be enabled.

            **Using Google Cloud CLI**

            1. Verify that the instance uses a compatible Shielded VM image. You can list public Shielded VM images that support Integrity Monitoring:
            ```bash
            gcloud compute images list --project gce-uefi-images --no-standard-images --filter="shieldedVmFeatures:(INTEGRITY_MONITORING)"
            ```

            2. Stop the instance if it is currently running:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```

            3. Update the instance to enable Integrity Monitoring. This command will also enable vTPM if it is not already enabled:
            ```bash
            gcloud compute instances update INSTANCE_NAME --zone=ZONE --shielded-vm-integrity-monitoring
            ```

            4. Start the instance after the update:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```

            Replace `INSTANCE_NAME` and `ZONE` with the appropriate values for your instance.
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance.enableIntegrityMonitoring == true
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(
        nameLabel == 'google_compute_instance'
      ).all(
        blocks.where(
          type == 'shielded_instance_config'
        ).all(
           arguments.enable_integrity_monitoring == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(
        type == 'google_compute_instance'
      ).all(
        change.after.shielded_instance_config.all(
          enable_integrity_monitoring == true
        )
      )
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance').all(
        values.shielded_instance_config.all(
          enable_integrity_monitoring == true
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed
    title: Ensure Cloud SQL PostgreSQL instances are not publicly exposed
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-single
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-state
    docs:
      desc: |
        Assigning public IP addresses to Cloud SQL PostgreSQL instances expands the potential attack surface, making databases accessible from the public internet and increasing security risks.

        The recommended practice is to configure instances exclusively with private IP addresses. This enhances security by isolating the database within your VPC network and can reduce latency for internal applications. Be aware that removing a public IP will disrupt existing connections that depend on it; establish and test private connectivity paths before making the change. This applies to Second Generation instances.
      audit: |
        **Using Google Cloud Console**

          1. Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
          2. Review the list of PostgreSQL instances. For each primary (non-replica) Second Generation instance:
             - Select the instance name to view its details.
             - Navigate to the **Connections** tab.
             - Confirm that a **Private IP** address is assigned and that no **Public IP** address (type: PRIMARY) is present.

        **Using Google Cloud CLI**

          1. List all Cloud SQL instances in your project:
            ```bash
            gcloud sql instances list
            ```

          2. For each PostgreSQL instance identified as `backendType: SECOND_GEN` and `instanceType: CLOUD_SQL_INSTANCE` (primary instance), retrieve its configuration details:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```

          3. Inspect the `ipAddresses` section in the output:
             - Ensure there is an entry with `type: PRIVATE`.
             - Verify that no entry exists with `type: PRIMARY`, as this indicates a public IP address.

          **Note:** Instances can temporarily have both private and public IPs during transitions. The secure state is when only the **PRIVATE** type is assigned.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud SQL Instances page in the Google Cloud Console: https://console.cloud.google.com/sql/instances.
            2.  Select the name of the target PostgreSQL instance to open its configuration details.
            3.  Navigate to the **Connections** tab.
            4.  In the **Networking** section, uncheck the box labeled **Public IP** to disable public access.
            5.  Click **Save** to apply the changes.

            **Prevention:**

            To ensure new Cloud SQL instances are not created with public IP addresses, enforce the `Restrict Public IP access on Cloud SQL instances` Organization Policy. Configure this policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1.  Modify the target instance to remove its public IP address and ensure it's associated with a VPC network for private IP access. Replace `INSTANCE_NAME` with the actual instance name and `VPC_NETWORK_NAME` with the desired VPC network name:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --network=VPC_NETWORK_NAME --no-assign-ip
                ```
                *Note: If the instance is already associated with the correct VPC network for private IP, you might only need the `--no-assign-ip` flag.*
            2.  Verify that the public IP address has been removed by inspecting the instance's configuration:
                ```bash
                gcloud sql instances describe INSTANCE_NAME
                ```
                Check the `ipAddresses` section in the output to confirm the absence of an entry with `type: PRIMARY`.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `ipv4_enabled` attribute within the `ip_configuration` block is set to `false` or omitted (defaults to false if private network is configured):

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  # Ensure private network is configured
                  private_network = "projects/my-project/global/networks/my-vpc"
                  # Set ipv4_enabled to false or omit it
                  ipv4_enabled    = false
                }
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^POSTGRES_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        ipAddresses.all(_.type != "PRIMARY")
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-single
    filters: |
      asset.platform == 'gcp-sql-postgresql'
    mql: |
      gcp.project.sql.instance.ipAddresses.all(type != "PRIMARY")
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'ip_configuration').all(
            attributes['ipv4_enabled'] == null || attributes['ipv4_enabled'].value == false
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')).all(
        change.after['settings'].all(
          _['ip_configuration'].all(
            _['ipv4_enabled'] == false
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')).all(
        values['settings'].all(
          _['ip_configuration'].all(
            _['ipv4_enabled'] == false
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed
    title: Ensure Cloud SQL for SQL Server instances are not publicly exposed
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-all
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instance-not-publicly-exposed-single
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-state
    docs:
      desc: |
        Assigning public IP addresses to Cloud SQL for SQL Server instances expands the potential attack surface, making databases accessible from the public internet and increasing security risks.

        The recommended practice is to configure instances exclusively with private IP addresses. This enhances security by isolating the database within your VPC network and can reduce latency for internal applications. Be aware that removing a public IP will disrupt existing connections that depend on it; establish and test private connectivity paths before making the change. This applies to Second Generation instances.
      audit: |
        **Using Google Cloud Console**

          1. Navigate to the Cloud SQL Instances page within the Google Cloud Console: https://console.cloud.google.com/sql/instances
          2. Review each SQL Server instance listed. For every primary (non-replica) Second Generation instance, examine its networking details to confirm that a Private IP address is assigned and that no Public IP address (type: PRIMARY) is present.

        ** Using Google Cloud CLI **

          1. Obtain a list of all your Cloud SQL instances:

            ```bash
            gcloud sql instances list
            ```

          2. For each SQL Server instance identified as `backendType: SECOND_GEN` and `instanceType: CLOUD_SQL_INSTANCE` (primary instance), retrieve its full configuration details. Read replicas (`instanceType: READ_REPLICA_INSTANCE`) inherit network settings.

            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```

          3. Inspect the `ipAddresses` section in the output for the instance. Verify that an entry exists with `type: PRIVATE`. Crucially, ensure there is no entry with `type: PRIMARY`, as this indicates a public IP address. While an instance can technically possess both during transitions, the secure state is having only the `PRIVATE` type assigned.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page in the Google Cloud Console: https://console.cloud.google.com/sql/instances
            2.  Select the name of the target SQL Server instance to view its configuration details.
            3.  Navigate to the **Connections** settings tab.
            4.  Under the **Networking** section, locate and uncheck the box labeled **Public IP**.
            5.  Confirm the modification by selecting the **Save** button.

            **Prevention:**

            To proactively enforce that new Cloud SQL instances are not created with public IP addresses, implement the `Restrict Public IP access on Cloud SQL instances` Organization Policy. You can configure this policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1.  Modify the target instance to remove its public IP address and ensure it's associated with a VPC network for private IP access. Replace `INSTANCE_NAME` with the actual instance name and `VPC_NETWORK_NAME` with the desired VPC network name:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --network=VPC_NETWORK_NAME --no-assign-ip
                ```
                *Note: If the instance is already associated with the correct VPC network for private IP, you might only need the `--no-assign-ip` flag.*
            2.  Verify that the public IP address has been removed by inspecting the instance's configuration:
                ```bash
                gcloud sql instances describe INSTANCE_NAME
                ```
                Check the `ipAddresses` section in the output to confirm the absence of an entry with `type: PRIMARY`.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `ipv4_enabled` attribute within the `ip_configuration` block is set to `false` or omitted (defaults to false if private network is configured):

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-sql-server-instance"
              database_version = "SQLSERVER_2019_STANDARD"
              region           = "us-central1"

              settings {
                tier = "db-custom-2-7680" # Example tier
                ip_configuration {
                  # Ensure private network is configured
                  private_network = "projects/my-project/global/networks/my-vpc"
                  # Set ipv4_enabled to false or omit it
                  ipv4_enabled    = false
                }
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^SQLSERVER_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^SQLSERVER_/).all(
        ipAddresses.all(_.type != "PRIMARY")
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instance-not-publicly-exposed-single
    filters: |
      asset.platform == 'gcp-sql-sqlserver'
    mql: |
      gcp.project.sql.instance.ipAddresses.all(type != "PRIMARY")
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER')).all(
        blocks.where(type == 'settings').all(
          blocks.where(type == 'ip_configuration').all(
            attributes['ipv4_enabled'] == null || attributes['ipv4_enabled'].value == false
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER')).all(
        change.after['settings'].all(
          _['ip_configuration'].all(
            _['ipv4_enabled'] == false
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER')).all(
        values['settings'].all(
          _['ip_configuration'].all(
            _['ipv4_enabled'] == false
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls
    title: Ensure Cloud SQL PostgreSQL connections require SSL/TLS
    impact: 90
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-single
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-state
    docs:
      desc: |
        Requiring SSL/TLS for connections to Cloud SQL PostgreSQL instances encrypts data in transit between the client and the database server. This prevents potential eavesdropping and man-in-the-middle attacks, protecting sensitive data from unauthorized access during transmission.

        It is strongly recommended to configure Cloud SQL instances to enforce SSL/TLS for all incoming connections to maintain data confidentiality and integrity. Note that enabling this setting requires clients to be configured correctly to use SSL/TLS, which might necessitate application updates.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: https://console.cloud.google.com/sql/instances
        2.  Select the name of the PostgreSQL instance you want to audit.
        3.  Select the **Connections** tab.
        4.  Go to the **Security** sub-tab.
        5.  Verify that the checkbox for **Allow only SSL connections** is checked.

        **Using Google Cloud CLI**

        1.  Retrieve the configuration details for the instance:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```
        2.  Inspect the output and locate the `settings.ipConfiguration` section.
        3.  Ensure the value for `sslMode` is set to `ENCRYPTED_ONLY`.

            Example relevant output snippet:
            ```yaml
            settings:
              ipConfiguration:
                sslMode: ENCRYPTED_ONLY
            ```
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page: https://console.cloud.google.com/sql/instances
            2.  Select the name of the target PostgreSQL instance.
            3.  Navigate to the **Connections** tab, then the **Security** sub-tab.
            4.  Check the box labeled **Allow only SSL connections**.
            5.  If it is disabled go to **Security** and check **Allow only SSL connections**
            5.  Select **Save** to apply the change. *Note: This may trigger an instance restart.*

            **Prevention:**

            Always configure new Cloud SQL PostgreSQL instances with the "Allow only SSL connections" option enabled during creation via the Console. Regularly audit instances to ensure compliance.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1.  Enable the SSL Mode to be "ENCRYPTED_ONLY":
                ```bash
                gcloud sql instances patch INSTANCE_NAME --ssl-mode=ENCRYPTED_ONLY
                ```
                *Note: This command may cause the instance to restart.*

            **Prevention:**

            Always configure new Cloud SQL PostgreSQL instances with the `--ssl-mode=ENCRYPTED_ONLY` flag during creation via the CLI. Regularly audit instances to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `ssl_mode` attribute within the `ip_configuration` block is set to `ENCRYPTED_ONLY`:

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  ipv4_enabled = true
                  ssl_mode     = "ENCRYPTED_ONLY"
                }
              }
            }
            ```

            **Prevention:**

            Always configure new Cloud SQL PostgreSQL instances with `ssl_mode = "ENCRYPTED_ONLY"` during creation via Terraform. Regularly audit instances to ensure compliance.
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^POSTGRES_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings.ipConfiguration.sslMode == "ENCRYPTED_ONLY"
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-single
    filters: |
      asset.platform == 'gcp-sql-postgresql'
    mql: |
      gcp.project.sql.instance.settings.ipConfiguration.sslMode == "ENCRYPTED_ONLY"
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && 
        terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')).all(
        blocks.where(type == 'settings').all(
          attributes['ssl_mode'].value == 'ENCRYPTED_ONLY'
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')).all(
        change.after['settings'].all(
          _['ip_configuration'].all(
            _['ssl_mode'] == 'ENCRYPTED_ONLY'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')).all(
        values['settings'].all(
          _['ip_configuration'].all(
            _['ssl_mode'] == 'ENCRYPTED_ONLY'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls
    title: Ensure Cloud SQL for SQL Server connections require SSL/TLS
    impact: 90
    variants:
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-all
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-single
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-state
    docs:
      desc: |
        Requiring SSL/TLS for connections to Cloud SQL for SQL Server instances encrypts data in transit between the client and the database server. This prevents potential eavesdropping and man-in-the-middle attacks, protecting sensitive data from unauthorized access during transmission.

        It is strongly recommended to configure Cloud SQL instances to enforce SSL/TLS for all incoming connections to maintain data confidentiality and integrity. Note that enabling this setting requires clients to be configured correctly to use SSL/TLS, which might necessitate application updates.
      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: https://console.cloud.google.com/sql/instances
        2.  Select the name of the SQL Server instance you want to audit.
        3.  Select the **Connections** tab.
        4.  Go to the **Security** sub-tab.
        5.  Verify that the checkbox for **Allow only SSL connections** is checked.

        **Using Google Cloud CLI**

        1.  Retrieve the configuration details for the instance:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```
        2.  Inspect the output and locate the `settings.ipConfiguration` section.
        3.  Ensure the value for `sslMode` is set to `ENCRYPTED_ONLY`.

            Example relevant output snippet:
            ```yaml
            settings:
              ipConfiguration:
                sslMode: ENCRYPTED_ONLY
            ```
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page: https://console.cloud.google.com/sql/instances
            2.  Select the name of the target SQL Server instance.
            3.  Navigate to the **Connections** tab, then the **Security** sub-tab.
            4.  Check the box labeled **Allow only SSL connections**.
            5.  If it is disabled go to **Security** and check **Allow only SSL connections**
            5.  Select **Save** to apply the change. *Note: This may trigger an instance restart.*

            **Prevention:**

            Always configure new Cloud SQL for SQL Server instances with the "Allow only SSL connections" option enabled during creation via the Console. Regularly audit instances to ensure compliance.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1.  Enable the SSL Mode to be "ENCRYPTED_ONLY":
                ```bash
                gcloud sql instances patch INSTANCE_NAME --ssl-mode=ENCRYPTED_ONLY
                ```
                *Note: This command may cause the instance to restart.*

            **Prevention:**

            Always configure new Cloud SQL for SQL Server instances with the `--ssl-mode=ENCRYPTED_ONLY` flag during creation via the CLI. Regularly audit instances to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `require_ssl` attribute within the `ip_configuration` block is set to `true`:

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-sql-server-instance"
              database_version = "SQLSERVER_2019_STANDARD"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  ipv4_enabled = true
                  ssl_mode     = "ENCRYPTED_ONLY"
                }
              }
            }
            ```

            **Prevention:**

            Always configure new Cloud SQL for SQL Server instances with `ssl_mode = "ENCRYPTED_ONLY"` during creation via Terraform. Regularly audit instances to ensure compliance.
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.any(databaseInstalledVersion == /^SQLSERVER_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^SQLSERVER_/).all(
        settings.ipConfiguration.sslMode == "ENCRYPTED_ONLY"
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-single
    filters: |
      asset.platform == 'gcp-sql-sqlserver'
    mql: |
      gcp.project.sql.instance.settings.ipConfiguration.sslMode == "ENCRYPTED_ONLY"
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && 
        terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER')).all(
        blocks.where(type == 'settings').all(
          attributes['ssl_mode'].value == 'ENCRYPTED_ONLY'
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER')).all(
        change.after['settings'].all(
          _['ip_configuration'].all(
            _['ssl_mode'] == 'ENCRYPTED_ONLY'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER')).all(
        values['settings'].all(
          _['ssl_mode'] == 'ENCRYPTED_ONLY'
        )
      )
  - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible
    title: Ensure That Cloud KMS Cryptokeys Are Not Anonymously or Publicly Accessible
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-all
      - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-single
      - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-terraform-hcl
      - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-terraform-plan
      - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-terraform-state
    docs:
      desc: |
        It is recommended to restrict anonymous and/or public access in the Cloud Key Management Service (KMS) Cryptokeys Identity and Access Management (IAM) policy.

        Granting permissions to `allUsers` or `allAuthenticatedUsers` allows broad access to your cryptokeys. Ensuring that anonymous and/or public access is not permitted helps maintain the confidentiality and integrity of your encrypted data.

        Removing `allUsers` and `allAuthenticatedUsers` from the Cloud KMS Cryptokey IAM policy prevents unauthorized anonymous or public access to your cryptokeys, thereby enhancing the security posture of your encrypted data.

      audit: |
        **Using Google Cloud Console**

        1.  Navigate to the Cloud KMS Keys page: https://console.cloud.google.com/security/kms/keys
        2.  Select a key ring to view its cryptokeys.
        3.  For each cryptokey, click the **Permissions** tab.
        4.  Verify that neither `allUsers` nor `allAuthenticatedUsers` appears in the member list.

        **Using Google Cloud CLI**

        1. List all Cloud KMS `Cryptokeys`:
        ```bash
        gcloud kms keys list --keyring=[key_ring_name] --location=global --format=json | jq '.[].name'
        ```
        2. Ensure the below command's output does not contain `allUsers` or `allAuthenticatedUsers`:
        ```bash
        gcloud kms keys get-iam-policy [key_name] --keyring=[key_ring_name] --location=global --format=json | jq '.bindings[].members[]'
        ```
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1.  Navigate to the Cloud KMS Keys page: https://console.cloud.google.com/security/kms/keys
            2.  Select the key ring containing the target cryptokey.
            3.  Click on the cryptokey name to view its details.
            4.  Navigate to the **Permissions** tab.
            5.  For any binding that includes `allUsers` or `allAuthenticatedUsers`:
                - Click the **Edit** (pencil) icon for that binding.
                - Remove `allUsers` and/or `allAuthenticatedUsers` from the members list.
                - Click **Save** to apply the changes.

            **Prevention:**

            When creating new cryptokeys or modifying IAM policies, ensure that `allUsers` and `allAuthenticatedUsers` are never added as members. Regularly audit cryptokey permissions to ensure compliance.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1. List all Cloud KMS `Cryptokeys`:
            ```bash
            gcloud kms keys list --keyring=[key_ring_name] --location=global --format=json | jq '.[].name'
            ```
            2. Remove IAM policy binding for a KMS key to remove access to `allUsers` and `allAuthenticatedUsers`:
            ```bash
            gcloud kms keys remove-iam-policy-binding [key_name] --keyring=[key_ring_name] --location=global --member='allAuthenticatedUsers' --role='[role]'

            gcloud kms keys remove-iam-policy-binding [key_name] --keyring=[key_ring_name] --location=global --member='allUsers' --role='[role]'
            ```

            **Prevention:**

            When creating new cryptokeys or modifying IAM policies via CLI, ensure that `allUsers` and `allAuthenticatedUsers` are never included in policy bindings. Regularly audit cryptokey permissions to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure that IAM policy resources for KMS crypto keys do not include `allUsers` or `allAuthenticatedUsers` as members:

            ```hcl
            # Good example - specific users/service accounts only
            resource "google_kms_crypto_key_iam_binding" "crypto_key" {
              crypto_key_id = google_kms_crypto_key.key.id
              role          = "roles/cloudkms.cryptoKeyEncrypter"

              members = [
                "user:jane@example.com",
                "serviceAccount:my-service@project.iam.gserviceaccount.com",
              ]
            }

            # Avoid - public access
            resource "google_kms_crypto_key_iam_binding" "crypto_key_bad" {
              crypto_key_id = google_kms_crypto_key.key.id
              role          = "roles/cloudkms.cryptoKeyEncrypter"

              members = [
                "allUsers",                    # Remove this
                "allAuthenticatedUsers",       # Remove this
                "user:jane@example.com",
              ]
            }
            ```

            **Prevention:**

            Always review IAM policies for KMS crypto keys during code reviews. Use Terraform validation rules or policy-as-code tools to prevent public access grants. Regularly audit your Terraform configurations to ensure compliance.
  - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.kms.keyrings.any(cryptokeys.contains(primary.state != "DESTROYED"))
    mql: |
      gcp.project.kms.keyrings.where(cryptokeys.where(primary.state != "DESTROYED")).all(
        cryptokeys.all(
          iamPolicy.all(
            members.none(_ == "allUsers" || _ == "allAuthenticatedUsers")
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-single
    filters: asset.platform == "gcp-kms-keyring"
    mql: |
      gcp.project.kms.keyring.cryptokeys.all(
        iamPolicy.all(
          members.none(_ == "allUsers" || _ == "allAuthenticatedUsers")
        )
      )
  - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl'
      terraform.resources.where( nameLabel.in(['google_kms_crypto_key_iam_policy', 'google_kms_crypto_key_iam_binding','google_kms_crypto_key_iam_member'])) != empty
    mql: |
      terraform.resources.where(nameLabel == 'google_kms_crypto_key_iam_policy' || nameLabel == 'google_kms_crypto_key_iam_binding')
        .all(
          arguments.members == empty || arguments.members.none(_ == 'allUsers' && _ == 'allAuthenticatedUsers')
        )
      terraform.resources.where(nameLabel == 'google_kms_crypto_key_iam_member').all(
        arguments.member != 'allUsers' && arguments.member != 'allAuthenticatedUsers'
      )
  - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-terraform-plan
    filters: |
      asset.platform == 'terraform-plan'
      terraform.plan.resourceChanges.contains(type == 'google_kms_crypto_key_iam_policy') ||
      terraform.plan.resourceChanges.contains(type == 'google_kms_crypto_key_iam_binding') ||
      terraform.plan.resourceChanges.contains(type == 'google_kms_crypto_key_iam_member')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_kms_crypto_key_iam_policy' || type == 'google_kms_crypto_key_iam_binding' || type == 'google_kms_crypto_key_iam_member').all(
        change.after.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
  - uid: mondoo-gcp-security-cloud-kms-cryptokeys-not-publicly-accessible-terraform-state
    filters: |
      asset.platform == 'terraform-state'
      terraform.state.resources.contains(type == 'google_kms_crypto_key_iam_policy') ||
      terraform.state.resources.contains(type == 'google_kms_crypto_key_iam_binding') ||
      terraform.state.resources.contains(type == 'google_kms_crypto_key_iam_member')
    mql: |
      terraform.state.resources.where(type == 'google_kms_crypto_key_iam_policy' || type == 'google_kms_crypto_key_iam_binding' || type == 'google_kms_crypto_key_iam_member')
        .all(values.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers'))
  - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days
    title: Ensure KMS Encryption Keys Are Rotated Within a Period of 90 Days
    impact: 30
    variants:
      - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-all
      - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-single
      - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-terraform-hcl
      - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-terraform-plan
      - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-terraform-state
    docs:
      desc: |
        Google Cloud Key Management Service (KMS) stores cryptographic keys hierarchically with robust access control. Configure a key rotation period and start time to ensure regular updates, enhancing security for data encrypted by these keys. The gcloud CLI requires the next rotation time in ISO or RFC3339 format, and the rotation period as INTEGER[UNIT] (s, m, h, or d). Note that after rotation, the older key version is still required to decrypt data encrypted with it.
      audit: |
        **Using Google Cloud Console**

        1. - Navigate to the Cryptographic Keys section of the Google Cloud Console by visiting: [https://console.cloud.google.com/security/kms](https://console.cloud.google.com/security/kms).

        2. Select each key ring sequentially. Within each key ring, verify that every key's "Next Rotation" is scheduled to occur within 90 days from the current date.

        **Using Google Cloud CLI**

        1. To confirm that a rotation schedule is configured for each key, including both the ROTATION_PERIOD and NEXT_ROTATION_TIME, use the following command:

        ```bash
        gcloud kms keys list --keyring=<KEY_RING> --location=<LOCATION> --format=json'(rotationPeriod)'
        ```

        Ensure the returned values for rotationPeriod and nextRotationTime adhere to the following criteria:

        - `rotationPeriod` must not exceed 129600m (minutes).
        - `rotationPeriod` must not exceed 7776000s (seconds).
        - `rotationPeriod` must not exceed 2160h (hours).
        - `rotationPeriod` must not exceed 90d (days).
        - `nextRotationTime` must be scheduled within 90 days from the current date.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. Access the `Cryptographic Keys` page: [https://console.cloud.google.com/security/kms](https://console.cloud.google.com/security/kms).
            2. Select the desired key ring.
            3. From the list of keys, locate and click the three-dot menu icon on the right side of the specific key.
            4. Choose "Edit rotation period" from the options.
            5. In the pop-up window, set a new rotation period (in days) to be less than 90 days, and specify a "Starting on" date for the rotation to begin.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Update and schedule rotation by `ROTATION_PERIOD` and `NEXT_ROTATION_TIME` for each key:

            ```bash
            gcloud kms keys update KEY_NAME --keyring=KEY_RING --location=LOCATION --next-rotation-time=NEXT_ROTATION_TIME --rotation-period=ROTATION_PERIOD
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            Configure automatic key rotation for your KMS cryptokeys by setting a rotation period of 90 days or less:

            ```hcl
            resource "google_kms_crypto_key" "example" {
              name     = "example-key"
              key_ring = google_kms_key_ring.example.id

              # Rotate every 90 days (maximum)
              rotation_period = "7776000s"  # 90 days in seconds

              lifecycle {
                prevent_destroy = true
              }
            }

            resource "google_kms_key_ring" "example" {
              name     = "example-keyring"
              location = "global"
            }
            ```

            **Prevention:**

            Always configure key rotation periods in your Terraform KMS configurations. Use Terraform validation rules or policy-as-code tools to ensure rotation periods are set to 90 days or less. Regularly audit your Terraform configurations to ensure compliance with key rotation requirements.
  - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled
    title: Ensure That DNSSEC Is Enabled for Cloud DNS
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-all
      - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-single
      - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-terraform-state
    docs:
      desc: |
        Cloud DNS with DNSSEC provides a secure, reliable, and cost-effective domain name system. DNSSEC protects domains from hijacking and man-in-the-middle attacks by cryptographically signing DNS records, ensuring the authenticity of DNS responses. This prevents attackers from redirecting users to malicious sites through fake DNS lookups.
      audit: |
        **Using Google Cloud Console**

        1. Go to `Cloud DNS` by navigating to [https://console.cloud.google.com/net-services/dns/zones](https://console.cloud.google.com/net-services/dns/zones).
        2. For each zone of `Type` `Public`, make sure that `DNSSEC` is set to `On`.

        **Using Google Cloud CLI**

        1. List all Managed Zones in a project:

        ```bash
        gcloud dns managed-zones list
        ```

        2. For each zone of `VISIBILITY` `public`, describe its metadata:

        ```bash
        gcloud dns managed-zones describe ZONE_NAME
        ```

        3. Make sure that `dnssecConfig.state` property is `on`.
      remediation:
        - id: console
          desc: |
            **Using Google Cloud Console**

            1. Go to `Cloud DNS` by navigating to [https://console.cloud.google.com/net-services/dns/zones](https://console.cloud.google.com/net-services/dns/zones).
            2. For each zone of `Type` `Public`, switch `DNSSEC` to `On`.
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            Use the below command to enable `DNSSEC` for Cloud DNS Zone Name:
            ```bash
            gcloud dns managed-zones update ZONE_NAME --dnssec-state on
            ```
        - id: terraform
          desc: |
            **Using Terraform**

            Enable DNSSEC for managed DNS zones by setting the `dnssec_config` block with `state = "on"`:

            ```hcl
            resource "google_dns_managed_zone" "example" {
              name         = "example-zone"
              dns_name     = "example.com."
              description  = "Example managed zone"
              visibility   = "public"

              dnssec_config {
                state = "on"
                default_key_specs {
                  algorithm  = "rsasha256"
                  key_length = 2048
                  key_type   = "keySigning"
                }
                default_key_specs {
                  algorithm  = "rsasha256"
                  key_length = 2048
                  key_type   = "zoneSigning"
                }
              }
            }
            ```

            **Prevention:**

            Always configure DNSSEC for public DNS zones in your Terraform configurations. Use Terraform validation rules or policy-as-code tools to ensure DNSSEC is enabled for all public zones. Regularly audit your Terraform configurations to ensure compliance.
  - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.dns.managedZones.any(visibility == "public")
    mql: |
      publicDnsManagedZones = gcp.project.dns.managedZones.where(visibility == "public")
      publicDnsManagedZones.all(dnssecConfig['state'] == 'on')
  - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-single
    filters: |
      asset.platform == "gcp-dns-managedzone"
      gcp.project.dnsService.managedzone.visibility == "public"
    mql: |
      gcp.dns.managedzone.dnssecConfig['state'] == 'on'
  - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl'
      terraform.resources.contains(nameLabel == 'google_dns_managed_zone')
    mql: |
      terraform.resources.where(nameLabel == 'google_dns_managed_zone').where(arguments['visibility'] == 'public' || arguments['visibility'] == null).all(
        blocks.where(type == 'dnssec_config').any(arguments['state'] == 'on')
      )
  - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan'
      terraform.plan.resourceChanges.contains(type == 'google_dns_managed_zone')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_dns_managed_zone').where(change.after['visibility'] == 'public' || change.after['visibility'] == null).all(
        change.after['dnssec_config'] != empty && change.after['dnssec_config'].any(_['state'] == "on")
      )
  - uid: mondoo-gcp-security-cloud-dns-dnssec-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state'
      terraform.state.resources.contains(type == 'google_dns_managed_zone')
    mql: |
      terraform.state.resources.where(type == 'google_dns_managed_zone').where(values['visibility'] == 'public' || values['visibility'] == empty).all(
        values['dnssec_config'] != empty && values['dnssec_config'].any(_['state'] == "on")
      )
  - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used
    title: Ensure That RSASHA1 Is Not Used for the Key-Signing Key in Cloud DNS DNSSEC
    impact: 30
    variants:
      - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-all
      - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-single
      - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-terraform-hcl
      - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-terraform-plan
      - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-terraform-state
    docs:
      desc: |
        When configuring DNSSEC for a managed zone, choose strong, recommended algorithms for key signing and denial-of-existence. While various DNSSEC algorithms are available, some are better suited for zone signing or transaction security. Note that SHA1 is deprecated by Google and requires a Google Cloud support contract and allowlisting for use. To modify DNSSEC settings on an enabled zone, disable and then re-enable it with the new configuration.
      audit: |
        **Using Google Cloud CLI**

        Ensure the property algorithm for keyType keySigning is not using `RSASHA1`:

        ```bash
        gcloud dns managed-zones describe ZONE_NAME --format="json(dnsName,dnssecConfig.state,dnssecConfig.defaultKeySpecs)"
        ```
      remediation:
        - id: cli
          desc: |
            **Using Google Cloud CLI**

            1. To change DNSSEC settings on an already enabled managed zone, first disable it:

            ```bash
            gcloud dns managed-zones update ZONE_NAME --dnssec-state off
            ```

            2. Then, re-enable it with the desired key-signing and denial-of-existence settings:

            ```bash
            gcloud dns managed-zones update ZONE_NAME --dnssec-state on --ksk-algorithm KSK_ALGORITHM --ksk-key-length KSK_KEY_LENGTH --zsk-algorithm ZSK_ALGORITHM --zsk-key-length ZSK_KEY_LENGTH --denial-of-existence DENIAL_OF_EXISTENCE
            ```

            **Supported algorithm options and key lengths:**

            | Algorithm | KSK Length | ZSK Length |
            |-----------|------------|------------|
            | RSASHA1 | 1024,2048 | 1024,2048 |
            | RSASHA256 | 1024,2048 | 1024,2048 |
            | RSASHA512 | 1024,2048 | 1024,2048 |
            | ECDSAP256SHA256 | 256 | 256 |
            | ECDSAP384SHA384 | 384 | 384 |
        - id: terraform
          desc: |
            **Using Terraform**

            Avoid using RSASHA1 for key-signing keys in your DNSSEC configuration. Use stronger algorithms like RSASHA256, RSASHA512, or ECDSA variants.:

            ```hcl
            resource "google_dns_managed_zone" "example" {
              name         = "example-zone"
              dns_name     = "example.com."
              description  = "Example managed zone"
              visibility   = "public"

              dnssec_config {
                state = "on"
                # Use RSASHA256 instead of RSASHA1 for key-signing
                default_key_specs {
                  algorithm  = "rsasha256"  # Not rsasha1
                  key_length = 2048
                  key_type   = "keySigning"
                }
                default_key_specs {
                  algorithm  = "rsasha256"
                  key_length = 2048
                  key_type   = "zoneSigning"
                }
              }
            }
            ```

            **Prevention:**

            Always use strong cryptographic algorithms in your Terraform DNSSEC configurations. Avoid RSASHA1 and prefer RSASHA256, RSASHA512, or ECDSA algorithms. Use Terraform validation rules to prevent weak algorithms from being deployed.
  - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.dns.managedZones.any(visibility != "private")
    mql: |
      privateDnsManagedZones = gcp.project.dns.managedZones.where(visibility != "private")
      privateDnsManagedZones.all(dnssecConfig['state'] == 'on')
      privateDnsManagedZones.all(dnssecConfig.defaultKeySpecs.where(keyType == 'keySigning').all(algorithm != 'RSASHA1'))
  - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-single
    filters: |
      asset.platform == "gcp-dns-managedzone"
      gcp.project.dnsService.managedzone.visibility != "private"
    mql: |
      gcp.dns.managedzone.dnssecConfig['state'] == 'on'
      gcp.dns.managedzone.dnssecConfig.defaultKeySpecs.where(keyType == 'keySigning').all(algorithm != 'RSASHA1')
  - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl'
      terraform.resources.contains(nameLabel == 'google_dns_managed_zone')
    mql: |
      terraform.resources.where(nameLabel == 'google_dns_managed_zone').where(arguments['visibility'] == 'public' || arguments['visibility'] == null).all(
        blocks.where(type == 'dnssec_config').where(attributes['state'] == 'on').all(
          blocks.where(type == 'default_key_specs').where(attributes['key_type'] == 'keySigning').all(
            attributes['algorithm'] != 'rsasha1'
          )
        )
      )
  - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-terraform-plan
    filters: |
      asset.platform == 'terraform-plan'
      terraform.plan.resourceChanges.contains(type == 'google_dns_managed_zone')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_dns_managed_zone').where(change.after['visibility'] == 'public' || change.after['visibility'] == null).all(
        change.after['dnssec_config'] != empty &&
        change.after['dnssec_config'].where(_['state'] == "on").all(
          _['default_key_specs'].where(_['key_type'] == "keySigning").all(_['algorithm'] != "rsasha1")
        )
      )
  - uid: mondoo-gcp-security-cloud-dns-rsasha1-ksk-not-used-terraform-state
    filters: |
      asset.platform == 'terraform-state'
      terraform.state.resources.contains(type == 'google_dns_managed_zone')
    mql: |
      terraform.state.resources.where(type == 'google_dns_managed_zone').where(values['visibility'] == 'public' || values['visibility'] == empty).all(
        values['dnssec_config'] != empty &&
        values['dnssec_config'].where(_['state'] == "on").all(
          _['default_key_specs'].where(_['key_type'] == "keySigning").all(_['algorithm'] != "rsasha1")
        )
      )
  - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.kms.keyrings.any(cryptokeys.contains(primary.state == "ENABLED"))
    mql: |
      gcp.project.kms.keyrings.where(cryptokeys.where(primary.state == "ENABLED")).all(
        cryptokeys.all(rotationPeriod.seconds <= 7776000)
      )
  - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-single
    filters: asset.platform == "gcp-kms-keyring"
    mql: |
      gcp.project.kms.keyring.cryptokeys.where(primary.state == "ENABLED").all(rotationPeriod.seconds <= 7776000)
  - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl'
      terraform.resources.contains(nameLabel == 'google_kms_crypto_key')
    mql: |
      terraform.resources.where(nameLabel == 'google_kms_crypto_key').all(
        arguments['rotation_period'] != null && arguments['rotation_period'] != empty
      )
  - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-terraform-plan
    filters: |
      asset.platform == 'terraform-plan'
      terraform.plan.resourceChanges.contains(type == 'google_kms_crypto_key')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_kms_crypto_key').all(
        change.after['rotation_period'] != null && change.after['rotation_period'] != empty
      )
  - uid: mondoo-gcp-security-cloud-kms-keys-rotated-90-days-terraform-state
    filters: |
      asset.platform == 'terraform-state'
      terraform.state.resources.contains(type == 'google_kms_crypto_key')
    mql: |
      terraform.state.resources.where(type == 'google_kms_crypto_key').all(
        values['rotation_period'] != null && values['rotation_period'] != empty
      )
