# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-gitlab-security
    name: Mondoo GitLab Security
    version: 1.5.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: gitlab
    require:
      - provider: gitlab
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |
        The Mondoo GitLab Security policy identifies misconfigurations that could expose your GitLab groups and projects to supply chain attacks, unauthorized code changes, and data breaches. Improperly secured GitLab environments can allow attackers to access private repositories, inject malicious code, or exfiltrate sensitive data.

        This policy validates critical security controls including group and project visibility settings, two-factor authentication requirements, and access control configurations.

        ### Prerequisites

        Remote scans of GitLab require a [personal access token](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html) with access to the group and projects you plan to scan.

        ### Scan a GitLab group and projects

        To scan a GitLab group, set your personal access token and run a scan:

        ```bash
        export GITLAB_TOKEN=<your personal access token>
        cnspec scan gitlab --group <group_name>
        ```

        ### Scan a single GitLab project

        To scan a GitLab project, set your personal access token and run a scan:

        ```bash
        export GITLAB_TOKEN=<your personal access token>
        cnspec scan gitlab --group <group_name> --project <project_name>
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Group
        filters: asset.platform == "gitlab-group"
        checks:
          - uid: mondoo-gitlab-security-private-group
          - uid: mondoo-gitlab-security-private-projects
          - uid: mondoo-gitlab-security-require-two-factor
      - title: Project
        filters: asset.platform == "gitlab-project"
        checks:
          - uid: mondoo-gitlab-security-private-project
      - title: Merge Request Security
        filters: asset.platform == "gitlab-project"
        checks:
          - uid: mondoo-gitlab-security-approvals-required
          - uid: mondoo-gitlab-security-no-author-approval
          - uid: mondoo-gitlab-security-reset-approvals-on-push
          - uid: mondoo-gitlab-security-no-committer-approval
          - uid: mondoo-gitlab-security-pipeline-must-succeed
      - title: Branch Protection
        filters: asset.platform == "gitlab-project"
        checks:
          - uid: mondoo-gitlab-security-no-force-push-default-branch
    scoring_system: highest impact
queries:
  - uid: mondoo-gitlab-security-private-group
    title: Ensure the group is private
    mql: gitlab.group.visibility != "public"
    docs:
      desc: |
        This check verifies that the GitLab group visibility is set to private or internal, not public.

        **Why this matters**

        Public GitLab groups expose all contained projects and their contents to anyone on the internet:

          - **Source code exposure**: Public groups allow anyone to clone repositories and view proprietary source code.
          - **Secret leakage**: Hardcoded credentials, API keys, or configuration files may be exposed in public repositories.
          - **Supply chain attacks**: Public visibility enables attackers to analyze code for vulnerabilities before they're patched.
          - **Intellectual property theft**: Competitors or malicious actors can access and copy proprietary algorithms and business logic.
          - **Reconnaissance**: Public groups provide attackers with information about your technology stack and infrastructure.

        Set group visibility to private unless there is an explicit business requirement for public access, and regularly audit group visibility settings.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            To make the visibility of a GitLab group private:

            1. In GitLab, navigate to your group.
            2. Go to **Settings** > **General**.
            3. Expand the **Visibility, project features, permissions** section.
            4. Under **Visibility level**, select **Private**.
            5. Click **Save changes**.

            For more details, see [Change group visibility](https://docs.gitlab.com/ee/user/public_access.html#change-group-visibility).
        - id: terraform
          desc: |
            **Using Terraform**

            To make the visibility of a GitLab group private using Terraform, you can use the following configuration:

            ```hcl
            resource "gitlab_group" "example" {
              name        = "example"
              path        = "example"
              visibility  = "private"
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/group).
  - uid: mondoo-gitlab-security-require-two-factor
    title: Ensure two-factor authentication is required
    mql: gitlab.group.requireTwoFactorAuthentication == true
    docs:
      desc: |
        This check verifies that two-factor authentication is required for all members of the GitLab group.

        **Why this matters**

        GitLab accounts are high-value targets for attackers seeking to compromise software supply chains:

          - **Source code tampering**: Compromised accounts can push malicious code that gets deployed to production.
          - **Credential theft protection**: Even if passwords are phished or leaked, attackers cannot access accounts without the second factor.
          - **CI/CD pipeline access**: Attackers with GitLab access can modify pipelines to inject malicious build steps.
          - **Secrets and variables**: GitLab projects often contain CI/CD variables with deployment credentials and API keys.
          - **Supply chain attacks**: Software supply chain compromises often begin with compromised developer accounts.

        Require 2FA at the group level to ensure all members are protected, and set a reasonable grace period for compliance.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            To require two-factor authentication for all users in a GitLab group:

            1. In GitLab, navigate to your group.
            2. Go to **Settings** > **General**.
            3. Expand the **Permissions and group features** section.
            4. Under **Require two-factor authentication**, check the box.
            5. Click **Save changes**.

            For more details, see [Enforce two-factor authentication](https://docs.gitlab.com/ee/security/two_factor_authentication.html).
        - id: terraform
          desc: |
            **Using Terraform**

            To require two-factor authentication for all users in a GitLab group using Terraform, you can use the following configuration:

            ```hcl
            resource "gitlab_group" "example" {
              name        = "example"
              path        = "example"
              require_two_factor_authentication = true
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/group).
  - uid: mondoo-gitlab-security-private-projects
    title: Ensure all projects are private
    mql: gitlab.group.projects.none(visibility == "public")
    docs:
      desc: |
        This check verifies that no projects within the GitLab group have public visibility.

        **Why this matters**

        Even when a group is private, individual projects can be set to public, exposing their contents:

          - **Inconsistent security**: Public projects in an otherwise private group create gaps in access control.
          - **Accidental exposure**: Developers may inadvertently set projects to public without understanding the implications.
          - **Data leakage**: Public projects expose code, issues, merge requests, and wiki content to the internet.
          - **Configuration drift**: Over time, project visibility settings may deviate from intended security posture.
          - **Compliance violations**: Regulatory requirements may prohibit public exposure of certain types of code or data.

        Enforce private visibility as the default for new projects and regularly audit all projects for visibility settings.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            This check fails when any existing project in the group has public visibility. You must change each public project to private individually.

            **Step 1: Change existing public projects to private**

            For each public project in the group:

            1. In GitLab, navigate to the project.
            2. Go to **Settings** > **General**.
            3. Expand the **Visibility, project features, permissions** section.
            4. Under **Project visibility**, select **Private**.
            5. Click **Save changes**.

            **Step 2: Set the default visibility for new projects**

            To prevent future projects from being created as public:

            1. In GitLab, navigate to your group.
            2. Go to **Settings** > **General**.
            3. Expand the **Visibility, project features, permissions** section.
            4. Under **Default project visibility**, select **Private**.
            5. Click **Save changes**.

            For more details, see [Change project visibility](https://docs.gitlab.com/ee/user/public_access.html#change-project-visibility).
        - id: terraform
          desc: |
            **Using Terraform**

            This check fails when any existing project has public visibility. You must set each project's visibility to private.

            To make individual projects private:

            ```hcl
            resource "gitlab_project" "example" {
              name         = "example"
              path         = "example"
              visibility   = "private"
              namespace_id = gitlab_group.example.id
            }
            ```

            To set the default visibility for new projects in a group:

            ```hcl
            resource "gitlab_group" "example" {
              name                      = "example"
              path                      = "example"
              default_branch_protection = 2
              project_creation_level    = "maintainer"
              subgroup_creation_level   = "maintainer"
              visibility_level          = "private"
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project).
  - uid: mondoo-gitlab-security-private-project
    title: Ensure the project is private
    mql: gitlab.project.visibility != "public"
    docs:
      desc: |
        This check verifies that the individual GitLab project visibility is set to private or internal, not public.

        **Why this matters**

        Public project visibility exposes the entire repository contents and metadata to anyone on the internet:

          - **Complete code exposure**: All source code, including historical commits, is accessible to anyone.
          - **Issue and MR visibility**: Bug reports, security issues, and code review discussions are publicly readable.
          - **CI/CD job logs**: Build and deployment logs may contain sensitive information or credentials.
          - **Dependency information**: Lock files and manifests reveal your technology stack and potential vulnerabilities.
          - **Contributor information**: Git history exposes developer names, emails, and work patterns.

        Set project visibility to private unless there is a documented business requirement for public access.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            To make the visibility of an individual GitLab project private:

            1. In GitLab, navigate to your project.
            2. Go to **Settings** > **General**.
            3. Expand the **Visibility, project features, permissions** section.
            4. Under **Project visibility**, select **Private**.
            5. Click **Save changes**.

            For more details, see [Change project visibility](https://docs.gitlab.com/ee/user/public_access.html#change-project-visibility).
        - id: terraform
          desc: |
            **Using Terraform**

            To make an individual GitLab project private using Terraform, you can use the following configuration:

            ```hcl
            resource "gitlab_project" "example" {
              name         = "example"
              path         = "example"
              visibility   = "private"
              namespace_id = gitlab_group.example.id
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project).
  - uid: mondoo-gitlab-security-approvals-required
    title: Ensure merge request approvals are required
    impact: 90
    mql: |
      gitlab.project.approvalSettings.approvalsBeforeMerge >= 1
    docs:
      desc: |
        This check ensures that at least one approval is required before a merge request can be merged. Without required approvals, any developer with merge access can push code changes directly without peer review.

        **Why this matters**

        Merge request approvals are a fundamental code review control:
          •  Without required approvals, a single compromised account can push malicious code directly to production branches.
          •  Code review catches bugs, security vulnerabilities, and logic errors before they reach production.
          •  Required approvals create an audit trail of who reviewed and approved each change.
          •  Many compliance frameworks (SOC 2, ISO 27001) require separation of duties for code changes.

        Risk mitigation:
          •  Require at least one approval on all projects.
          •  For critical projects, consider requiring two or more approvals.
          •  Combine with protected branches to enforce approval requirements.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            1. Navigate to your project.
            2. Go to **Settings** > **Merge requests**.
            3. Under **Merge request approvals**, set **Approvals required** to at least 1.
            4. Click **Save changes**.

            For more details, see [Merge request approval rules](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/rules.html).
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "gitlab_project_level_mr_approvals" "example" {
              project = gitlab_project.example.id
            }

            resource "gitlab_project_approval_rule" "example" {
              project            = gitlab_project.example.id
              name               = "default"
              approvals_required = 1
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project_level_mr_approvals).
  - uid: mondoo-gitlab-security-no-author-approval
    title: Ensure merge request authors cannot approve their own requests
    impact: 90
    mql: |
      gitlab.project.approvalSettings.mergeRequestsAuthorApproval == false
    docs:
      desc: |
        This check ensures that merge request authors cannot approve their own merge requests. Allowing self-approval defeats the purpose of code review and eliminates the separation of duties control.

        **Why this matters**

        Self-approval of merge requests undermines code review integrity:
          •  A compromised developer account can both create and approve malicious changes.
          •  Self-approval eliminates the independent verification of code changes.
          •  Regulatory and compliance frameworks require separation of duties between code authors and reviewers.
          •  Supply chain attacks often exploit the ability to self-approve changes.

        Risk mitigation:
          •  Disable author approval for all projects.
          •  Combine with required approvals to ensure independent review.
          •  Monitor merge request activity for unusual approval patterns.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            1. Navigate to your project.
            2. Go to **Settings** > **Merge requests**.
            3. Under **Merge request approvals**, uncheck **Allow author approval**.
            4. Click **Save changes**.

            For more details, see [Merge request approval settings](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/settings.html).
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "gitlab_project_level_mr_approvals" "example" {
              project                        = gitlab_project.example.id
              merge_requests_author_approval  = false
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project_level_mr_approvals).
  - uid: mondoo-gitlab-security-reset-approvals-on-push
    title: Ensure approvals are reset when new commits are pushed
    impact: 80
    mql: |
      gitlab.project.approvalSettings.resetApprovalsOnPush == true
    docs:
      desc: |
        This check ensures that merge request approvals are reset when new commits are pushed to the source branch. Without this setting, a developer could get a merge request approved and then add unapproved changes before merging.

        **Why this matters**

        Stale approvals on modified merge requests create a security gap:
          •  An attacker can get a benign change approved, then add malicious code before merging.
          •  Reviewers may not notice additional commits pushed after their approval.
          •  This bypasses the intent of code review by allowing unapproved code to be merged.
          •  Compliance requirements for code review are not met if approved code is modified post-approval.

        Risk mitigation:
          •  Enable reset approvals on push for all projects.
          •  Combine with required approvals and branch protection rules.
          •  Educate developers to re-review merge requests after new commits are pushed.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            1. Navigate to your project.
            2. Go to **Settings** > **Merge requests**.
            3. Under **Merge request approvals**, check **Remove all approvals when commits are added to the source branch**.
            4. Click **Save changes**.

            For more details, see [Merge request approval settings](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/settings.html).
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "gitlab_project_level_mr_approvals" "example" {
              project                  = gitlab_project.example.id
              reset_approvals_on_push  = true
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project_level_mr_approvals).
  - uid: mondoo-gitlab-security-no-committer-approval
    title: Ensure committers cannot approve merge requests they contributed to
    impact: 80
    mql: |
      gitlab.project.approvalSettings.mergeRequestsDisableCommittersApproval == true
    docs:
      desc: |
        This check ensures that users who have committed to a merge request cannot also approve it. This enforces separation between contributors and reviewers for each change.

        **Why this matters**

        Allowing committers to approve their own contributions weakens code review:
          •  A developer who contributed code to a merge request has a conflict of interest when reviewing it.
          •  Committer approval allows a single person to both write and approve code in collaboration scenarios.
          •  This setting closes a gap where multiple contributors to a branch could approve each other's changes without independent review.
          •  Strengthens the audit trail by ensuring approvals come from independent reviewers.

        Risk mitigation:
          •  Disable committer approval for all projects.
          •  Combine with author approval restrictions for comprehensive separation of duties.
          •  Use code owner approvals for additional review requirements on critical paths.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            1. Navigate to your project.
            2. Go to **Settings** > **Merge requests**.
            3. Under **Merge request approvals**, check **Prevent approvals by users who add commits**.
            4. Click **Save changes**.

            For more details, see [Merge request approval settings](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/settings.html).
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "gitlab_project_level_mr_approvals" "example" {
              project                                     = gitlab_project.example.id
              merge_requests_disable_committers_approval   = true
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project_level_mr_approvals).
  - uid: mondoo-gitlab-security-no-force-push-default-branch
    title: Ensure force push is disabled on the default branch
    impact: 90
    mql: |
      gitlab.project.protectedBranches.where(defaultBranch == true).all(allowForcePush == false)
    docs:
      desc: |
        This check ensures that force push is disabled on the default (protected) branch. Force pushing allows rewriting Git history, which can be used to remove audit trails, overwrite security fixes, or inject malicious code.

        **Why this matters**

        Force push to the default branch is a high-severity risk:
          •  An attacker can rewrite Git history to inject malicious code that appears to have always been present.
          •  Force pushing can remove commits that contain security fixes or audit trails.
          •  History rewriting makes incident investigation and forensic analysis extremely difficult.
          •  Accidental force pushes can cause data loss and disrupt development workflows.

        Risk mitigation:
          •  Disable force push on all protected branches, especially the default branch.
          •  Use branch protection rules to enforce this at the project level.
          •  Monitor for any changes to branch protection settings.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            1. Navigate to your project.
            2. Go to **Settings** > **Repository**.
            3. Expand the **Protected branches** section.
            4. For the default branch, ensure **Allowed to force push** is disabled.
            5. Click **Protect** or **Save changes**.

            For more details, see [Protected branches](https://docs.gitlab.com/ee/user/project/protected_branches.html).
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "gitlab_branch_protection" "default" {
              project            = gitlab_project.example.id
              branch             = "main"
              allow_force_push   = false
              push_access_level  = "maintainer"
              merge_access_level = "maintainer"
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/branch_protection).
  - uid: mondoo-gitlab-security-pipeline-must-succeed
    title: Ensure pipeline must succeed before merging
    impact: 80
    mql: |
      gitlab.project.onlyAllowMergeIfPipelineSucceeds == true
    docs:
      desc: |
        This check ensures that merge requests can only be merged when the CI/CD pipeline succeeds. Without this requirement, code that fails tests, security scans, or other automated checks can be merged into protected branches.

        **Why this matters**

        Bypassing CI/CD pipeline requirements undermines automated security controls:
          •  Security scanning tools (SAST, DAST, dependency scanning) in the pipeline are bypassed.
          •  Failed tests may indicate bugs or regressions that reach production.
          •  Compliance checks and policy validations in the pipeline are skipped.
          •  Attackers can merge malicious code that would otherwise be caught by automated checks.

        Risk mitigation:
          •  Require pipeline success on all projects with CI/CD pipelines.
          •  Include security scanning jobs in your pipeline configuration.
          •  Combine with the "don't allow merge on skipped pipeline" setting.
          •  Monitor for projects that have this setting disabled.
      remediation:
        - id: gitlab
          desc: |
            **Using GitLab UI**

            1. Navigate to your project.
            2. Go to **Settings** > **Merge requests**.
            3. Under **Merge checks**, check **Pipelines must succeed**.
            4. Click **Save changes**.

            For more details, see [Merge request checks](https://docs.gitlab.com/ee/user/project/merge_requests/merge_when_pipeline_succeeds.html).
        - id: terraform
          desc: |
            **Using Terraform**

            ```hcl
            resource "gitlab_project" "example" {
              name                                  = "example"
              only_allow_merge_if_pipeline_succeeds = true
            }
            ```

            For more details, see the Terraform [GitLab Provider](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project).
