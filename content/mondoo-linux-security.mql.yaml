# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-linux-security
    name: Mondoo Linux Security
    version: 2.5.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: linux
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |-
        The Mondoo Linux Security policy provides guidance for establishing a secure baseline configuration for Linux systems running on x64 platforms.

        This policy includes queries to help harden Linux systems by:
          - Identifying problematic services that may be running
          - Identifying loose permissions on sensitive system configuration files
          - Ensuring logging and auditing services are properly configured and running
          - Hardening SSH configurations
          - Ensure users and groups are securely configured
          - Identifying misconfigured Kernel networking configurations

        This policy has been developed for Red Hat (RHEL), Debian, Ubuntu, and SUSE (SLES) derivative distributions running on x64 architectures.
        Some queries may be skipped depending on your particular distribution, installation type, or underlying infrastructure.
        The overall guidance within this policy broadly assumes that operations are being performed as the root user.
        Operations performed using sudo instead of the root user may produce unexpected results or fail to make the intended changes to the system.
        Non-root users may not be able to access certain areas of the system, especially after remediation has been performed. It is advisable to verify
        root users path integrity and the integrity of any programs being run prior to execution of commands and scripts included in this benchmark.

        ## Local scan

        Local scan refer to scans of files and operating systems where cnspec is installed.

        To scan the `localhost` against this policy:

        ```bash
        cnspec scan local
        ```

        ## Remote scan

        Remote scans use cnspec providers to retrieve on-demand scan results without having to install any agents.

        ### Prerequisites

        Remote scans of Linux hosts requires authentication such as SSH keys.

        ### Scan a remote Linux host (SSH authentication)

        ```bash
        cnspec scan ssh <user>@<IP_ADDRESS> -i /path/to/ssh_key
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Core
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-window-system-is-not-installed
          - uid: mondoo-linux-security-address-space-layout-randomization-aslr-is-enabled
          - uid: mondoo-linux-security-aide-is-installed
          - uid: mondoo-linux-security-core-dumps-are-restricted
          - uid: mondoo-linux-security-filesystem-integrity-is-regularly-checked
          - uid: mondoo-linux-security-mail-transfer-agent-is-configured-for-local-only-mode
          - uid: mondoo-linux-security-prelink-is-disabled
      - title: Network Stack
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-packet-redirect-sending-is-disabled
          - uid: mondoo-linux-security-reverse-path-filtering-is-enabled
          - uid: mondoo-linux-security-secure-icmp-redirects-are-not-accepted
          - uid: mondoo-linux-security-source-routed-packets-are-not-accepted
          - uid: mondoo-linux-security-suspicious-packets-are-logged
          - uid: mondoo-linux-security-tcp-syn-cookies-is-enabled
          - uid: mondoo-linux-security-icmp-redirects-are-not-accepted
          - uid: mondoo-linux-security-ip-forwarding-is-disabled
          - uid: mondoo-linux-security-ipv6-router-advertisements-are-not-accepted
          - uid: mondoo-linux-security-bogus-icmp-responses-are-ignored
          - uid: mondoo-linux-security-broadcast-icmp-requests-are-ignored
      - title: Sensitive Files
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-permissions-on-etcgroup--are-configured
          - uid: mondoo-linux-security-permissions-on-etcgroup-are-configured
          - uid: mondoo-linux-security-permissions-on-etcgshadow--are-configured
          - uid: mondoo-linux-security-permissions-on-etcgshadow-are-configured
          - uid: mondoo-linux-security-permissions-on-etcpasswd--are-configured
          - uid: mondoo-linux-security-permissions-on-etcpasswd-are-configured
          - uid: mondoo-linux-security-permissions-on-etcshadow--are-configured
          - uid: mondoo-linux-security-permissions-on-etcshadow-are-configured
      - title: Sensitive Services
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-avahi-server-is-not-enabled
          - uid: mondoo-linux-security-dhcp-server-is-not-enabled
          - uid: mondoo-linux-security-dns-server-is-not-enabled
          - uid: mondoo-linux-security-ftp-server-is-not-enabled
          - uid: mondoo-linux-security-http-proxy-server-is-not-enabled
          - uid: mondoo-linux-security-http-server-is-not-enabled
          - uid: mondoo-linux-security-imap-and-pop3-server-is-not-enabled
          - uid: mondoo-linux-security-ldap-server-is-not-enabled
          - uid: mondoo-linux-security-nfs-and-rpc-are-not-enabled
          - uid: mondoo-linux-security-nis-server-is-not-enabled
          - uid: mondoo-linux-security-rsh-server-is-not-enabled
          - uid: mondoo-linux-security-rsync-service-is-not-enabled
          - uid: mondoo-linux-security-samba-is-not-enabled
          - uid: mondoo-linux-security-snmp-server-is-not-enabled
          - uid: mondoo-linux-security-talk-server-is-not-enabled
          - uid: mondoo-linux-security-telnet-server-is-not-enabled
          - uid: mondoo-linux-security-tftp-server-is-not-enabled
          - uid: mondoo-linux-security-cups-is-not-enabled
      - title: SSH Server Configuration
        filters: |
          asset.family.contains('linux')
          package('openssh-server').installed
        checks:
          - uid: mondoo-linux-security-only-strong-ciphers-are-used
          - uid: mondoo-linux-security-only-strong-kex-algorithms-are-used
          - uid: mondoo-linux-security-only-strong-mac-algorithms-are-used
          - uid: mondoo-linux-security-permissions-on-etcsshsshd-config-are-configured
          - uid: mondoo-linux-security-permissions-on-ssh-private-host-key-files-are-configured
          - uid: mondoo-linux-security-permissions-on-ssh-public-host-key-files-are-configured
          - uid: mondoo-linux-security-ssh-access-is-limited
          - uid: mondoo-linux-security-ssh-hostbasedauthentication-is-disabled
          - uid: mondoo-linux-security-ssh-idle-timeout-interval-is-configured
          - uid: mondoo-linux-security-ssh-ignorerhosts-is-enabled
          - uid: mondoo-linux-security-ssh-logingracetime-is-set-to-one-minute-or-less
          - uid: mondoo-linux-security-ssh-loglevel-is-appropriate
          - uid: mondoo-linux-security-ssh-maxauthtries-is-set-to-4-or-less
          - uid: mondoo-linux-security-ssh-permitemptypasswords-is-disabled
          - uid: mondoo-linux-security-ssh-permituserenvironment-is-disabled
          - uid: mondoo-linux-security-ssh-protocol-is-set-to-2
          - uid: mondoo-linux-security-ssh-root-login-is-disabled
          - uid: mondoo-linux-security-ssh-warning-banner-is-configured
          - uid: mondoo-linux-security-ssh-x11-forwarding-is-disabled
      - title: Logging
        filters: |
          asset.family.contains('linux')
          asset.kind != "container-image"
        checks:
          - uid: mondoo-linux-security-audit-log-storage-size-is-configured
          - uid: mondoo-linux-security-audit-logs-are-not-automatically-deleted
          - uid: mondoo-linux-security-auditd-is-installed-and-running
          - uid: mondoo-linux-security-auditing-for-processes-that-start-prior-to-auditd-is-enabled
          - uid: mondoo-linux-security-changes-to-system-administration-scope-sudoers-is-collected
          - uid: mondoo-linux-security-discretionary-access-control-permission-modification-events-are-collected
          - uid: mondoo-linux-security-events-that-modify-date-and-time-information-are-collected
          - uid: mondoo-linux-security-events-that-modify-the-systems-mandatory-access-controls-are-collected
          - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected
          - uid: mondoo-linux-security-events-that-modify-usergroup-information-are-collected
          - uid: mondoo-linux-security-file-deletion-events-by-users-are-collected
          - uid: mondoo-linux-security-journald-is-configured-to-compress-large-log-files
          - uid: mondoo-linux-security-journald-is-configured-to-send-logs-to-rsyslog
          - uid: mondoo-linux-security-journald-is-configured-to-write-logfiles-to-persistent-disk
          - uid: mondoo-linux-security-kernel-module-loading-and-unloading-is-collected
          - uid: mondoo-linux-security-login-and-logout-events-are-collected
          - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
          - uid: mondoo-linux-security-rsyslog-default-file-permissions-configured
          - uid: mondoo-linux-security-rsyslog-is-installed-and-enabled
          - uid: mondoo-linux-security-session-initiation-information-is-collected
          - uid: mondoo-linux-security-successful-file-system-mounts-are-collected
          - uid: mondoo-linux-security-sudo-logging-is-enabled
          - uid: mondoo-linux-security-system-administrator-actions-sudolog-are-collected
          - uid: mondoo-linux-security-system-is-disabled-when-audit-logs-are-full
          - uid: mondoo-linux-security-the-audit-configuration-is-immutable
          - uid: mondoo-linux-security-unsuccessful-unauthorized-file-access-attempts-are-collected
      - title: Users and groups
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-access-to-the-su-command-is-restricted
          - uid: mondoo-linux-security-default-group-for-the-root-account-is-gid-0
          - uid: mondoo-linux-security-each-user-member-of-a-group
          - uid: mondoo-linux-security-gid-in-passwd-exists-in-group
          - uid: mondoo-linux-security-no-duplicate-gids-exist
          - uid: mondoo-linux-security-no-duplicate-group-names-exist
          - uid: mondoo-linux-security-no-duplicate-uids-exist
          - uid: mondoo-linux-security-no-duplicate-user-names-exist
          - uid: mondoo-linux-security-root-group-is-empty
          - uid: mondoo-linux-security-shadow-group-is-empty
          - uid: mondoo-linux-security-system-accounts-are-non-login
          - uid: mondoo-linux-security-uid-min-is-set-to-1000
    scoring_system: highest impact
queries:
  - uid: mondoo-linux-security-aide-is-installed
    title: Ensure Advanced Intrusion Detection Environment (AIDE) is installed
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      package("aide").installed
    docs:
      desc: |
        This check verifies that the Advanced Intrusion Detection Environment (AIDE) is installed on a Linux system. AIDE functions as a file integrity checker that helps detect unauthorized changes to critical system files and configurations.

        **Why this matters**

        AIDE creates a database of cryptographic checksums for important system files and directories. Once initialized, AIDE can be used to scan the system and compare the current state of files against the known-good baseline. This process helps detect file tampering, rootkit installation, or configuration drift that may indicate a security breach.

        Without a host-based file integrity monitoring (FIM) solution like AIDE, administrators may not be aware of changes to critical files made by malicious actors or unintended actions by privileged users. This lack of visibility undermines incident response, auditability, and system trustworthiness.

        Installing AIDE contributes to the overall integrity assurance of a Linux system and supports compliance with standards such as:
          - PCI-DSS Requirement 11.5
          - NIST 800-53 (SI-7: Software, Firmware, and Information Integrity)

        Ensuring AIDE is installed lays the foundation for host-based file integrity monitoring, which is a critical part of a defense-in-depth strategy for detecting intrusions and preserving system integrity.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to install `aide`:

            ### RHEL/Fedora/Amazon Linux and derivatives

            ```bash
            yum install aide
            ```

            ### Debian/Ubuntu and derivatives

            ```bash
            apt-get install aide
            ```

            ### SLES and openSUSE

            ```bash
            zypper install aide
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to install `aide`:

            ```yaml
            ---
            - name: Install AIDE on Linux systems
              hosts: all
              become: true

              tasks:
                - name: Ensure AIDE is installed
                  ansible.builtin.package:
                    name: aide
                    state: present
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to install AIDE. It will auto-detect the package manager and install AIDE if not already installed.

            ```bash
            #!/bin/bash
            set -e

            if command -v yum >/dev/null 2>&1; then
              echo "Detected yum-based system. Installing aide..."
              yum install -y aide
            elif command -v dnf >/dev/null 2>&1; then
              echo "Detected dnf-based system. Installing aide..."
              dnf install -y aide
            elif command -v apt-get >/dev/null 2>&1; then
              echo "Detected apt-based system. Installing aide..."
              apt-get update
              apt-get install -y aide
            elif command -v zypper >/dev/null 2>&1; then
              echo "Detected zypper-based system. Installing aide..."
              zypper install -y aide
            else
              echo "No supported package manager found. Please install AIDE manually."
              exit 1
            fi

            echo "AIDE installation complete."
            ```
  - uid: mondoo-linux-security-filesystem-integrity-is-regularly-checked
    title: Ensure filesystem integrity is regularly checked using AIDE
    impact: 50
    filters: |
      asset.kind != "container-image"
    mql: |
      file("/etc/default/aide").exists && ["/etc/default/aide"].where(file(_).exists).all(parse.ini(_).params["CRON_DAILY_RUN"] == "yes") ||
      command("crontab -u root -l | grep aide").stdout.lines.where(/^[^#]/).any(_.contains("aide --check")) ||
      command("crontab -u root -l | grep aide").stdout.lines.where(/^[^#]/).any(_.contains("aide.conf --check")) ||
      service('aidecheck').enabled
    docs:
      desc: |
        This check verifies that AIDE (Advanced Intrusion Detection Environment) is actively used to perform regular integrity scans of the filesystem. It ensures that an AIDE database has been initialized and that periodic checks are scheduled and executed.

        **Why this matters**

        Installing AIDE alone is not sufficient to protect a system from unauthorized changes. To be effective, AIDE must be routinely run to compare the current system state against its known-good baseline. Regular execution of these checks helps detect file tampering, unauthorized modifications, and early signs of compromise—especially in sensitive directories like /etc, /bin, and /sbin.

        If AIDE is not executed on a regular basis:
          - Integrity violations may go undetected, exposing the system to persistent threats such as rootkits or malware.
          - Audit logs and incident response efforts may be incomplete due to a lack of timely data.
          - Organizations may fail to meet compliance requirements that mandate proactive monitoring of system integrity.
      remediation:
        - id: cli
          desc: |
            **Using the CLI to setup Cron:**

            1. Run this command to initialize the AIDE database:

                ```bash
                aide --init
                ```

            2. Edit the root crontab:

                ```bash
                crontab -u root -e
                ```

                Add the following line to the crontab:

                ```
                0 5 * * * /usr/sbin/aide --check
                ```

            **Using the CLI to setup systemd:**

            1. Run this command to initialize the AIDE database:

                ```bash
                aide --init
                ```

            2. Create the systemd service by creating the file `/etc/systemd/system/aidecheck.service` and adding the following lines:

                ```ini
                [Unit]
                Description=Aide Check

                [Service]
                Type=simple
                ExecStart=/usr/sbin/aide --check

                [Install]
                WantedBy=multi-user.target
                ```

            3. Create the systemd timer by creating or editing the file `/etc/systemd/system/aidecheck.timer` and add the following lines:

                ```ini
                [Unit]
                Description=Aide check every day at 5AM

                [Timer]
                OnCalendar=*-*-* 05:00:00
                Unit=aidecheck.service

                [Install]
                WantedBy=multi-user.target
                ```

            4. Configure the service and timer to run:

                ```bash
                chown root:root /etc/systemd/system/aidecheck.*
                chmod 0644 /etc/systemd/system/aidecheck.*

                systemctl daemon-reload

                systemctl enable aidecheck.service
                systemctl --now enable aidecheck.timer
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to run AIDE using a systemd timer:

            ```yaml
            ---
            - name: Configure daily AIDE check using systemd timer
              hosts: all
              become: true

              tasks:
                - name: Create systemd service unit for AIDE check
                  copy:
                    dest: /etc/systemd/system/aidecheck.service
                    owner: root
                    group: root
                    mode: '0644'
                    content: |
                      [Unit]
                      Description=Aide Check

                      [Service]
                      Type=simple
                      ExecStart=/usr/sbin/aide --check

                      [Install]
                      WantedBy=multi-user.target

                - name: Create systemd timer unit for daily AIDE check at 5AM
                  copy:
                    dest: /etc/systemd/system/aidecheck.timer
                    owner: root
                    group: root
                    mode: '0644'
                    content: |
                      [Unit]
                      Description=Aide check every day at 5AM

                      [Timer]
                      OnCalendar=*-*-* 05:00:00
                      Unit=aidecheck.service

                      [Install]
                      WantedBy=multi-user.target

                - name: Reload systemd daemon to recognize new units
                  command: systemctl daemon-reexec

                - name: Enable aidecheck.service (not started, only enabled)
                  systemd:
                    name: aidecheck.service
                    enabled: true

                - name: Enable and start aidecheck.timer
                  systemd:
                    name: aidecheck.timer
                    enabled: true
                    state: started
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to configure a daily AIDE check. It will auto-detect the package manager, install AIDE if not already installed, initialize the database, and set up a cron job for daily checks at 5AM.

            ```bash
            #!/bin/bash
            set -e

            # Install AIDE if not present
            if ! command -v aide >/dev/null 2>&1; then
              if command -v yum >/dev/null 2>&1; then
                echo "Detected yum-based system. Installing aide..."
                yum install -y aide
              elif command -v dnf >/dev/null 2>&1; then
                echo "Detected dnf-based system. Installing aide..."
                dnf install -y aide
              elif command -v apt-get >/dev/null 2>&1; then
                echo "Detected apt-based system. Installing aide..."
                apt-get update
                apt-get install -y aide
              elif command -v zypper >/dev/null 2>&1; then
                echo "Detected zypper-based system. Installing aide..."
                zypper install -y aide
              else
                echo "No supported package manager found. Please install AIDE manually."
                exit 1
              fi
            fi

            # Initialize AIDE database if not already initialized
            if [ ! -f /var/lib/aide/aide.db.gz ] && [ ! -f /var/lib/aide/aide.db ]; then
              echo "Initializing AIDE database..."
              aide --init
              cp /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz 2>/dev/null || true
              cp /var/lib/aide/aide.db.new /var/lib/aide/aide.db 2>/dev/null || true
            fi

            # Add cron job for daily check at 5AM if not already present
            CRON_LINE="0 5 * * * /usr/sbin/aide --check"
            (crontab -l 2>/dev/null | grep -v -F "$CRON_LINE" ; echo "$CRON_LINE") | crontab -

            echo "AIDE daily check scheduled at 5AM via cron."
            ```
  - uid: mondoo-linux-security-core-dumps-are-restricted
    title: Ensure core dumps are restricted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      file("/etc/security/limits.conf").content.lines.where( _ == /^[^#]/ ).where( _.contains("core") ) {
        _ == /\*\s+hard\s+core\s+0/
      }
      kernel.parameters['fs.suid_dumpable'] == 0
      if(service("coredump").enabled || service("coredump").running) {
        parse.ini("/etc/systemd/coredump.conf").sections['Coredump']['ProcessSizeMax'] == 0
        parse.ini("/etc/systemd/coredump.conf").sections['Coredump']['Storage'] == 'none'
      }
    docs:
      desc: |
        This check verifies that core dumps are restricted on the system by setting appropriate limits in `/etc/security/limits.conf`, configuring the `fs.suid_dumpable` kernel parameter, and ensuring the `coredump` service (if installed) is properly configured. These settings prevent unauthorized or excessive core dump creation, especially for set-user-ID (SUID) programs.

        **Why this matters**

        Core dumps capture the memory contents of a process at the time it crashes. While useful for debugging, core dumps can expose sensitive information such as passwords, cryptographic keys, or proprietary application logic—especially if generated by privileged or network-facing applications.

        By default, systems may allow core dumps for all processes, including those with elevated privileges. If unrestricted:
          - Attackers could exploit this to gain access to in-memory secrets.
          - Users could accidentally or intentionally generate core dumps containing sensitive information.
          - Storage systems could become overwhelmed by large or repeated core files, leading to denial-of-service risks.

        To mitigate this, three key protections should be enforced:
          - A hard limit of 0 core file size in /etc/security/limits.conf to block core dumps for all users by default.
          - Setting the fs.suid_dumpable kernel parameter to 0 to disable core dumps for SUID programs, which typically run with elevated privileges.
          - Properly configuring the coredump service (if installed) with ProcessSizeMax=0 and Storage=none to prevent systemd-based core dump handling from storing crash data.

        Restricting core dumps helps preserve the confidentiality of system memory, prevents unnecessary disk usage, and protects against inadvertent leakage of sensitive data.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Run this command to set the core dump size to 0:

                ```bash
                ulimit -c 0
                ```

            2. To make the change permanent:

                Edit `/etc/security/limits.conf` and add the following line:

                ```
                * hard core 0
                ```

                Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                fs.suid_dumpable = 0
                ```

                Run this command to set the active kernel parameter:

                ```bash
                sysctl -w fs.suid_dumpable=0
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to restrict core dumps:

            ```yaml
            ---
            - name: Disable core dumps on Linux
              hosts: all
              become: true

              tasks:
                - name: Set hard core dump limit to 0 in limits.d
                  ansible.builtin.copy:
                    dest: /etc/security/limits.d/99-disable-core.conf
                    owner: root
                    group: root
                    mode: '0644'
                    content: |
                      * hard core 0

                - name: Disable core dumps via sysctl
                  ansible.builtin.sysctl:
                    name: fs.suid_dumpable
                    value: '0'
                    sysctl_file: /etc/sysctl.d/99-disable-coredump.conf
                    state: present
                    sysctl_set: true
                    reload: yes

                - name: Check if systemd-coredump config exists
                  ansible.builtin.stat:
                    path: /etc/systemd/coredump.conf
                  register: coredump_conf

                - name: Set systemd-coredump options if applicable
                  block:
                    - name: Ensure /etc/systemd/coredump.conf exists with correct settings
                      ansible.builtin.ini_file:
                        path: /etc/systemd/coredump.conf
                        section: Coredump
                        option: "{{ item.option }}"
                        value: "{{ item.value }}"
                      loop:
                        - { option: 'Storage', value: 'none' }
                        - { option: 'ProcessSizeMax', value: '0' }

                    - name: Reload systemd daemon after coredump config change
                      ansible.builtin.command: systemctl daemon-reexec
                  when: coredump_conf.stat.exists
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to restrict core dumps. It will set the appropriate limits, kernel parameters, and update systemd-coredump configuration if present.

            ```bash
            #!/bin/bash
            set -e

            # Set hard core dump limit to 0
            if ! grep -qE '^\*\s+hard\s+core\s+0' /etc/security/limits.conf; then
              echo "Adding hard core limit to /etc/security/limits.conf"
              echo '* hard core 0' | tee -a /etc/security/limits.conf
            fi

            # Set fs.suid_dumpable to 0 in sysctl
            if ! grep -q '^fs.suid_dumpable' /etc/sysctl.conf 2>/dev/null && ! grep -q '^fs.suid_dumpable' /etc/sysctl.d/* 2>/dev/null; then
              echo "Setting fs.suid_dumpable to 0 in /etc/sysctl.d/99-disable-coredump.conf"
              echo 'fs.suid_dumpable = 0' | tee /etc/sysctl.d/99-disable-coredump.conf
            fi
            sysctl -w fs.suid_dumpable=0

            # Configure systemd-coredump if present
            if [ -f /etc/systemd/coredump.conf ]; then
              echo "Setting systemd-coredump configuration"
              sed -i '/^ProcessSizeMax/d' /etc/systemd/coredump.conf
              sed -i '/^Storage/d' /etc/systemd/coredump.conf
              echo -e '[Coredump]\nProcessSizeMax=0\nStorage=none' | tee -a /etc/systemd/coredump.conf
              systemctl daemon-reexec
            fi

            echo "Core dump restrictions applied."
            ```
  - uid: mondoo-linux-security-address-space-layout-randomization-aslr-is-enabled
    title: Ensure address space layout randomization (ASLR) is enabled
    impact: 90
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters["kernel.randomize_va_space"] == 2
    docs:
      desc: |
        This check verifies that Address Space Layout Randomization (ASLR) is enabled by confirming that the kernel parameter kernel.randomize_va_space is set to 2, which enforces full randomization of memory regions.

        **Why this matters**

        ASLR is a memory protection technique that randomizes the location of key data areas in a process's address space, such as the stack, heap, and libraries. This unpredictability makes it significantly harder for attackers to exploit memory corruption vulnerabilities, such as buffer overflows, since they cannot reliably guess the locations of critical functions or data structures in memory.

        When ASLR is disabled or misconfigured:
          - Exploits that rely on fixed memory addresses become easier to execute.
          - Attackers may leverage known memory layouts to bypass protections like stack canaries, non-executable memory (NX), and control flow integrity.
          - Systems become more susceptible to privilege escalation, remote code execution, and other forms of memory-based attacks.

        Setting kernel.randomize_va_space to 2 enables full ASLR, providing the strongest level of memory layout unpredictability and helping to enforce modern exploit mitigation strategies on Linux systems.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Set the ASLR value to 2:

                ```bash
                sysctl -w kernel.randomize_va_space=2
                ```

            2. Make the change permanent:

                Edit `/etc/sysctl.conf` or a file in `/etc/sysctl.d/` and add the following line:

                ```
                kernel.randomize_va_space = 2
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set ASLR:

            ```yaml
            ---
            - name: Set ASLR to 2 on Linux systems
              hosts: all
              become: true

              tasks:
                - name: Set kernel.randomize_va_space to 2
                  ansible.builtin.sysctl:
                    name: kernel.randomize_va_space
                    value: '2'
                    sysctl_file: /etc/sysctl.d/99-aslr.conf
                    state: present
                    sysctl_set: true
                    reload: yes
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to set ASLR. It will check if the setting is already configured and apply it if not.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^kernel.randomize_va_space' /etc/sysctl.conf 2>/dev/null; then
              echo "Updating kernel.randomize_va_space to 2 in /etc/sysctl.conf"
              sed -i 's/^kernel.randomize_va_space.*/kernel.randomize_va_space = 2/' /etc/sysctl.conf
            else
              echo "Setting kernel.randomize_va_space to 2 in /etc/sysctl.d/99-aslr.conf"
              echo 'kernel.randomize_va_space = 2' | tee /etc/sysctl.d/99-aslr.conf
            fi

            sysctl -w kernel.randomize_va_space=2
            ```
  - uid: mondoo-linux-security-prelink-is-disabled
    title: Ensure prelink is disabled
    impact: 70
    mql: |
      package("prelink").installed == false
    docs:
      desc: |
        This check verifies that the prelink package is not installed on the system. The prelink utility modifies ELF binaries to optimize program load times by precomputing memory locations for shared libraries. While this can improve performance, it also introduces security risks and interferes with other critical system protections.

        **Why this matters**

        Disabling prelink helps ensure the reliability of security tools and strengthens system integrity protections. When prelink is active:
          - It modifies binaries on disk, which can prevent tools like AIDE from detecting unauthorized tampering because legitimate prelink changes obscure unauthorized ones.
          - It can negate security mechanisms such as Address Space Layout Randomization (ASLR) by fixing memory address locations in advance, undermining this key exploit mitigation technique.
          - It increases the system's attack surface by introducing complexity and modifying binaries in ways that may be exploited or misunderstood by defenders.

        Removing prelink eliminates this unnecessary risk, ensures compatibility with file integrity monitoring tools, and supports consistent enforcement of modern memory protection strategies.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to remove the prelink package:

            ### RHEL/Fedora/Amazon Linux and derivatives

            ```bash
            yum remove prelink
            ```

            ### Debian/Ubuntu and derivatives

            ```bash
            apt-get purge prelink
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to remove the prelink package:

            ```yaml
            ---
            - name: Remove prelink package
              hosts: all
              become: true

              tasks:
                - name: Remove prelink on RHEL/Fedora/Amazon Linux
                  ansible.builtin.yum:
                    name: prelink
                    state: absent
                  when: ansible_os_family == "RedHat"

                - name: Remove prelink on Debian/Ubuntu
                  ansible.builtin.apt:
                    name: prelink
                    state: absent
                  when: ansible_os_family == "Debian"
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to remove the prelink package. It will auto-detect the package manager and remove prelink if installed.

            ```bash
            #!/bin/bash
            set -e

            if command -v yum >/dev/null 2>&1; then
              echo "Detected yum-based system. Removing prelink..."
              yum remove -y prelink
            elif command -v dnf >/dev/null 2>&1; then
              echo "Detected dnf-based system. Removing prelink..."
              dnf remove -y prelink
            elif command -v apt-get >/dev/null 2>&1; then
              echo "Detected apt-based system. Removing prelink..."
              apt-get purge -y prelink
            else
              echo "No supported package manager found. Please remove prelink manually."
              exit 1
            fi
            echo "Prelink removal complete."
            ```
  - uid: mondoo-linux-security-window-system-is-not-installed
    title: Ensure X Window System is not installed
    impact: 100
    mql: |
      packages.none(name == /^xserver-xorg.*/ || name == /^xorg-x11/ || name == /^xserver/)
    docs:
      desc: |
        This check verifies that the X Window System is not installed on the host. It scans for common packages associated with X, such as xserver-xorg, xorg-x11, and other display server components.

        **Why this matters**

        The X Window System provides a graphical user interface (GUI) that enables users to interact with applications through windows, menus, and graphical controls. While useful for desktop environments, it is generally unnecessary—and potentially risky—on servers or hardened systems that do not require graphical interfaces.

        Keeping the X Window System installed on a server can:
          - Introduce unnecessary software components and services, increasing the system's attack surface.
          - Add network-facing daemons that may not be actively monitored or patched, creating potential entry points for attackers.
          - Consume additional system resources that could otherwise be allocated to critical services.

        On headless or server-class Linux systems, the X Window System should be removed unless explicitly required. Removing it aligns with the principle of least functionality, ensuring only essential software is installed and reducing the opportunity for exploitation.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to remove the X Windows System packages:

            ### RHEL/Fedora/Amazon Linux and derivatives

            ```bash
            yum remove xorg-x11*
            ```

            ### Debian/Ubuntu and derivatives

            ```bash
            apt-get purge xserver-xorg xserver-common
            ```

            ### SLES and openSUSE

            ```bash
            zypper remove xorg-x11-server
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to remove the X Windows System packages:

            ```yaml
            ---
            - name: Remove X Window System packages
              hosts: all
              become: true

              tasks:
                - name: Remove X Window System packages on RHEL/Fedora/Amazon Linux
                  ansible.builtin.yum:
                    name: xorg-x11*
                    state: absent
                  when: ansible_os_family == "RedHat"

                - name: Remove X Window System packages on Debian/Ubuntu
                  ansible.builtin.apt:
                  name:
                    - xserver-xorg
                    - xserver-common
                  state: absent
                  purge: yes
                  when: ansible_os_family == "Debian"

                - name: Remove X Window System packages on SLES/openSUSE
                  ansible.builtin.zypper:
                    name: xorg-x11-server
                    state: absent
                  when: ansible_os_family == "Suse"
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to remove the X Window System packages. It will auto-detect the package manager and remove relevant X packages if installed.

            ```bash
            #!/bin/bash
            set -e

            if command -v yum >/dev/null 2>&1; then
              echo "Detected yum-based system. Removing X Window System packages..."
              yum remove -y xorg-x11*
            elif command -v dnf >/dev/null 2>&1; then
              echo "Detected dnf-based system. Removing X Window System packages..."
              dnf remove -y xorg-x11*
            elif command -v apt-get >/dev/null 2>&1; then
              echo "Detected apt-based system. Removing X Window System packages..."
              apt-get purge -y xserver-xorg xserver-common
            elif command -v zypper >/dev/null 2>&1; then
              echo "Detected zypper-based system. Removing X Window System packages..."
              zypper remove -y xorg-x11-server
            else
              echo "No supported package manager found. Please remove X Window System packages manually."
              exit 1
            fi
            ```
  - uid: mondoo-linux-security-avahi-server-is-not-enabled
    title: Ensure Avahi server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("avahi-daemon").enabled == false
      service("avahi-daemon").running == false
    docs:
      desc: |
        This check verifies that the avahi-daemon service is neither running nor enabled on the system. Avahi is a zeroconf (zero-configuration networking) implementation that supports multicast DNS (mDNS) and DNS Service Discovery (DNS-SD), allowing devices to automatically discover each other on local networks.

        **Why this matters**

        While convenient in desktop or home environments, Avahi is rarely needed on production servers or hardened enterprise systems. When enabled, the Avahi daemon broadcasts services and listens for network announcements, which can:
          - Expose unnecessary information about the system to local network peers.
          - Increase the system's attack surface through unneeded services.
          - Allow unauthorized devices to detect and interact with the host without explicit configuration.

        In secure environments, it is a best practice to disable Avahi unless explicitly required for functionality. Stopping and disabling the avahi-daemon service helps enforce the principle of least functionality and reduces the risk of unintended network exposure.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to stop and disable `avahi-daemon`:

            ```bash
            systemctl stop avahi-daemon
            systemctl disable avahi-daemon
            ```

            Note: Since the `avahi-daemon` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

            To make the service `avahi-daemon` invisible to other services run this command:

            ```bash
            systemctl mask avahi-daemon
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `avahi-daemon`:

            ```yaml
            ---
            - name: Stop and disable Avahi daemon
              hosts: all
              become: true

              tasks:
                - name: Ensure Avahi daemon is stopped and disabled
                  ansible.builtin.systemd:
                    name: avahi-daemon
                    state: stopped
                    enabled: no
                    masked: true
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the Avahi daemon.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping, disabling, and masking Avahi daemon..."
            systemctl stop avahi-daemon
            systemctl disable avahi-daemon
            systemctl mask avahi-daemon
            ```
  - uid: mondoo-linux-security-cups-is-not-enabled
    title: Ensure CUPS is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("cups").enabled == false
      service("cups").running == false
    docs:
      desc: |
        This check verifies that the Common Unix Printing System (CUPS) service is neither running nor enabled on the system. CUPS provides printing capabilities for local and network printers and includes web-based administration tools.

        **Why this matters**

        CUPS is typically unnecessary on hardened servers or cloud-hosted Linux systems where printing services are not required. If left running:
          - It may expose the system to remote exploitation, especially if administrative interfaces are accessible over the network.
          - It increases the overall attack surface by introducing a network-accessible daemon.
          - Unused services like CUPS can be leveraged in lateral movement or privilege escalation scenarios, particularly if misconfigured or unpatched.

        Disabling CUPS aligns with the principle of least functionality and helps reduce the number of services available for exploitation. It is recommended to stop and disable the service unless printing capabilities are explicitly required for the system's role.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to stop and disable `cups`:

            ```bash
            systemctl stop cups
            systemctl disable cups
            ```

            Note: Since the `cups` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

            To make the service `cups` invisible to other services run this command:

            ```bash
            systemctl mask cups
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `cups`:

            ```yaml
            ---
            - name: Stop and disable CUPS printing service
              hosts: all
              become: true

              tasks:
                - name: Ensure CUPS service is stopped and disabled
                  ansible.builtin.systemd:
                    name: cups
                    state: stopped
                    enabled: no
                    masked: true
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the CUPS service.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping, disabling, and masking CUPS service..."
            systemctl stop cups
            systemctl disable cups
            systemctl mask cups
            ```
  - uid: mondoo-linux-security-dhcp-server-is-not-enabled
    title: Ensure DHCP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("dhcpd").enabled == false
      service("dhcpd").running == false
    docs:
      desc: |
        This check verifies that the DHCP server service (dhcpd) is neither running nor enabled on the system.

        **Why this matters**

        The Dynamic Host Configuration Protocol (DHCP) allows systems to dynamically assign IP addresses and other network configuration parameters to devices on a network. While essential in network infrastructure roles, DHCP servers are rarely required on general-purpose Linux systems or production servers.

        Running a DHCP server where it is not explicitly needed can:
          - Lead to IP address conflicts and unpredictable network behavior.
          - Allow unauthorized clients to obtain network configuration from an untrusted source.
          - Expose the host to exploitation if the service is vulnerable or misconfigured.

        Disabling unused services like dhcpd reduces the system's attack surface and aligns with the principle of least functionality. On systems that are not intended to serve as DHCP servers, the service should be fully disabled to prevent accidental exposure or misuse.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Run this command to stop and disable `dhcpd`:

                ```bash
                systemctl stop dhcpd
                systemctl disable dhcpd
                ```

            2. To make the service `dhcpd` invisible to other services run this command:

                ```bash
                systemctl mask dhcpd
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `dhcpd`:

            ```yaml
            ---
            - name: Stop and disable DHCP server service
              hosts: all
              become: true

              tasks:
                - name: Ensure DHCP server (dhcpd) is stopped and disabled
                  ansible.builtin.systemd:
                    name: dhcpd
                    state: stopped
                    enabled: no
                    masked: true
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the DHCP server.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping, disabling, and masking DHCP server..."
            systemctl stop dhcpd
            systemctl disable dhcpd
            systemctl mask dhcpd
            ```
  - uid: mondoo-linux-security-ldap-server-is-not-enabled
    title: Ensure LDAP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("slapd").enabled == false
      service("slapd").running == false
    docs:
      desc: |
        This check verifies that the LDAP server service (slapd) is neither running nor enabled on the system.

        **Why this matters**

        The Lightweight Directory Access Protocol (LDAP) server provides centralized directory services for managing user identities, authentication data, and configuration information across a network. While useful in enterprise environments that require directory-based access management, an LDAP server is rarely needed on general-purpose Linux systems unless explicitly part of the infrastructure design.

        If an unnecessary LDAP server is running:
          - It may expose sensitive directory information to the network.
          - It increases the system's attack surface by introducing a network-accessible service.
          - It can be misused or targeted by attackers to enumerate user accounts, perform unauthorized lookups, or exploit known vulnerabilities.

        To reduce risk and enforce the principle of least functionality, the slapd service should be stopped and disabled on systems that are not intended to serve directory services. This helps limit exposure and strengthens the host's overall security posture.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to stop and disable `slapd`:

            ```bash
            systemctl stop slapd
            systemctl disable slapd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `slapd`:

            ```yaml
            ---
            - name: Stop and disable LDAP server (slapd)
              hosts: all
              become: true

              tasks:
                - name: Ensure LDAP server (slapd) is stopped and disabled
                  ansible.builtin.systemd:
                    name: slapd
                    state: stopped
                    enabled: no
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the LDAP server.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling the slapd service..."
            systemctl stop slapd
            systemctl disable slapd
            ```
  - uid: mondoo-linux-security-nfs-and-rpc-are-not-enabled
    title: Ensure NFS and RPC are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("nfs").enabled == false
      service("nfs").running == false
      service("rpcbind").enabled == false
      service("rpcbind").running == false
    docs:
      desc: |
        This check verifies that the NFS (nfs) and RPC (rpcbind) services are not running and are disabled from starting at boot. These services are commonly used to share directories across systems on a network using the Network File System (NFS) protocol.

        **Why this matters**

        NFS and RPC are powerful but legacy components of networked UNIX environments. They introduce significant security risks when enabled unnecessarily, particularly on systems not explicitly configured as file servers or requiring remote filesystem mounts.

        When NFS and RPC are active:
          - They open multiple ports and expose services that can be discovered and potentially exploited.
          - RPC-based services may leak metadata about system configurations or mount points.
          - Misconfigurations or vulnerabilities in these services can be used for privilege escalation, lateral movement, or data exfiltration.

        Disabling NFS and RPC services on systems where they are not required reduces unnecessary network exposure, aligns with the principle of least functionality, and helps harden systems against remote access threats.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Run this command to stop and disable `nfs` and `rpcbind`:

                ```bash
                systemctl stop nfs
                systemctl stop rpcbind

                systemctl disable nfs
                systemctl disable rpcbind
                ```

            2. To make the service `nfs` and `rpcbind` invisible to other services run this command:

                ```bash
                systemctl mask nfs
                systemctl mask rpcbind
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `nfs` and `rpcbind`:

            ```yaml
            ---
            - name: Stop and disable NFS and RPC services
              hosts: all
              become: true

              tasks:
                - name: Ensure NFS and RPC services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                    masked: true
                  loop:
                    - nfs
                    - rpcbind
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the NFS and RPC services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling NFS and RPC services..."
            systemctl stop nfs
            systemctl stop rpcbind
            systemctl disable nfs
            systemctl disable rpcbind
            ```
  - uid: mondoo-linux-security-dns-server-is-not-enabled
    title: Ensure DNS server is stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("named").enabled == false
      service("named").running == false
      service("bind9").enabled == false
      service("bind9").running == false
    docs:
      desc: |
        This check verifies that DNS server services such as named (BIND) or bind9 are not running and are disabled on the system.

        **Why this matters**

        DNS servers provide name resolution services by mapping domain names to IP addresses. While essential in network infrastructure roles, running a DNS server on systems that are not explicitly intended to serve DNS requests introduces unnecessary risk.

        If a DNS server is unintentionally left active:
          - It may expose internal network details or zone files to unauthorized users.
          - It can be used in DNS amplification attacks if misconfigured.
          - It increases the system's attack surface through open ports and additional daemon processes.

        Disabling DNS server services on systems that are not authoritative or caching resolvers aligns with the principle of least functionality. This reduces exposure to misconfiguration, limits available network services, and strengthens the host's security posture.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to stop and disable `named` and `bind9`:

            ```bash
            systemctl stop named
            systemctl stop bind9

            systemctl disable named
            systemctl disable bind9
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `named` and `bind9`:

            ```yaml
            ---
            - name: Stop and disable DNS server services
              hosts: all
              become: true

              tasks:
                - name: Ensure DNS server services (named and bind9) are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - named
                    - bind9
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the DNS server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling DNS server services..."
            systemctl stop named
            systemctl stop bind9
            systemctl disable named
            systemctl disable bind9
            ```
  - uid: mondoo-linux-security-ftp-server-is-not-enabled
    title: Ensure FTP servers are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("vsftpd").enabled == false
      service("vsftpd").running == false
      service("proftpd").enabled == false
      service("proftpd").running == false
      service("pure-ftpd").enabled == false
      service("pure-ftpd").running == false
    docs:
      desc: |
        This check verifies that common FTP server services—vsftpd, proftpd, and pure-ftpd—are not running and are disabled on the system.

        **Why this matters**

        FTP servers enable file transfer over a network but do so using plaintext for both data and credentials, making them inherently insecure. When enabled without encryption or proper controls, FTP services are vulnerable to:
          - Credential theft through packet sniffing
          - Unauthorized file access or modification
          - Abuse in reconnaissance and data exfiltration by attackers

        In most environments, FTP has been replaced by more secure alternatives like SFTP or FTPS, which encrypt both authentication and file transfer traffic. Unless explicitly required, running an FTP server introduces unnecessary risk and increases the system's attack surface.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run this command to stop and disable `vsftpd`, `proftpd`, and `pure-ftpd`:

            ```bash
            systemctl stop vsftpd
            systemctl disable vsftpd

            systemctl stop proftpd
            systemctl disable proftpd

            systemctl stop pure-ftpd
            systemctl disable pure-ftpd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `vsftpd`, `proftpd`, and `pure-ftpd`:

            ```yaml
            ---
            - name: Stop and disable FTP server services
              hosts: all
              become: true

              tasks:
                - name: Ensure FTP server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - vsftpd
                    - proftpd
                    - pure-ftpd
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the FTP server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling FTP server services..."
            systemctl stop vsftpd
            systemctl stop proftpd
            systemctl stop pure-ftpd
            systemctl disable vsftpd
            systemctl disable proftpd
            systemctl disable pure-ftpd
            ```
  - uid: mondoo-linux-security-http-server-is-not-enabled
    title: Ensure HTTP servers are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("httpd").enabled == false
      service("httpd").running == false
      service("apache2").enabled == false
      service("apache2").running == false
      service("nginx").enabled == false
      service("nginx").running == false
    docs:
      desc: |
        This check verifies that common HTTP server services such as httpd, apache2, and nginx are not running and are disabled on the system.

        **Why this matters**

        HTTP servers provide web hosting functionality and are often exposed to the network, making them high-value targets for attackers. Unless the system is explicitly intended to serve web content, running these services introduces unnecessary security risk.

        If left enabled:
          - HTTP servers can expose sensitive files or administrative interfaces.
          - They may contain unpatched vulnerabilities that are remotely exploitable.
          - Misconfigurations can lead to data leakage, privilege escalation, or unauthorized access.

        Disabling web servers like Apache and NGINX on systems where they are not required aligns with the principle of least functionality. This reduces the system's attack surface and helps ensure that only essential services are active and maintained.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run this command to stop and disable `httpd`, `apache2`, and `nginx`:

            ```bash
            systemctl stop httpd
            systemctl disable httpd

            systemctl stop apache2
            systemctl disable apache2

            systemctl stop nginx
            systemctl disable nginx
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `httpd`, `apache2`, and `nginx`:

            ```yaml
            ---
            - name: Stop and disable HTTP server services
              hosts: all
              become: true

              tasks:
                - name: Ensure HTTP server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - httpd
                    - apache2
                    - nginx
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable HTTP server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling HTTP server services..."
            systemctl stop httpd
            systemctl stop apache2
            systemctl stop nginx
            systemctl disable httpd
            systemctl disable apache2
            systemctl disable nginx
            ```
  - uid: mondoo-linux-security-imap-and-pop3-server-is-not-enabled
    title: Ensure IMAP and POP3 servers are stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("dovecot").enabled == false
      service("dovecot").running == false
      service("cyrus-imapd").enabled == false
      service("cyrus-imapd").running == false
    docs:
      desc: |
        This check verifies that common IMAP and POP3 email server services such as dovecot and cyrus-imapd are not running and are disabled from starting at boot.

        **Why this matters**

        IMAP (Internet Message Access Protocol) and POP3 (Post Office Protocol) servers are used to deliver email messages to clients. These services are typically deployed in environments where systems are designated as mail servers. On general-purpose Linux systems or hardened servers, they are rarely required and introduce unnecessary risk if left enabled.

        Running IMAP or POP3 servers where not needed can:
          - Expose authentication services and mail data to the network.
          - Increase the system's attack surface via potentially unpatched or misconfigured mail daemons.
          - Create compliance and privacy issues if email data is improperly stored or transmitted.

        To minimize exposure, systems that do not explicitly require mail delivery services should have dovecot, cyrus-imapd, and similar services disabled. This approach supports the principle of least functionality and reduces the risk of unauthorized access or system compromise.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run this command to stop and disable `dovecot` and `cyrus-imapd`:

            ```bash
            systemctl stop dovecot
            systemctl disable dovecot

            systemctl stop cyrus-imapd
            systemctl disable cyrus-imapd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `dovecot` and `cyrus-imapd`:

            ```yaml
            ---
            - name: Stop and disable IMAP and POP3 server services
              hosts: all
              become: true

              tasks:
                - name: Ensure IMAP and POP3 server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - dovecot
                    - cyrus-imapd
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable IMAP and POP3 server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling IMAP and POP3 server services..."
            systemctl stop dovecot
            systemctl stop cyrus-imapd
            systemctl disable dovecot
            systemctl disable cyrus-imapd
            ```
  - uid: mondoo-linux-security-samba-is-not-enabled
    title: Ensure Samba is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("smb").enabled == false
      service("smbd").enabled == false
      service("smb").running == false
      service("smbd").running == false
    docs:
      desc: |
        This check verifies that the Samba services (smb and smbd) are not running and are disabled on the system.

        **Why this matters**

        Samba provides file and print sharing capabilities for interoperability between Linux and Windows systems using the SMB/CIFS protocol. While useful in mixed OS environments that require shared resources, Samba is unnecessary—and potentially risky—on systems that are not intended to serve files or printers over the network.

        If Samba is enabled where not needed:
          - It introduces network-facing services that can be discovered and targeted by attackers.
          - Misconfigurations or outdated Samba versions may allow unauthorized access or remote code execution.
          - It increases the system's attack surface and may expose internal file systems unintentionally.

        To minimize unnecessary exposure, Samba should be disabled on systems that do not explicitly require Windows-compatible file sharing. This approach supports a least functionality model and helps reduce the risk of data leakage or compromise.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `smb` and `smbd`:

            ```bash
            systemctl stop smb
            systemctl stop smbd

            systemctl disable smb
            systemctl disable smbd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `smb` and `smbd`:

            ```yaml
            ---
            - name: Stop and disable Samba services
              hosts: all
              become: true

              tasks:
                - name: Stop and disable Samba services
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - smb
                    - smbd
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable Samba services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling Samba services..."
            systemctl stop smb
            systemctl stop smbd
            systemctl disable smb
            systemctl disable smbd
            ```
  - uid: mondoo-linux-security-http-proxy-server-is-not-enabled
    title: Ensure HTTP Proxy server is stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("squid").enabled == false
      service("squid").running == false
      service("tinyproxy").enabled == false
      service("tinyproxy").running == false
    docs:
      desc: |
        This check verifies that HTTP proxy services such as squid and tinyproxy are not running and are disabled on the system.

        **Why this matters**

        HTTP proxy servers are used to forward client requests to destination servers, often to enable caching, access control, or anonymization of traffic. While valuable in network perimeter or gateway roles, proxy services are rarely needed on general-purpose Linux systems or hardened servers.

        If an HTTP proxy service is enabled unnecessarily:
          - It may relay traffic without proper filtering or monitoring, exposing the system to misuse or abuse.
          - Misconfigured proxies can be exploited to bypass security controls, leak sensitive information, or allow unauthorized access to internal networks.
          - Proxy daemons increase the system's attack surface through open ports and additional network logic.

        To reduce risk, squid, tinyproxy, and similar services should be stopped and disabled unless the system is explicitly designed to function as a proxy server. This limits unnecessary service exposure and aligns with best practices for host hardening.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `squid` and `tinyproxy`:

            ```bash
            systemctl stop squid
            systemctl stop tinyproxy

            systemctl disable squid
            systemctl disable tinyproxy
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `squid` and `tinyproxy`:

            ```yaml
            ---
            - name: Stop and disable HTTP proxy services
              hosts: all
              become: true

              tasks:
                - name: Ensure HTTP proxy services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - squid
                    - tinyproxy
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable HTTP proxy services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling HTTP proxy services..."
            systemctl stop squid
            systemctl stop tinyproxy
            systemctl disable squid
            systemctl disable tinyproxy
            ```
  - uid: mondoo-linux-security-snmp-server-is-not-enabled
    title: Ensure SNMP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("snmpd").enabled == false
      service("snmpd").running == false
    docs:
      desc: |
        This check verifies that the SNMP server service (snmpd) is not running and is disabled on the system.

        **Why this matters**

        The Simple Network Management Protocol (SNMP) is used for monitoring and managing network devices. While SNMP can be valuable in infrastructure environments that require centralized device monitoring, it is rarely needed on general-purpose Linux systems or non-networking servers.

        If the SNMP service is enabled unnecessarily:
          - It may expose system and network information to unauthorized users, especially if default community strings are not changed.
          - SNMPv1 and SNMPv2c transmit data in plaintext, making them vulnerable to interception and misuse.
          - Misconfigured or unmonitored SNMP services can be leveraged for network reconnaissance or as part of broader attack campaigns.

        To reduce the risk of information disclosure and limit unnecessary network services, snmpd should be stopped and disabled on systems that are not specifically designated for SNMP-based monitoring. This supports the principle of least functionality and strengthens the system's security posture.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `snmpd`:

            ```bash
            systemctl stop snmpd
            systemctl disable snmpd
            ```

            Note: Since the `snmpd` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

            To make the service `snmpd` invisible to other services run this command:

            ```bash
            systemctl mask snmpd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `snmpd`:

            ```yaml
            ---
            - name: Stop and disable SNMP server
              hosts: all
              become: true

              tasks:
                - name: Ensure SNMP server (snmpd) is stopped and disabled
                  ansible.builtin.systemd:
                    name: snmpd
                    state: stopped
                    masked: true
                    enabled: no
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the SNMP server.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping, disabling, and masking the snmpd service..."
            systemctl stop snmpd
            systemctl disable snmpd
            systemctl mask snmpd
            ```
  - uid: mondoo-linux-security-mail-transfer-agent-is-configured-for-local-only-mode
    title: Ensure mail transfer agent is configured for local-only mode
    impact: 85
    filters: |
      asset.kind != "container-image"
    mql: |
      if( package("postfix").installed && service('postfix').running ) {
        parse.ini("/etc/postfix/main.cf").params["inet_interfaces"] == "localhost" || parse.ini("/etc/postfix/main.cf").params["inet_interfaces"] == "loopback-only"
      }
      if( package("exim4").installed && service('exim4').running ) {
        parse.ini("/etc/exim4/update-exim4.conf.conf").params["dc_local_interfaces"] == "'127.0.0.1 ; ::1'"
      }
      ports.listening.where(address != "127.0.0.1" && address != "[::1]").none(port == 25)
    docs:
      desc: |
        This check verifies that the system's mail transfer agent (MTA), such as Postfix or Exim, is configured to accept and process email only from the local host, rather than listening on external network interfaces.

        **Why this matters**

        Mail transfer agents are used to route and deliver email messages. On most Linux systems, an MTA is installed by default to handle local system notifications, such as cron job outputs or security alerts. However, if the MTA is configured to listen on external interfaces, it may unintentionally expose the system to external email traffic.

        Allowing remote connections to a local MTA can:
          - Turn the system into an open relay if not properly secured.
          - Increase the attack surface by exposing the MTA to brute-force attacks, spoofed messages, or software vulnerabilities.
          - Introduce compliance concerns if email flows are not properly audited or encrypted.

        Configuring the MTA to listen only on the loopback interface (127.0.0.1) ensures it serves only local applications and users. This reduces exposure, limits attack vectors, and aligns with security best practices for systems that are not intended to function as full email servers.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. For Postfix, edit the main configuration file `/etc/postfix/main.cf`:

                ```bash
                vi /etc/postfix/main.cf
                ```

            2. Find the line that starts with `inet_interfaces` and change it to:

                ```ini
                inet_interfaces = loopback-only
                ```

            3. Restart Postfix:

                ```bash
                systemctl restart postfix
                ```

            4. For Exim4, edit the Exim4 configuration file:

                ```bash
                vi /etc/exim4/update-exim4.conf.conf
                ```

            5. Find the line that sets `dc_local_interfaces` and modify it to:

                ```ini
                dc_local_interfaces='127.0.0.1 ; ::1'
                ```

            6. Regenerate the Exim4 runtime configuration and restart the service:

                ```bash
                update-exim4.conf
                systemctl restart exim4
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to ensure the Postfix is configured for local-only mode:

            ```yaml
            ---
            - name: Ensure mail transfer agent is configured for local-only mode
              hosts: all
              become: true

              tasks:
                - name: Configure Postfix for local-only mode
                  ansible.builtin.lineinfile:
                    path: /etc/postfix/main.cf
                    regexp: '^inet_interfaces'
                    line: 'inet_interfaces = loopback-only'
                    state: present

                - name: Restart Postfix
                  ansible.builtin.systemd:
                    name: postfix
                    state: restarted
            ```

            Use this Ansible playbook to ensure the Exim4 is configured for local-only mode:

            ```yaml
            ---
            - name: Ensure Exim4 is configured for local-only mode
              hosts: all
              become: true

              tasks:
                - name: Configure Exim4 for local-only mode
                  ansible.builtin.lineinfile:
                    path: /etc/exim4/update-exim4.conf.conf
                    regexp: '^dc_local_interfaces'
                    line: 'dc_local_interfaces=\'127.0.0.1 ; ::1\''
                    state: present

                - name: Regenerate Exim4 configuration
                  ansible.builtin.command:
                    cmd: update-exim4.conf

                - name: Restart Exim4
                  ansible.builtin.systemd:
                    name: exim4
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to configure the MTA for local-only mode.

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring Postfix for local-only mode..."
            sed -i 's/^inet_interfaces = .*/inet_interfaces = loopback-only/' /etc/postfix/main.cf
            systemctl restart postfix

            echo "Configuring Exim4 for local-only mode..."
            sed -i "s/^dc_local_interfaces = .*/dc_local_interfaces='127.0.0.1 ; ::1'/" /etc/exim4/update-exim4.conf.conf
            update-exim4.conf
            systemctl restart exim4
            ```
  - uid: mondoo-linux-security-nis-server-is-not-enabled
    title: Ensure NIS server is stopped and not enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
    mql: |
      service("ypserv").enabled == false
      service("ypserv").running == false
      service("nis").enabled == false
      service("nis").running == false
    docs:
      desc: |
        This check verifies that the Network Information Service (NIS) server services, such as ypserv or nis, are not running and are disabled on the system.

        **Why this matters**

        NIS (formerly known as Yellow Pages) is a legacy directory service protocol used to centrally manage user accounts and configuration data across multiple systems. While once common in UNIX environments, NIS has significant security limitations and has been largely replaced by more secure alternatives like LDAP or Kerberos.

        If the NIS server is enabled unnecessarily:
          - It may transmit sensitive data such as usernames and password hashes in plaintext.
          - NIS lacks modern authentication and encryption mechanisms, making it highly susceptible to eavesdropping and spoofing attacks.
          - Running NIS services can expose the system to unauthorized access or information disclosure, especially in mixed or untrusted networks.

        On systems that are not explicitly designated to serve as NIS servers, ypserv, nis, and related services should be stopped and disabled. This helps enforce the principle of least functionality and significantly reduces the system's vulnerability to legacy protocol risks.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `ypserv` and `nis`:

            ```bash
            systemctl stop ypserv
            systemctl stop nis

            systemctl disable ypserv
            systemctl disable nis
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `ypserv` and `nis`:

            ```yaml
            ---
            - name: Stop and disable NIS server services
              hosts: all
              become: true

              tasks:
                - name: Ensure NIS server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - ypserv
                    - nis
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable NIS server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling NIS server services..."
            systemctl stop ypserv
            systemctl stop nis
            systemctl disable ypserv
            systemctl disable nis
            ```
  - uid: mondoo-linux-security-rsh-server-is-not-enabled
    title: Ensure rsh server is stopped and not enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
    mql: |
      service("rsh.socket").enabled == false
      service("rlogin.socket").enabled == false
      service("rexec.socket").enabled == false
      service("rsh.socket").running == false
      service("rlogin.socket").running == false
      service("rexec.socket").running == false
    docs:
      desc: |
        This check verifies that the Remote Shell (rsh) server services—specifically rsh.socket, rlogin.socket, and rexec.socket—are not running and are disabled on the system.

        **Why this matters**

        The rsh suite (which includes rsh, rlogin, and rexec) provides remote command execution and login capabilities over a network. However, these services transmit data, including credentials, in plaintext and rely on weak authentication mechanisms based on hostname and user trust relationships.

        If rsh services are enabled:
          - They expose sensitive data to interception, making the system vulnerable to credential theft.
          - Host-based trust mechanisms (like .rhosts) can be easily bypassed or misconfigured, allowing unauthorized access.
          - They increase the system's attack surface and may be exploited for lateral movement in a compromised environment.

        Because of these risks, rsh is considered obsolete and should be replaced with secure alternatives such as SSH. Disabling rsh, rlogin, and rexec services helps prevent unauthorized remote access and aligns with modern security best practices for system hardening.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `rsh`, `rlogin`, and `rexec`:

            ```bash
            systemctl stop rsh.socket
            systemctl stop rlogin.socket
            systemctl stop rexec.socket

            systemctl disable rsh.socket
            systemctl disable rlogin.socket
            systemctl disable rexec.socket
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `rsh`, `rlogin`, and `rexec`:

            ```yaml
            ---
            - name: Stop and disable rsh server services
              hosts: all
              become: true

              tasks:
                - name: Ensure rsh-related services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - rsh.socket
                    - rlogin.socket
                    - rexec.socket
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable rsh server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling rsh server services..."
            systemctl stop rsh.socket
            systemctl stop rlogin.socket
            systemctl stop rexec.socket
            systemctl disable rsh.socket
            systemctl disable rlogin.socket
            systemctl disable rexec.socket
            ```
  - uid: mondoo-linux-security-telnet-server-is-not-enabled
    title: Ensure Telnet server is stopped and not enabled
    impact: 90
    filters: |
      asset.kind != "container-image"
    mql: |
      service("telnet.socket").enabled == false
      service("telnet.socket").running == false
    docs:
      desc: |-
        This check verifies that the Telnet server service (telnet.socket) is not running and is disabled on the system.

        **Why this matters**

        Telnet is an older protocol used for remote command-line access over a network. It transmits all data—including usernames and passwords—in plaintext, making it highly insecure for modern environments. Any system using Telnet is vulnerable to eavesdropping, session hijacking, and credential theft.

        If the Telnet server is enabled:
          - It exposes the system to man-in-the-middle attacks due to the lack of encryption.
          - Credentials and session data can be intercepted by any attacker with network access.
          - It creates a significant attack surface that can be exploited by automated tools or targeted threats.

        Modern systems should use secure alternatives such as SSH, which encrypt all communications. Disabling Telnet services on systems where they are not explicitly required strengthens the host's security posture and reduces the risk of unauthorized access.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these command to stop and disable telnet:

            ```bash
            systemctl stop telnet.socket
            systemctl disable telnet.socket
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable telnet:

            ```yaml
            ---
            - name: Stop and disable Telnet server
              hosts: all
              become: true

              tasks:
                - name: Ensure Telnet server is stopped and disabled
                  ansible.builtin.systemd:
                    name: telnet.socket
                    state: stopped
                    enabled: no
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the Telnet server.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling telnet service..."
            systemctl stop telnet.socket
            systemctl disable telnet.socket
            ```
  - uid: mondoo-linux-security-tftp-server-is-not-enabled
    title: Ensure TFTP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("tftp.socket").enabled == false
      service("tftp.socket").running == false
    docs:
      desc: |
        This check verifies that the Trivial File Transfer Protocol (TFTP) server service (tftp.socket) is not running and is disabled on the system.

        **Why this matters**

        TFTP is a simple, lightweight file transfer protocol typically used for tasks such as bootstrapping diskless workstations or network appliances. It lacks authentication, encryption, and access control mechanisms, making it highly insecure for general-purpose or internet-connected systems.

        If the TFTP server is enabled:
          - Files can be read or written without authentication, leading to data leakage or unauthorized modification.
          - Attackers can use TFTP to upload malicious payloads or exfiltrate sensitive files.
          - It may serve as an entry point for lateral movement in network-based attacks, especially in environments with legacy devices.

        Unless TFTP is explicitly required for a specific, isolated use case, the service should be stopped and disabled. Removing unnecessary TFTP services reduces the system's attack surface and aligns with best practices for minimizing unauthenticated network protocols.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable tftp:

            ```bash
            systemctl stop tftp.socket
            systemctl disable tftp.socket
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable tftp:

            ```yaml
            ---
            - name: Stop and disable TFTP server
              hosts: all
              become: true

              tasks:
                - name: Ensure TFTP server is stopped and disabled
                  ansible.builtin.systemd:
                    name: tftp.socket
                    state: stopped
                    enabled: no
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the TFTP server.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling TFTP service..."
            systemctl stop tftp.socket
            systemctl disable tftp.socket
            ```
  - uid: mondoo-linux-security-rsync-service-is-not-enabled
    title: Ensure rsync service is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("rsyncd").enabled == false
      service("rsyncd").running == false
    docs:
      desc: |
        This check verifies that the rsyncd service, which enables the rsync daemon for file synchronization over the network, is not running and is disabled on the system.

        **Why this matters**

        The rsync daemon allows systems to synchronize files with remote hosts. While useful in backup and replication workflows, running rsyncd as a service introduces a network-accessible endpoint that may expose files or directories if not properly secured.

        If the rsync service is enabled unnecessarily:
          - It can expose sensitive files to unauthorized access, especially if authentication is misconfigured or absent.
          - It increases the system's attack surface by opening a network port that could be targeted for exploitation.
          - Unrestricted or anonymous rsync configurations can lead to data exfiltration or integrity compromise.

        Unless the system is explicitly configured to serve files via rsyncd, the service should be disabled. This aligns with the principle of least functionality and helps prevent accidental exposure of file data to untrusted networks.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `rsync`:

            ```bash
            systemctl stop rsyncd
            systemctl disable rsyncd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `rsync`:

            ```yaml
            ---
            - name: Stop and disable rsync service
              hosts: all
              become: true

              tasks:
                - name: Ensure rsync service is stopped and disabled
                  ansible.builtin.systemd:
                    name: rsyncd
                    state: stopped
                    enabled: no
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable the rsync service.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling rsyncd service..."
            systemctl stop rsyncd
            systemctl disable rsyncd
            ```
  - uid: mondoo-linux-security-talk-server-is-not-enabled
    title: Ensure talk server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("ntalk").enabled == false
      service("ntalk").running == false
      service("talkd").enabled == false
      service("talkd").running == false
    docs:
      desc: |
        This check verifies that the talk server (talkd or ntalk) is disabled to prevent the use of an outdated and insecure communication protocol.

        **Why this matters**

        The talk protocol enables real-time text-based communication between users on UNIX systems. However, it lacks encryption and strong authentication mechanisms, making it unsuitable for modern environments.

        If the talk server is enabled:
          - It exposes the system to network-based attacks through an unnecessary and insecure service.
          - Messages are transmitted in plaintext, allowing for potential interception and eavesdropping.
          - The service increases the system's attack surface and may be abused for denial-of-service attacks or unauthorized user messaging.

        Disabling the talk server minimizes risk, reduces the system's attack surface, and enforces a minimal, hardened system configuration.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `ntalk` and `talkd`:

            ```bash
            systemctl stop ntalk
            systemctl stop talkd

            systemctl disable ntalk
            systemctl disable talkd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `ntalk` and `talkd`:

            ```yaml
            ---
            - name: Stop and disable talk server services
              hosts: all
              become: true

              tasks:
                - name: Ensure talk server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - ntalk
                    - talkd
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to stop and disable talk server services.

            ```bash
            #!/bin/bash
            set -e

            echo "Stopping and disabling talk server services..."
            systemctl stop ntalk
            systemctl stop talkd
            systemctl disable ntalk
            systemctl disable talkd
            ```
  - uid: mondoo-linux-security-ip-forwarding-is-disabled
    title: Ensure IP forwarding is disabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.ip_forward'] == 0
        || kernel.parameters['net.ipv4.ip_forward'] == null
      kernel.parameters['net.ipv6.conf.all.forwarding'] == 0
        || kernel.parameters['net.ipv6.conf.all.forwarding'] == null
    docs:
      desc: |
        This check verifies that IP forwarding is disabled by confirming that the kernel parameters net.ipv4.ip_forward and net.ipv6.conf.all.forwarding are set to 0.

        **Why this matters**

        IP forwarding allows a system to route network packets between interfaces, effectively enabling it to act as a router. While necessary for certain network infrastructure roles, IP forwarding is not appropriate for general-purpose servers, workstations, or systems that are not explicitly configured to route traffic.

        If IP forwarding is enabled unnecessarily:
          - The system could be used to redirect or intercept network traffic, intentionally or accidentally.
          - It increases the risk of network misconfiguration, data leakage, or man-in-the-middle attacks.
          - It may violate segmentation and isolation policies in secure environments.

        Disabling IP forwarding ensures the system cannot forward packets between networks, reducing the potential for misuse or compromise. This helps maintain clear boundaries between network zones and supports a more secure and predictable system configuration.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.ip_forward = 0
                net.ipv6.conf.all.forwarding = 0
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.ip_forward=0
                sysctl -w net.ipv4.route.flush=1

                sysctl -w net.ipv6.conf.all.forwarding=0
                sysctl -w net.ipv6.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable IPv4 and IPv6 forwarding
              hosts: all
              become: true

              tasks:
                - name: Ensure IPv4 and IPv6 forwarding is disabled in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-ip-forwarding.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.ip_forward', value: '0' }
                    - { name: 'net.ipv6.conf.all.forwarding', value: '0' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
                    - { name: 'net.ipv6.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable IP forwarding.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv4.ip_forward
            if grep -q '^net.ipv4.ip_forward' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.ip_forward to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.ip_forward.*/net.ipv4.ip_forward = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.ip_forward to 0 in /etc/sysctl.d/99-disable-ip-forwarding.conf"
              echo "net.ipv4.ip_forward = 0" >> /etc/sysctl.d/99-disable-ip-forwarding.conf
            fi

            # Set net.ipv6.conf.all.forwarding
            if grep -q '^net.ipv6.conf.all.forwarding' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.all.forwarding to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.all.forwarding.*/net.ipv6.conf.all.forwarding = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.all.forwarding to 0 in /etc/sysctl.d/99-disable-ip-forwarding.conf"
              echo "net.ipv6.conf.all.forwarding = 0" >> /etc/sysctl.d/99-disable-ip-forwarding.conf
            fi

            sysctl -w net.ipv4.ip_forward=0
            sysctl -w net.ipv4.route.flush=1

            sysctl -w net.ipv6.conf.all.forwarding=0
            sysctl -w net.ipv6.route.flush=1
            ```
  - uid: mondoo-linux-security-packet-redirect-sending-is-disabled
    title: Ensure packet redirect sending is disabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.send_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.send_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.send_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.send_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to not send ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.send_redirects` and `net.ipv4.conf.default.send_redirects` are set to `0`.

        **Why this matters**

        ICMP redirect messages are used by routers to inform hosts of a more efficient route for reaching a destination. However, on systems that are not functioning as routers, this feature is unnecessary and can introduce security risks.

        If packet redirect sending is enabled:
          - The system could inadvertently influence the routing behavior of other devices on the network.
          - Malicious actors could exploit redirect functionality to reroute traffic through compromised or untrusted devices.
          - It increases the complexity and unpredictability of network traffic flow, complicating security monitoring and enforcement.

        Disabling the ability to send ICMP redirects on non-router systems prevents unauthorized route manipulation and supports secure, well-defined network behavior. This reduces the risk of traffic interception or redirection by adversaries.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.conf.all.send_redirects = 0
                net.ipv4.conf.default.send_redirects = 0
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.conf.all.send_redirects=0
                sysctl -w net.ipv4.conf.default.send_redirects=0
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable packet redirect sending
              hosts: all
              become: true

              tasks:
                - name: Ensure packet redirect sending is disabled in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-packet-redirect.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.conf.all.send_redirects', value: '0' }
                    - { name: 'net.ipv4.conf.default.send_redirects', value: '0' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable packet redirect sending.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv4.conf.all.send_redirects
            if grep -q '^net.ipv4.conf.all.send_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.all.send_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.all.send_redirects.*/net.ipv4.conf.all.send_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.all.send_redirects to 0 in /etc/sysctl.d/99-disable-packet-redirect.conf"
              echo "net.ipv4.conf.all.send_redirects = 0" >> /etc/sysctl.d/99-disable-packet-redirect.conf
            fi

            # Set net.ipv4.conf.default.send_redirects
            if grep -q '^net.ipv4.conf.default.send_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.default.send_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.default.send_redirects.*/net.ipv4.conf.default.send_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.default.send_redirects to 0 in /etc/sysctl.d/99-disable-packet-redirect.conf"
              echo "net.ipv4.conf.default.send_redirects = 0" >> /etc/sysctl.d/99-disable-packet-redirect.conf
            fi

            sysctl -w net.ipv4.conf.all.send_redirects=0
            sysctl -w net.ipv4.conf.default.send_redirects=0
            sysctl -w net.ipv4.route.flush=1
            ```
  - uid: mondoo-linux-security-source-routed-packets-are-not-accepted
    title: Ensure source routed packets are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.accept_source_route'] == 0
        || kernel.parameters['net.ipv4.conf.all.accept_source_route'] == null
      kernel.parameters['net.ipv4.conf.default.accept_source_route'] == 0
        || kernel.parameters['net.ipv4.conf.default.accept_source_route'] == null
      kernel.parameters['net.ipv6.conf.all.accept_source_route'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_source_route'] == null
      kernel.parameters['net.ipv6.conf.default.accept_source_route'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_source_route'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject source-routed packets by ensuring the kernel parameters `net.ipv4.conf.all.accept_source_route`, `net.ipv4.conf.default.accept_source_route`, `net.ipv6.conf.all.accept_source_route`, and `net.ipv6.conf.default.accept_source_route` are set to `0`.

        **Why this matters**

        Source routing allows the sender of a packet to specify the exact path it should take through the network. While this feature was designed for network troubleshooting, it is rarely used in modern environments and poses significant security risks.

        If source-routed packets are accepted:
          - Attackers can bypass network routing controls and firewall rules by crafting packets with arbitrary paths.
          - It enables traffic spoofing and man-in-the-middle attacks by redirecting data through attacker-controlled systems.
          - It undermines network segmentation and isolation policies.

        Disabling acceptance of source-routed packets ensures that the system only processes packets routed according to the network's standard path selection, reducing the risk of exploitation and reinforcing a secure network posture.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.conf.all.accept_source_route = 0
                net.ipv4.conf.default.accept_source_route = 0
                net.ipv6.conf.all.accept_source_route = 0
                net.ipv6.conf.default.accept_source_route = 0
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.conf.all.accept_source_route=0
                sysctl -w net.ipv4.conf.default.accept_source_route=0
                sysctl -w net.ipv4.route.flush=1

                sysctl -w net.ipv6.conf.all.accept_source_route=0
                sysctl -w net.ipv6.conf.default.accept_source_route=0
                sysctl -w net.ipv6.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable source routed packets acceptance
              hosts: all
              become: true

              tasks:
                - name: Ensure source routed packets are not accepted in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-source-routing.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.conf.all.accept_source_route', value: '0' }
                    - { name: 'net.ipv4.conf.default.accept_source_route', value: '0' }
                    - { name: 'net.ipv6.conf.all.accept_source_route', value: '0' }
                    - { name: 'net.ipv6.conf.default.accept_source_route', value: '0' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
                    - { name: 'net.ipv6.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable source routed packets acceptance.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv4.conf.all.accept_source_route
            if grep -q '^net.ipv4.conf.all.accept_source_route' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.all.accept_source_route to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.all.accept_source_route.*/net.ipv4.conf.all.accept_source_route = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.all.accept_source_route to 0 in /etc/sysctl.d/99-disable-source-routing.conf"
              echo "net.ipv4.conf.all.accept_source_route = 0" >> /etc/sysctl.d/99-disable-source-routing.conf
            fi

            # Set net.ipv4.conf.default.accept_source_route
            if grep -q '^net.ipv4.conf.default.accept_source_route' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.default.accept_source_route to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.default.accept_source_route.*/net.ipv4.conf.default.accept_source_route = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.default.accept_source_route to 0 in /etc/sysctl.d/99-disable-source-routing.conf"
              echo "net.ipv4.conf.default.accept_source_route = 0" >> /etc/sysctl.d/99-disable-source-routing.conf
            fi

            # Set net.ipv6.conf.all.accept_source_route
            if grep -q '^net.ipv6.conf.all.accept_source_route' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.all.accept_source_route to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.all.accept_source_route.*/net.ipv6.conf.all.accept_source_route = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.all.accept_source_route to 0 in /etc/sysctl.d/99-disable-source-routing.conf"
              echo "net.ipv6.conf.all.accept_source_route = 0" >> /etc/sysctl.d/99-disable-source-routing.conf
            fi

            # Set net.ipv6.conf.default.accept_source_route
            if grep -q '^net.ipv6.conf.default.accept_source_route' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.default.accept_source_route to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.default.accept_source_route.*/net.ipv6.conf.default.accept_source_route = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.default.accept_source_route to 0 in /etc/sysctl.d/99-disable-source-routing.conf"
              echo "net.ipv6.conf.default.accept_source_route = 0" >> /etc/sysctl.d/99-disable-source-routing.conf
            fi

            sysctl -w net.ipv4.conf.all.accept_source_route=0
            sysctl -w net.ipv4.conf.default.accept_source_route=0
            sysctl -w net.ipv4.route.flush=1

            sysctl -w net.ipv6.conf.all.accept_source_route=0
            sysctl -w net.ipv6.conf.default.accept_source_route=0
            sysctl -w net.ipv6.route.flush=1
            ```
  - uid: mondoo-linux-security-icmp-redirects-are-not-accepted
    title: Ensure ICMP redirects are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.accept_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.accept_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.accept_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.accept_redirects'] == null
      kernel.parameters['net.ipv6.conf.all.accept_redirects'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_redirects'] == null
      kernel.parameters['net.ipv6.conf.default.accept_redirects'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.accept_redirects`, `net.ipv4.conf.default.accept_redirects`, `net.ipv6.conf.all.accept_redirects`, and `net.ipv6.conf.default.accept_redirects` are set to `0`.

        **Why this matters**

        ICMP redirect messages are used by routers to inform hosts of a better route for reaching a destination. While intended to optimize network traffic, accepting these messages on non-router systems can introduce serious security risks.

        If ICMP redirects are accepted:
          - Attackers can exploit this to alter the routing table of a host, redirecting traffic through malicious devices.
          - It creates opportunities for man-in-the-middle attacks, traffic interception, or denial-of-service.
          - It makes network traffic paths unpredictable and harder to audit or monitor effectively.

        Disabling ICMP redirect acceptance ensures that the system maintains static and trusted routing behavior, helping to preserve network integrity and defend against unauthorized routing changes.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.conf.all.accept_redirects = 0
                net.ipv4.conf.default.accept_redirects = 0
                net.ipv6.conf.all.accept_redirects = 0
                net.ipv6.conf.default.accept_redirects = 0
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.conf.all.accept_redirects=0
                sysctl -w net.ipv4.conf.default.accept_redirects=0
                sysctl -w net.ipv4.route.flush=1

                sysctl -w net.ipv6.conf.all.accept_redirects=0
                sysctl -w net.ipv6.conf.default.accept_redirects=0
                sysctl -w net.ipv6.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable ICMP redirects acceptance
              hosts: all
              become: true

              tasks:
                - name: Ensure ICMP redirects are not accepted in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-icmp-redirects.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.conf.all.accept_redirects', value: '0' }
                    - { name: 'net.ipv4.conf.default.accept_redirects', value: '0' }
                    - { name: 'net.ipv6.conf.all.accept_redirects', value: '0' }
                    - { name: 'net.ipv6.conf.default.accept_redirects', value: '0' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
                    - { name: 'net.ipv6.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable ICMP redirects acceptance.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv4.conf.all.accept_redirects
            if grep -q '^net.ipv4.conf.all.accept_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.all.accept_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.all.accept_redirects.*/net.ipv4.conf.all.accept_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.all.accept_redirects to 0 in /etc/sysctl.d/99-disable-icmp-redirects.conf"
              echo "net.ipv4.conf.all.accept_redirects = 0" >> /etc/sysctl.d/99-disable-icmp-redirects.conf
            fi

            # Set net.ipv4.conf.default.accept_redirects
            if grep -q '^net.ipv4.conf.default.accept_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.default.accept_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.default.accept_redirects.*/net.ipv4.conf.default.accept_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.default.accept_redirects to 0 in /etc/sysctl.d/99-disable-icmp-redirects.conf"
              echo "net.ipv4.conf.default.accept_redirects = 0" >> /etc/sysctl.d/99-disable-icmp-redirects.conf
            fi

            # Set net.ipv6.conf.all.accept_redirects
            if grep -q '^net.ipv6.conf.all.accept_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.all.accept_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.all.accept_redirects.*/net.ipv6.conf.all.accept_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.all.accept_redirects to 0 in /etc/sysctl.d/99-disable-icmp-redirects.conf"
              echo "net.ipv6.conf.all.accept_redirects = 0" >> /etc/sysctl.d/99-disable-icmp-redirects.conf
            fi

            # Set net.ipv6.conf.default.accept_redirects
            if grep -q '^net.ipv6.conf.default.accept_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.default.accept_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.default.accept_redirects.*/net.ipv6.conf.default.accept_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.default.accept_redirects to 0 in /etc/sysctl.d/99-disable-icmp-redirects.conf"
              echo "net.ipv6.conf.default.accept_redirects = 0" >> /etc/sysctl.d/99-disable-icmp-redirects.conf
            fi

            sysctl -w net.ipv4.conf.all.accept_redirects=0
            sysctl -w net.ipv4.conf.default.accept_redirects=0
            sysctl -w net.ipv4.route.flush=1
            sysctl -w net.ipv6.conf.all.accept_redirects=0
            sysctl -w net.ipv6.conf.default.accept_redirects=0
            sysctl -w net.ipv6.route.flush=1
            ```
  - uid: mondoo-linux-security-secure-icmp-redirects-are-not-accepted
    title: Ensure secure ICMP redirects are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.secure_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.secure_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.secure_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.secure_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject secure ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.secure_redirects` and `net.ipv4.conf.default.secure_redirects` are set to `0`.

        **Why this matters**

        Secure ICMP redirects are a variant of ICMP redirect messages that are accepted only from gateways listed in the system's default gateway table. While they are intended to provide safer route optimization, accepting any form of redirect introduces risk by allowing remote influence over local routing decisions.

        If secure ICMP redirects are accepted:
          - An attacker controlling or spoofing a default gateway could influence traffic paths.
          - It increases the likelihood of man-in-the-middle attacks by rerouting data through malicious intermediaries.
          - It undermines the reliability of static routing configurations and may conflict with security controls or monitoring systems.

        Disabling acceptance of secure ICMP redirects ensures that routing updates are not accepted dynamically from potentially compromised gateways. This strengthens network security by enforcing a more predictable and tightly controlled routing posture.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.conf.all.secure_redirects = 0
                net.ipv4.conf.default.secure_redirects = 0
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.conf.all.secure_redirects=0
                sysctl -w net.ipv4.conf.default.secure_redirects=0
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable secure ICMP redirects acceptance
              hosts: all
              become: true

              tasks:
                - name: Ensure secure ICMP redirects are not accepted in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-secure-icmp-redirects.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.conf.all.secure_redirects', value: '0' }
                    - { name: 'net.ipv4.conf.default.secure_redirects', value: '0' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable secure ICMP redirects acceptance and persist the settings.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv4.conf.all.secure_redirects
            if grep -q '^net.ipv4.conf.all.secure_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.all.secure_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.all.secure_redirects.*/net.ipv4.conf.all.secure_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.all.secure_redirects to 0 in /etc/sysctl.d/99-disable-secure-icmp-redirects.conf"
              echo "net.ipv4.conf.all.secure_redirects = 0" >> /etc/sysctl.d/99-disable-secure-icmp-redirects.conf
            fi

            # Set net.ipv4.conf.default.secure_redirects
            if grep -q '^net.ipv4.conf.default.secure_redirects' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.default.secure_redirects to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.default.secure_redirects.*/net.ipv4.conf.default.secure_redirects = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.default.secure_redirects to 0 in /etc/sysctl.d/99-disable-secure-icmp-redirects.conf"
              echo "net.ipv4.conf.default.secure_redirects = 0" >> /etc/sysctl.d/99-disable-secure-icmp-redirects.conf
            fi

            sysctl -w net.ipv4.conf.all.secure_redirects=0
            sysctl -w net.ipv4.conf.default.secure_redirects=0
            sysctl -w net.ipv4.route.flush=1

            sysctl -w net.ipv6.conf.all.secure_redirects=0
            sysctl -w net.ipv6.conf.default.secure_redirects=0
            sysctl -w net.ipv6.route.flush=1
            ```
  - uid: mondoo-linux-security-suspicious-packets-are-logged
    title: Ensure suspicious packets are logged
    impact: 60
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.log_martians'] == 1
      kernel.parameters['net.ipv4.conf.default.log_martians'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to log suspicious or malformed packets by ensuring the kernel parameters `net.ipv4.conf.all.log_martians` and `net.ipv4.conf.default.log_martians` are set to `1`.

        **Why this matters**

        Martian packets are packets with impossible or invalid source addresses, such as those that should not appear on the public internet or within specific segments of a private network. Logging these packets helps administrators detect potential misconfigurations or malicious activity, such as spoofed traffic or scanning attempts.

        If logging of suspicious packets is not enabled:
          - Unusual or invalid network traffic may go undetected, reducing visibility into potential reconnaissance or attack attempts.
          - Misconfigured hosts or routing issues may persist without notice, leading to degraded performance or security gaps.
          - Incident response and forensic analysis capabilities are weakened due to lack of log data.

        Enabling logging for martian packets provides valuable insights into unusual traffic patterns and supports early detection of threats or misconfigurations. This improves network observability and supports a proactive security posture.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.conf.all.log_martians = 1
                net.ipv4.conf.default.log_martians = 1
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.conf.all.log_martians=1
                sysctl -w net.ipv4.conf.default.log_martians=1
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Enable logging of suspicious packets
              hosts: all
              become: true

              tasks:
                - name: Ensure suspicious packets are logged in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-log-suspicious-packets.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.conf.all.log_martians', value: '1' }
                    - { name: 'net.ipv4.conf.default.log_martians', value: '1' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to enable logging of suspicious packets.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^net.ipv4.conf.all.log_martians' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.all.log_martians to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.all.log_martians.*/net.ipv4.conf.all.log_martians = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.all.log_martians to 1 in /etc/sysctl.d/99-log-martians.conf"
              echo "net.ipv4.conf.all.log_martians = 1" >> /etc/sysctl.d/99-log-martians.conf
            fi

            if grep -q '^net.ipv4.conf.default.log_martians' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.default.log_martians to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.default.log_martians.*/net.ipv4.conf.default.log_martians = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.default.log_martians to 1 in /etc/sysctl.d/99-log-martians.conf"
              echo "net.ipv4.conf.default.log_martians = 1" >> /etc/sysctl.d/99-log-martians.conf
            fi

            sysctl -w net.ipv4.conf.all.log_martians=1
            sysctl -w net.ipv4.conf.default.log_martians=1
            sysctl -w net.ipv4.route.flush=1
            ```
  - uid: mondoo-linux-security-broadcast-icmp-requests-are-ignored
    title: Ensure broadcast ICMP requests are ignored
    impact: 60
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.icmp_echo_ignore_broadcasts'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to ignore ICMP echo requests sent to broadcast or multicast addresses by ensuring the kernel parameter `net.ipv4.icmp_echo_ignore_broadcasts` is set to `1`.

        **Why this matters**

        ICMP echo requests sent to broadcast addresses can be used in amplification attacks, such as the Smurf attack, where a single ICMP request can generate a large volume of responses from multiple hosts. This can lead to denial-of-service conditions for targeted systems or network segments.

        If broadcast ICMP requests are not ignored:
          - The system may be exploited as part of a distributed denial-of-service (DDoS) attack.
          - Network resources may be consumed by processing and responding to unnecessary or malicious requests.
          - Attackers can use broadcast ICMP traffic to map networks or identify live hosts.

        Ignoring broadcast ICMP requests reduces the likelihood that the system can be leveraged in amplification attacks and helps maintain the integrity and availability of the network. This is particularly important in environments where network resources are limited or where systems are exposed to untrusted networks.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.icmp_echo_ignore_broadcasts = 1
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable ICMP echo broadcasts
              hosts: all
              become: true

              tasks:
                - name: Ensure ICMP echo broadcasts are ignored in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-icmp-echo-broadcasts.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.icmp_echo_ignore_broadcasts', value: '1' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable ICMP echo broadcasts.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^net.ipv4.icmp_echo_ignore_broadcasts' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.icmp_echo_ignore_broadcasts to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.icmp_echo_ignore_broadcasts.*/net.ipv4.icmp_echo_ignore_broadcasts = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.icmp_echo_ignore_broadcasts to 1 in /etc/sysctl.d/99-disable-icmp-echo-broadcasts.conf"
              echo "net.ipv4.icmp_echo_ignore_broadcasts = 1" >> /etc/sysctl.d/99-disable-icmp-echo-broadcasts.conf
            fi

            sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
            sysctl -w net.ipv4.route.flush=1
            ```
  - uid: mondoo-linux-security-bogus-icmp-responses-are-ignored
    title: Ensure bogus ICMP responses are ignored
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.icmp_ignore_bogus_error_responses'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to ignore bogus ICMP error responses by ensuring the kernel parameter `net.ipv4.icmp_ignore_bogus_error_responses` is set to `1`.

        **Why this matters**

        Bogus ICMP error responses are non-compliant or malformed ICMP messages that do not correspond to any legitimate traffic. These can be generated accidentally by misconfigured devices or intentionally by attackers attempting to disrupt or confuse network communications.

        If bogus ICMP responses are not ignored:
          - The system may log unnecessary or misleading error messages, cluttering logs and making it harder to identify real issues.
          - Attackers may exploit this setting to flood logs or trigger unstable behavior in poorly configured systems.
          - It may lead to resource exhaustion or degradation of network performance in environments with high volumes of invalid traffic.

        By ignoring bogus ICMP error responses, the system avoids reacting to malformed or irrelevant network messages, helping to maintain cleaner logs and more stable network operations.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.icmp_ignore_bogus_error_responses = 1
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable bogus ICMP responses
              hosts: all
              become: true

              tasks:
                - name: Ensure bogus ICMP responses are ignored in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-bogus-icmp-responses.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.icmp_ignore_bogus_error_responses', value: '1' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable bogus ICMP responses and persist the setting.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^net.ipv4.icmp_ignore_bogus_error_responses' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.icmp_ignore_bogus_error_responses to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.icmp_ignore_bogus_error_responses.*/net.ipv4.icmp_ignore_bogus_error_responses = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.icmp_ignore_bogus_error_responses to 1 in /etc/sysctl.d/99-disable-bogus-icmp-responses.conf"
              echo "net.ipv4.icmp_ignore_bogus_error_responses = 1" >> /etc/sysctl.d/99-disable-bogus-icmp-responses.conf
            fi

            sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
            sysctl -w net.ipv4.route.flush=1
            ```
  - uid: mondoo-linux-security-reverse-path-filtering-is-enabled
    title: Ensure Reverse Path Filtering is enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.rp_filter'] == 1
      kernel.parameters['net.ipv4.conf.default.rp_filter'] == 1
    docs:
      desc: |
        This check verifies that reverse path filtering is active by ensuring the kernel parameters `net.ipv4.conf.all.rp_filter` and `net.ipv4.conf.default.rp_filter` are set to `1`.

        **Why this matters**

        Reverse Path Filtering is a security mechanism that helps prevent IP spoofing by verifying that the source of a packet has a valid route back to the receiving interface. If a packet arrives on an interface and the system would not use that same interface to reach the source IP, the packet is dropped.

        If reverse path filtering is not enabled:
          - Spoofed packets with forged source addresses may be accepted, allowing attackers to bypass basic network controls.
          - Systems may become vulnerable to reflection and amplification attacks.
          - It undermines the reliability of source-based filtering and complicates network traffic analysis.

        Enabling reverse path filtering ensures the system performs sanity checks on incoming traffic, which helps prevent IP spoofing and enhances the integrity of network communications. It is an important safeguard in both perimeter and internal network environments.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.conf.all.rp_filter = 1
                net.ipv4.conf.default.rp_filter = 1
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.conf.all.rp_filter=1
                sysctl -w net.ipv4.conf.default.rp_filter=1
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Enable Reverse Path Filtering
              hosts: all
              become: true

              tasks:
                - name: Ensure Reverse Path Filtering is enabled in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-enable-reverse-path-filtering.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.conf.all.rp_filter', value: '1' }
                    - { name: 'net.ipv4.conf.default.rp_filter', value: '1' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to enable reverse path filtering and persist the settings.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^net.ipv4.conf.all.rp_filter' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.all.rp_filter to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.all.rp_filter.*/net.ipv4.conf.all.rp_filter = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.all.rp_filter to 1 in /etc/sysctl.d/99-enable-reverse-path-filtering.conf"
              echo "net.ipv4.conf.all.rp_filter = 1" >> /etc/sysctl.d/99-enable-reverse-path-filtering.conf
            fi

            if grep -q '^net.ipv4.conf.default.rp_filter' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.conf.default.rp_filter to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.conf.default.rp_filter.*/net.ipv4.conf.default.rp_filter = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.conf.default.rp_filter to 1 in /etc/sysctl.d/99-enable-reverse-path-filtering.conf"
              echo "net.ipv4.conf.default.rp_filter = 1" >> /etc/sysctl.d/99-enable-reverse-path-filtering.conf
            fi

            sysctl -w net.ipv4.conf.all.rp_filter=1
            sysctl -w net.ipv4.conf.default.rp_filter=1
            sysctl -w net.ipv4.route.flush=1
            ```
  - uid: mondoo-linux-security-tcp-syn-cookies-is-enabled
    title: Ensure TCP SYN Cookies is enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.tcp_syncookies'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to use TCP SYN cookies by ensuring the kernel parameter `net.ipv4.tcp_syncookies` is set to `1`.

        **Why this matters**

        TCP SYN cookies are a defense mechanism against SYN flood attacks, a type of denial-of-service (DoS) attack where an attacker sends a large number of TCP connection requests without completing the handshake. This consumes server resources and can prevent legitimate users from establishing connections.

        When SYN cookies are enabled:
          - The system avoids allocating memory for incomplete TCP handshakes by encoding connection information into the TCP sequence number.
          - It allows the server to continue responding to new connection requests even when the SYN backlog is full.
          - It helps maintain availability and resilience under high connection request loads or malicious activity.

        Without SYN cookies, systems are more susceptible to resource exhaustion during a SYN flood. Enabling this feature strengthens the host's ability to withstand network-based denial-of-service attempts and helps ensure reliable TCP service availability.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv4.tcp_syncookies = 1
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv4.tcp_syncookies=1
                sysctl -w net.ipv4.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Enable TCP SYN Cookies
              hosts: all
              become: true

              tasks:
                - name: Ensure TCP SYN Cookies is enabled in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-enable-tcp-syncookies.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.tcp_syncookies', value: '1' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to enable TCP SYN Cookies and persist the setting.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv4.tcp_syncookies
            if grep -q '^net.ipv4.tcp_syncookies' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.tcp_syncookies to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.tcp_syncookies.*/net.ipv4.tcp_syncookies = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.tcp_syncookies to 1 in /etc/sysctl.d/99-enable-tcp-syncookies.conf"
              echo "net.ipv4.tcp_syncookies = 1" >> /etc/sysctl.d/99-enable-tcp-syncookies.conf
            fi

            # Set net.ipv4.route.flush
            if grep -q '^net.ipv4.route.flush' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv4.route.flush to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv4.route.flush.*/net.ipv4.route.flush = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv4.route.flush to 1 in /etc/sysctl.d/99-enable-tcp-syncookies.conf"
              echo "net.ipv4.route.flush = 1" >> /etc/sysctl.d/99-enable-tcp-syncookies.conf
            fi

            sysctl -w net.ipv4.tcp_syncookies=1
            sysctl -w net.ipv4.route.flush=1
            ```
  - uid: mondoo-linux-security-ipv6-router-advertisements-are-not-accepted
    title: Ensure IPv6 router advertisements are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv6.conf.all.accept_ra'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_ra'] == null
      kernel.parameters['net.ipv6.conf.default.accept_ra'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_ra'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject IPv6 router advertisements by ensuring the kernel parameters `net.ipv6.conf.all.accept_ra` and `net.ipv6.conf.default.accept_ra` are set to `0`.

        **Why this matters**

        IPv6 router advertisements (RAs) are used by routers to inform hosts about network configuration settings, such as default gateways and prefix information. While useful in dynamic network environments, accepting unsolicited RAs on systems that are not mobile or router-dependent can introduce security risks.

        If IPv6 router advertisements are accepted:
          - Malicious or misconfigured devices on the network could inject rogue RAs, redirecting traffic or altering host routing tables.
          - Attackers could exploit this to perform man-in-the-middle attacks, traffic interception, or denial-of-service.
          - It undermines predictable network configuration and may conflict with security policies that rely on static or managed routing.

        Disabling acceptance of IPv6 router advertisements helps ensure that routing configuration is controlled explicitly, reducing the likelihood of unauthorized or harmful route changes on the host.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

                ```
                net.ipv6.conf.all.accept_ra = 0
                net.ipv6.conf.default.accept_ra = 0
                ```

            2. Run these commands to set the active kernel parameters:

                ```bash
                sysctl -w net.ipv6.conf.all.accept_ra=0
                sysctl -w net.ipv6.conf.default.accept_ra=0
                sysctl -w net.ipv6.route.flush=1
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable IPv6 router advertisements acceptance
              hosts: all
              become: true

              tasks:
                - name: Ensure IPv6 router advertisements are not accepted in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf
                    state: present
                    sysctl_set: true
                    reload: yes
                  loop:
                    - { name: 'net.ipv6.conf.all.accept_ra', value: '0' }
                    - { name: 'net.ipv6.conf.default.accept_ra', value: '0' }
                    - { name: 'net.ipv6.route.flush', value: '1' }
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to disable IPv6 router advertisements acceptance and persist the settings.

            ```bash
            #!/bin/bash
            set -e

            # Set net.ipv6.conf.all.accept_ra
            if grep -q '^net.ipv6.conf.all.accept_ra' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.all.accept_ra to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.all.accept_ra.*/net.ipv6.conf.all.accept_ra = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.all.accept_ra to 0 in /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf"
              echo "net.ipv6.conf.all.accept_ra = 0" >> /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf
            fi

            # Set net.ipv6.conf.default.accept_ra
            if grep -q '^net.ipv6.conf.default.accept_ra' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.conf.default.accept_ra to 0 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.conf.default.accept_ra.*/net.ipv6.conf.default.accept_ra = 0/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.conf.default.accept_ra to 0 in /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf"
              echo "net.ipv6.conf.default.accept_ra = 0" >> /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf
            fi

            # Set net.ipv6.route.flush
            if grep -q '^net.ipv6.route.flush' /etc/sysctl.conf 2>/dev/null; then
              echo "Setting net.ipv6.route.flush to 1 in /etc/sysctl.conf"
              sed -i 's/^net.ipv6.route.flush.*/net.ipv6.route.flush = 1/' /etc/sysctl.conf
            else
              echo "Setting net.ipv6.route.flush to 1 in /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf"
              echo "net.ipv6.route.flush = 1" >> /etc/sysctl.d/99-disable-ipv6-router-advertisements.conf
            fi

            sysctl -w net.ipv6.conf.all.accept_ra=0
            sysctl -w net.ipv6.conf.default.accept_ra=0
            sysctl -w net.ipv6.route.flush=1
            ```
  - uid: mondoo-linux-security-auditd-is-installed-and-running
    title: Ensure auditd is installed, enabled, and running
    impact: 50
    mql: |
      package("auditd").installed && package("audispd-plugins").installed
      || package("audit").installed || package("audit-libs").installed
      service("auditd").enabled
      service("auditd").running
    docs:
      desc: |
        This check verifies that the auditd package is installed on the system and that the auditd service is both enabled and running.

        **Why this matters**

        auditd is the core component of the Linux Auditing System, responsible for collecting, processing, and writing audit records to disk. These records provide detailed visibility into system-level activities such as user logins, file access, command execution, and permission changes.

        Ensuring that auditd is installed and actively running is essential for:
          - Capturing a reliable audit trail of security-relevant events.
          - Supporting forensic investigations and incident response efforts.
          - Meeting regulatory and organizational compliance requirements that mandate audit logging.
          - Detecting suspicious or unauthorized behavior on the system in near real time.

        If auditd is not installed, or if the service is disabled or inactive:
          - No audit logs will be recorded, creating blind spots in system monitoring.
          - Critical evidence may be lost during or after an attack.
          - The system may fall out of compliance with standards that require audit functionality.

        By installing and enabling auditd, organizations ensure consistent audit logging is in place, improving accountability and strengthening overall system security.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Install the auditd package:

                **RHEL/Fedora/Amazon Linux and derivatives**

                ```bash
                dnf install audit audit-libs
                ```

                **Debian/Ubuntu and derivatives**

                ```bash
                apt-get install auditd audispd-plugins
                ```

                **SLES and openSUSE**

                ```bash
                zypper install audit
                ```

            2. Enable and start the auditd service:

                ```bash
                systemctl --now enable auditd
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to ensure auditd is installed, enabled, and running:

            ```yaml
            ---
            - name: Ensure auditd is installed and running
              hosts: all
              become: true

              tasks:
                - name: Install auditd on RHEL/Fedora/Amazon Linux
                  package:
                    name:
                      - audit
                      - audit-libs
                    state: present
                  when: ansible_facts['os_family'] == "RedHat"

                - name: Install auditd on Debian/Ubuntu
                  package:
                    name:
                      - auditd
                      - audispd-plugins
                    state: present
                  when: ansible_facts['os_family'] == "Debian"

                - name: Install auditd on SLES/openSUSE
                  package:
                    name: audit
                    state: present
                  when: ansible_facts['os_family'] == "Suse"

                - name: Enable and start auditd service
                  systemd:
                    name: auditd
                    enabled: yes
                    state: started
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to install auditd, enable it, and start the service.

            ```bash
            #!/bin/bash
            set -e

            echo "Installing auditd..."
            if command -v dnf &> /dev/null; then
              dnf install -y audit audit-libs
            elif command -v apt-get &> /dev/null; then
              apt-get install -y auditd audispd-plugins
            elif command -v zypper &> /dev/null; then
              zypper install -y audit
            else
              echo "Unsupported package manager. Please install auditd manually."
              exit 1
            fi

            echo "Enabling and starting auditd service..."
            systemctl --now enable auditd
            ```
  - uid: mondoo-linux-security-auditing-for-processes-that-start-prior-to-auditd-is-enabled
    title: Ensure auditing for processes that start prior to auditd is enabled
    impact: 50
    mql: |
      switch {
        case file("/boot/grub2/grubenv").exists:
          file("/boot/grub2/grubenv").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub2/grub.cfg").exists:
          file("/boot/grub2/grub.cfg").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub/grub.cfg").exists:
          file("/boot/grub/grub.cfg").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub/grub.conf").exists:
          file("/boot/grub/grub.conf").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/etc/secboot/config.json").exists:
          parse.json('/etc/secboot/config.json')
            .params['kernel-params'] == /audit(\s+)?\=(\s+)?1/;
        default: false
      }
    docs:
      desc: |
        This check verifies that the system's GRUB bootloader is configured to pass the audit=1 kernel parameter, which ensures that auditing is enabled from the earliest stages of system initialization—even before the auditd daemon starts.

        **Why this matters**

        By default, some processes may start before auditd is initialized, especially during early boot. Without early auditing enabled, actions taken by these processes can go unrecorded, creating a blind spot in audit logs and weakening the system's ability to track critical events.

        If the audit=1 kernel parameter is not set:
          - Early-boot processes such as init systems, kernel modules, or startup scripts may execute without being logged.
          - Attackers or misconfigurations could exploit this window to perform actions undetected.
          - The system's audit trail may be incomplete, undermining trust in audit data and complicating incident response or compliance reviews.

        Adding audit=1 to the GRUB configuration ensures that the Linux kernel begins generating audit records as soon as it starts, capturing all auditable activity regardless of when auditd is fully initialized. This enhances the completeness and integrity of audit logging across the system lifecycle.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Edit the GRUB configuration file at `/etc/default/grub` to include the `audit=1` parameter in addition to any previous values it may have:

                ```bash
                GRUB_CMDLINE_LINUX_DEFAULT="audit=1"
                ```

            2. Update the GRUB configuration:

                **RHEL/Fedora/Amazon Linux and derivatives**

                For BIOS systems:

                ```bash
                grub2-mkconfig -o /boot/grub2/grub.cfg
                ```

                For UEFI systems:

                ```bash
                grub2-mkconfig -o /boot/efi/EFI/<distribution>/grub.cfg
                ```

                Replace `<distribution>` with your distribution's directory name (e.g., `centos`, `redhat`, `fedora`).

                **Debian/Ubuntu and derivatives**

                ```bash
                update-grub
                ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure the audit=1 parameter is set in the GRUB configuration.

            ```bash
            #!/bin/bash
            set -e

            EFI_DIR="/boot/efi/EFI"

            # Check if GRUB configuration file exists
            if [ -f /etc/default/grub ]; then
              if grep -q "audit=1" /etc/default/grub; then
                echo "audit=1 is already set in GRUB configuration."
              else
                echo "Setting audit=1 in GRUB configuration."
                sed -i 's/GRUB_CMDLINE_LINUX="/GRUB_CMDLINE_LINUX="audit=1 /' /etc/default/grub
              fi
            fi

            if command -v update-grub >/dev/null 2>&1; then
              echo "Running update-grub"
              update-grub
            elif [ -d "$EFI_DIR" ]; then
              echo "EFI directory found at $EFI_DIR. Updating any grub.cfg files under it."
              find "$EFI_DIR" -type f -name "grub.cfg" -exec grub2-mkconfig -o {} \;
            else
              echo "Running grub2-mkconfig for BIOS install"
              grub2-mkconfig -o /boot/grub2/grub.cfg
            fi
            ```
  - uid: mondoo-linux-security-audit-log-storage-size-is-configured
    title: Ensure audit log storage size is configured
    impact: 40
    mql: |
      file("/etc/audit/auditd.conf").exists
      auditd.config.params.contains("max_log_file")
      auditd.config.params.max_log_file != 0
    docs:
      desc: |
        This check verifies that the auditd configuration specifies a maximum storage size for audit logs by ensuring the `max_log_file` parameter in `/etc/audit/auditd.conf` is set to a value greater than zero.

        **Why this matters**

        The `max_log_file` setting defines the maximum size (in megabytes) that an audit log file can grow before it is rotated. Without this limit, audit logs can consume excessive disk space, leading to system performance degradation or failures—especially on systems with limited storage or extensive auditing.

        If audit log size is not properly configured:
          - Log files may grow indefinitely and fill the disk, potentially causing services to fail or the system to become unresponsive.
          - Critical audit data may be lost if the system cannot write to a full disk.
          - Administrators may be unaware of abnormal log volume trends, missing opportunities for early detection of suspicious activity.

        Configuring max_log_file helps maintain system stability by preventing uncontrolled log growth. It also supports log management practices such as automated rotation and retention policies, ensuring that audit data remains available without jeopardizing system operations.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameter in `/etc/audit/auditd.conf` in accordance with site policy:

                ```
                max_log_file = <MB>
                ```

            2. Restart the auditd service to apply the new configuration:

                ```bash
                systemctl restart auditd
                ```

            3. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the maximum log file size for audit logs:

            ```yaml
            ---
            - name: Configure audit log storage size
              hosts: all
              become: true

              tasks:
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Ensure audit log storage size is configured in auditd.conf
                  ansible.builtin.lineinfile:
                    path: /etc/audit/auditd.conf
                    regexp: '^max_log_file ='
                    line: 'max_log_file = <MB>'
                    create: yes
                    state: present
                  register: auditd_logsize_changed

                - name: Restart auditd service to apply changes if not immutable
                  ansible.builtin.systemd:
                    name: auditd
                    state: restarted
                  when:
                    - immutable_check.rc != 0
                    - auditd_logsize_changed.changed

                - name: Warn if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to configure the maximum log file size for audit logs.

            ```bash
            #!/bin/bash
            set -e

            MB_SIZE="500"  # Replace 500 with the desired size in megabytes

            if grep -q '^max_log_file' /etc/audit/auditd.conf; then
              echo "Updating max_log_file to $MB_SIZE in /etc/audit/auditd.conf"
              sed -i "s/^max_log_file.*/max_log_file = $MB_SIZE/" /etc/audit/auditd.conf
            else
              echo "Adding max_log_file = $MB_SIZE to /etc/audit/auditd.conf"
              echo "max_log_file = $MB_SIZE" >> /etc/audit/auditd.conf
            fi

            echo "Restarting auditd service to apply changes"
            systemctl restart auditd

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-audit-logs-are-not-automatically-deleted
    title: Ensure audit logs are not automatically deleted
    impact: 40
    mql: |
      file("/etc/audit/auditd.conf").exists
      auditd.config.params.max_log_file_action == "keep_logs"
    docs:
      desc: |
        This check verifies that the system is configured to retain audit logs by ensuring the `max_log_file_action` parameter in `/etc/audit/auditd.conf`` is set to `keep_logs`.

        **Why this matters**

        The `max_log_file_action` setting controls how auditd behaves when an audit log file reaches its maximum size. Setting it to keep_logs ensures that old logs are preserved rather than deleted or overwritten, supporting long-term retention and forensic traceability.

        If audit logs are automatically deleted:
          - Critical historical data may be lost, undermining the ability to investigate past events or security incidents.
          - Organizations may fall out of compliance with regulatory requirements that mandate audit log retention.
          - Incident response efforts may be hindered by incomplete log records.

        By configuring auditd to preserve logs, the system ensures that valuable audit data is available when needed for security analysis, compliance reviews, or legal investigation. This supports a more robust and accountable auditing strategy.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameter in `/etc/audit/auditd.conf`:

                ```
                max_log_file_action = keep_logs
                ```

            2. Restart the service to load the new configuration values:

                ```bash
                systemctl restart auditd
                ```

            3. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the maximum log file action for audit logs:

            ```yaml
            ---
            - name: Configure audit log file action
              hosts: all
              become: true

              tasks:
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                  auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Ensure audit log file action is configured in auditd.conf
                  ansible.builtin.lineinfile:
                    path: /etc/audit/auditd.conf
                    regexp: '^max_log_file_action ='
                    line: 'max_log_file_action = keep_logs'
                    create: yes
                    state: present
                    register: auditd_logfile_action_changed

                - name: Restart auditd service to apply changes if not immutable
                  ansible.builtin.systemd:
                    name: auditd
                    state: restarted
                    when:
                    - immutable_check.rc != 0
                    - auditd_logfile_action_changed.changed

                - name: Warn if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                    when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**
            Use this Bash script to configure the maximum log file action for audit logs.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^max_log_file_action' /etc/audit/auditd.conf; then
              echo "Updating max_log_file_action to keep_logs in /etc/audit/auditd.conf"
              sed -i 's/^max_log_file_action.*/max_log_file_action = keep_logs/' /etc/audit/auditd.conf
            else
              echo "Adding max_log_file_action = keep_logs to /etc/audit/auditd.conf"
              echo "max_log_file_action = keep_logs" >> /etc/audit/auditd.conf
            fi

            echo "Restarting auditd service to apply changes"
            systemctl restart auditd

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-system-is-disabled-when-audit-logs-are-full
    title: Ensure system is disabled when audit logs are full
    impact: 40
    filters: |
      asset.kind != "container-image"
    mql: |
      file("/etc/audit/auditd.conf").exists
      auditd.config.params.space_left_action == /email|exec|single|halt/
      auditd.config.params.action_mail_acct == "root"
      auditd.config.params.admin_space_left_action == /halt|single/
    docs:
      desc: |
        This check verifies that the system is configured to disable itself when audit logs are full by ensuring the `space_left_action` and `admin_space_left_action` parameters in `/etc/audit/auditd.conf` are set to appropriate values.

        **Why this matters**

        The `space_left_action` setting determines what action auditd takes when disk space for audit logs is low. The `admin_space_left_action` setting specifies the action when space is critically low. Setting these to halt or single ensures that the system does not continue operating with potentially compromised logging capabilities.

        If the system does not disable itself when audit logs are full:
          - Crucial audit data may be lost, leading to gaps in security monitoring.
          - The system may continue to operate without proper oversight, increasing the risk of undetected malicious activity.
          - Compliance with regulatory requirements for audit logging may be jeopardized.

        Configuring these parameters helps ensure that the system maintains a secure state and that audit logging remains functional, even under adverse conditions.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            1. Set the following parameters in `/etc/audit/auditd.conf`:

                ```
                space_left_action = email
                action_mail_acct = root
                admin_space_left_action = halt
                ```

            2. Restart the service to load the new configuration values:

                ```bash
                systemctl restart auditd
                ```

            3. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the auditd parameters:

            ```yaml
            ---
            - name: Configure auditd parameters
              hosts: all
              become: true

              tasks:
                - name: Ensure auditd parameters are configured in auditd.conf
                  ansible.builtin.blockinfile:
                    path: /etc/audit/auditd.conf
                    block: |
                      space_left_action = email
                      action_mail_acct = root
                      admin_space_left_action = halt
                    create: yes
                    state: present
                  register: auditd_params_changed

                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Restart auditd service to apply changes if not immutable and config changed
                  ansible.builtin.systemd:
                    name: auditd
                    state: restarted
                  when:
                    - immutable_check.rc != 0
                    - auditd_params_changed.changed

                - name: Warn if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to configure the auditd parameters for handling full audit logs.

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^space_left_action' /etc/audit/auditd.conf; then
              echo "Updating space_left_action to email in /etc/audit/auditd.conf"
              sed -i 's/^space_left_action.*/space_left_action = email/' /etc/audit/auditd.conf
            else
              echo "Adding space_left_action = email to /etc/audit/auditd.conf"
              echo "space_left_action = email" >> /etc/audit/auditd.conf
            fi

            if grep -q '^action_mail_acct' /etc/audit/auditd.conf; then
              echo "Updating action_mail_acct to root in /etc/audit/auditd.conf"
              sed -i 's/^action_mail_acct.*/action_mail_acct = root/' /etc/audit/auditd.conf
            else
              echo "Adding action_mail_acct = root to /etc/audit/auditd.conf"
              echo "action_mail_acct = root" >> /etc/audit/auditd.conf
            fi

            if grep -q '^admin_space_left_action' /etc/audit/auditd.conf; then
              echo "Updating admin_space_left_action to halt in /etc/audit/auditd.conf"
              sed -i 's/^admin_space_left_action.*/admin_space_left_action = halt/' /etc/audit/auditd.conf
            else
              echo "Adding admin_space_left_action = halt to /etc/audit/auditd.conf"
              echo "admin_space_left_action = halt" >> /etc/audit/auditd.conf
            fi

            echo "Restarting auditd service to apply changes"
            systemctl restart auditd

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-changes-to-system-administration-scope-sudoers-is-collected
    title: Ensure changes to system administration scope (sudoers) is audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/sudoers\.d(\/?)\s+\-p\s+wa\s+\-k\s+scope(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/sudoers(\/?)\s+\-p\s+wa\s+\-k\s+scope(\s+)?$/))
    docs:
      desc: |
        This check verifies that auditd is configured to monitor changes to the system administration scope (sudoers). The parameters below track changes to files associated with sudoers.

        - The file `/etc/sudoers` is the main configuration file for sudo.
        - The `/etc/sudoers.d/` directory contains additional configuration files for sudo.

        **Why this matters**

        Monitoring changes to the sudoers file and its associated directory is critical for maintaining system security. Unauthorized modifications can lead to privilege escalation, unauthorized access, or other malicious activities.

        If monitoring is not enabled:
          - Changes to sudo permissions may go undetected, allowing unauthorized users to gain elevated privileges.
          - It becomes difficult to track who made changes and when, complicating incident response efforts.
          - The system may fall out of compliance with security policies or regulatory requirements.

        By ensuring that changes to the sudoers file and directory are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

            Example: `vi /etc/audit/rules.d/50-scope.rules`

            Add the following lines:

            ```
            -w /etc/sudoers -p wa -k scope
            -w /etc/sudoers.d -p wa -k scope
            ```

            To load the newly added rules into the running configuration:

            ```bash
            augenrules --load
            ```

            This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            Check if a reboot is required, in case the running configuration is set to be immutable:

            ```bash
            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for sudoers:

            ```yaml
            ---
            - name: Ensure changes to system administration scope (sudoers) is audited
              hosts: all
              become: true

              tasks:
                - name: Ensure audit rules for sudoers are configured in auditd.conf
                  ansible.builtin.lineinfile:
                    path: /etc/audit/rules.d/50-scope.rules
                    line: |
                      -w /etc/sudoers -p wa -k scope
                      -w /etc/sudoers.d -p wa -k scope
                    create: yes
                    state: present
                - name: Reload auditd service to apply changes
                  ansible.builtin.systemd:
                    name: auditd
                    state: reloaded
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure changes to the sudoers file and directory are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-scope.rules"

            if [ ! -f "$RULES_FILE" ]; then
              echo "Creating audit rules file: $RULES_FILE"
              touch "$RULES_FILE"
            fi

            echo "Ensuring audit rules for sudoers are configured"
            if ! grep -q '^-w /etc/sudoers -p wa -k scope' "$RULES_FILE"; then
              echo "-w /etc/sudoers -p wa -k scope" >> "$RULES_FILE"
            fi
            if ! grep -q '^-w /etc/sudoers.d -p wa -k scope' "$RULES_FILE"; then
              echo "-w /etc/sudoers.d -p wa -k scope" >> "$RULES_FILE"
            fi

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-login-and-logout-events-are-collected
    title: Ensure login and logout events are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    variants:
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-debian
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-rhel
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-other
    docs:
      desc: |
        This check verifies that auditd is configured to monitor login and logout events. The parameters in this section track changes to the files associated with login and logout events. The file `/var/log/lastlog` tracks the last login of each user. The file `/var/log/tallylog` tracks failed login attempts. The file `/var/run/faillock` is used by the `pam_faillock` module to track failed authentication attempts. All audit records will be tagged with the identifier "logins."

        **Why this matters**

        Monitoring login and logout events is critical for maintaining system security. Unauthorized access attempts or successful logins by malicious actors can lead to data breaches, privilege escalation, or other security incidents.

        If monitoring is not enabled:
          - Unauthorized login attempts may go undetected, allowing attackers to gain access to the system.
          - Legitimate user activity may be obscured, complicating incident response efforts.
          - The system may fall out of compliance with security policies or regulatory requirements.

        By ensuring that login and logout events are monitored, organizations can maintain a secure environment and quickly respond to potential threats. This is particularly important in environments with sensitive data or critical infrastructure.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-logins.rules`

            2. Add the following lines to the configuration file:

                ```
                -w /var/log/lastlog -p wa -k logins
                -w /var/log/tallylog -p wa -k logins
                ```

            3. Add the following additional line for Debian/Ubuntu based systems:

                ```
                -w /var/log/faillog -p wa -k logins
                ```

            4. Add the following additional line for Red Hat/Fedora/Amazon Linux based systems:

                ```
                -w /var/run/faillock -p wa -k logins
                ```

            5. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            6. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for login and logout events:

            ```yaml
            ---
            - name: Ensure login and logout events are audited
              hosts: all
              become: true

              tasks:
                - name: Set base login audit rules
                  copy:
                    dest: /etc/audit/rules.d/50-logins.rules
                    content: |
                      -w /var/log/lastlog -p wa -k logins
                      -w /var/log/tallylog -p wa -k logins
                  notify: Load audit rules

                - name: Add Debian/Ubuntu-specific faillog audit rule
                  lineinfile:
                    path: /etc/audit/rules.d/50-logins.rules
                    line: "-w /var/log/faillog -p wa -k logins"
                    create: yes
                    insertafter: EOF
                  when: ansible_os_family == "Debian"
                  notify: Load audit rules

                - name: Add RedHat/Fedora/Amazon-specific faillock audit rule
                  lineinfile:
                    path: /etc/audit/rules.d/50-logins.rules
                    line: "-w /var/run/faillock -p wa -k logins"
                    create: yes
                    insertafter: EOF
                  when: ansible_os_family in ["RedHat", "Amazon"]
                  notify: Load audit rules

                - name: Check if audit rules are immutable
                  shell: |
                    auditctl -s | grep '^enabled' | awk '{print $2}'
                  register: audit_enabled

                - name: Warn if reboot is required to apply immutable audit rules
                  debug:
                    msg: "Reboot required to load audit rules because the configuration is immutable."
                  when: audit_enabled.stdout == "2"

              handlers:
                - name: Load audit rules
                  command: augenrules --load
              ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure login and logout events are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-logins.rules"

            echo "Ensuring audit rules for lastlog and tallylog are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -w /var/log/lastlog -p wa -k logins
            -w /var/log/tallylog -p wa -k logins
            EOF

            if [[ -d /var/log/faillog ]]; then
              echo "Adding auditing for faillog in $RULES_FILE"
              echo "-w /var/log/faillog -p wa -k logins" >> "$RULES_FILE"
            fi

            if [[ -d /var/run/faillock ]]; then
              echo "Adding auditing for faillock in $RULES_FILE"
              echo "-w /var/run/faillock -p wa -k logins" >> "$RULES_FILE"
            fi

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-debian
    filters: asset.family.contains("debian")
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/faillog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/log\/faillog|\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-rhel
    filters: asset.family.contains("redhat") || asset.platform == "amazonlinux"
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/run\/faillock/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/run\/faillock|\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-other
    filters: asset.family.contains(/redhat|debian/) == false && asset.platform != "amazonlinux"
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-session-initiation-information-is-collected
    title: Ensure session initiation information is audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/run\/utmp\s+\-p\s+wa\s+\-k\s+session(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/wtmp\s+\-p\s+wa\s+\-k\s+(logins|session)(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/btmp\s+\-p\s+wa\s+\-k\s+(logins|session)(\s+)?$/))
    docs:
      desc: |
        This check verifies that the system is configured to record session start events in the audit logs, ensuring that audit rules are in place to track successful login sessions using the auditd subsystem.

        **Why this matters**

        Capturing session initiation information—such as user logins and terminal access—is essential for establishing a complete record of user activity. These events mark the beginning of user interactions with the system and provide vital context for analyzing subsequent actions.

        If session initiation is not logged:
          •  User activity cannot be reliably correlated to specific sessions, weakening audit trails.
          •  Security incidents such as unauthorized access or lateral movement may go undetected.
          •  Compliance with security standards and regulatory frameworks that require session logging may be compromised.

        By ensuring session start events are audited, organizations gain visibility into who accessed the system and when, supporting effective monitoring, incident investigation, and user accountability. This forms a foundational element of audit-based security controls.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-session.rules`

            2. Add the following lines to the configuration file:

                ```
                -w /var/run/utmp -p wa -k session
                -w /var/log/wtmp -p wa -k logins
                -w /var/log/btmp -p wa -k logins
                ```

            3. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for session initiation:

            ```yaml
            ---
            - name: Ensure session initiation information is audited
              hosts: all
              become: true

              tasks:
                - name: Set session tracking audit rules
                  copy:
                    dest: /etc/audit/rules.d/50-session.rules
                    content: |
                      -w /var/run/utmp -p wa -k session
                      -w /var/log/wtmp -p wa -k logins
                      -w /var/log/btmp -p wa -k logins
                  notify: Load audit rules

                - name: Check if audit rules are immutable
                  shell: |
                    auditctl -s | grep '^enabled' | awk '{print $2}'
                  register: audit_enabled

                - name: Warn if reboot is required to apply immutable audit rules
                  debug:
                    msg: "Reboot required to load audit rules because the configuration is immutable."
                  when: audit_enabled.stdout == "2"

              handlers:
                - name: Load audit rules
                  command: augenrules --load
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure session initiation information is audited:

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-session.rules"

            echo "Ensuring audit rules for session initiation are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -w /var/run/utmp -p wa -k session
            -w /var/log/wtmp -p wa -k logins
            -w /var/log/btmp -p wa -k logins
            EOF

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-events-that-modify-date-and-time-information-are-collected
    title: Ensure events that modify date and time information are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /settimeofday/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /clock_settime/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /adjtimex/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /settimeofday|clock_settime|adjtimex/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-F", "key=time-change"])
            || split(" ").containsAll(["-k", "time-change"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(/\/etc\/localtime/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(/\/etc\/localtime/).all(
        split("-").containsAll(["w /etc/localtime ","p wa ",])
          && split(" ").containsAll(["-F", "key=time-change"])
            || split(" ").containsAll(["-k", "time-change"])
      )
    docs:
      desc: |
        This check verifies that the audit system is configured to log all events that change the system's date and time settings, including modifications to the system clock and timezone.

        **Why this matters**

        Accurate system time is critical for security auditing, log correlation, and incident investigation. If an attacker or unauthorized user alters the system time, it can obscure malicious activity, disrupt monitoring tools, and compromise the integrity of audit logs.

        If changes to date and time settings are not audited:
          •  Malicious modifications may go unnoticed, allowing attackers to hide their tracks.
          •  Log timestamps may become unreliable, complicating forensic analysis.
          •  Compliance with standards that require time synchronization and audit log integrity may be violated.

        By auditing all date and time modifications, administrators can detect tampering attempts, verify system integrity, and maintain a trustworthy timeline of system events. This ensures that audit logs remain a reliable source of truth during security reviews and investigations.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-time_change.rules`

            2. Add the following lines to the configuration file:

                ```
                -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
                -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
                -a always,exit -F arch=b32 -S clock_settime -k time-change
                -a always,exit -F arch=b64 -S clock_settime -k time-change
                -w /etc/localtime -p wa -k time-change
                ```

            3. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for date and time changes:

            ```yaml
            ---
            - name: Configure audit rules for time change events
              hosts: all
              become: true

              tasks:
                - name: Ensure required time-change audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-time_change.rules
                    block: |
                      -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
                      -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
                      -a always,exit -F arch=b32 -S clock_settime -k time-change
                      -a always,exit -F arch=b64 -S clock_settime -k time-change
                      -w /etc/localtime -p wa -k time-change
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: audit_rules_updated

                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: audit_rules_updated.changed

                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to configure the auditd rules for date and time changes.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-time_change.rules"

            echo "Ensuring audit rules for time changes are configured"
            cat > "$RULES_FILE" <<EOF
            -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
            -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
            -a always,exit -F arch=b32 -S clock_settime -k time-change
            -a always,exit -F arch=b64 -S clock_settime -k time-change
            -w /etc/localtime -p wa -k time-change
            EOF

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-mandatory-access-controls-are-collected
    title: Ensure events that modify the system's Mandatory Access Controls are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      appArmorSys = props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/apparmor(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
        && props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/apparmor.d(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
      seLinuxSys = props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/selinux(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
       && props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/usr\/share\/selinux(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
      appArmorSys || seLinuxSys
    docs:
      desc: |
        This check verifies that the audit system is configured to log changes to the system's Mandatory Access Control (MAC) configurations, such as modifications to SELinux or AppArmor policies.

        **Why this matters**

        Mandatory Access Controls enforce strict rules about which subjects (users, processes) can access which objects (files, resources) beyond traditional discretionary permissions. Changes to MAC settings directly impact the system's security posture and can either strengthen or weaken its defenses.

        When modifications to MAC configurations are not audited:
          - Unauthorized or malicious changes may go undetected, potentially disabling key security mechanisms.
          - Administrators may be unaware of policy alterations that expose the system to privilege escalation or data leakage.
          - The system's compliance with security frameworks requiring MAC enforcement may be compromised.

        Logging events that alter SELinux modes, AppArmor profiles, or related configuration files helps ensure that all security policy changes are tracked and attributable. This supports continuous monitoring, strengthens control over access enforcement, and enhances trust in the system's security model.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-MAC_policy.rules`

            2. Add the following lines, for SELinux:

                ```
                -w /etc/selinux/ -p wa -k MAC-policy
                -w /usr/share/selinux/ -p wa -k MAC-policy
                ```

            3. Add the following lines, for AppArmor:

                ```
                -w /etc/apparmor/ -p wa -k MAC-policy
                -w /etc/apparmor.d/ -p wa -k MAC-policy
                ```

            4. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            5. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for MAC policy changes:

            ```yaml
            ---
            - name: Configure audit rules for SELinux and AppArmor MAC policy monitoring
              hosts: all
              become: true

              tasks:
                - name: Ensure MAC-policy audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-MAC_policy.rules
                    block: |
                      -w /etc/selinux/ -p wa -k MAC-policy
                      -w /usr/share/selinux/ -p wa -k MAC-policy
                      -w /etc/apparmor/ -p wa -k MAC-policy
                      -w /etc/apparmor.d/ -p wa -k MAC-policy
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: mac_audit_rules_updated

                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: mac_audit_rules_updated.changed

                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure events that modify the system's Mandatory Access Controls are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-MAC_policy.rules"

            echo "Ensuring audit rules for MAC policy changes are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -w /etc/selinux/ -p wa -k MAC-policy
            -w /usr/share/selinux/ -p wa -k MAC-policy
            -w /etc/apparmor/ -p wa -k MAC-policy
            -w /etc/apparmor.d/ -p wa -k MAC-policy
            EOF

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected
    title: Ensure events that modify the system's network environment are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    variants:
      - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-debian-rhel
      - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-other
    docs:
      desc: |
        This check verifies that the audit system is configured to record changes to key network configuration files and system identity settings by monitoring specific system calls and file paths.

        **Why this matters**

        Changes to the system's hostname, domain name, or core network-related files can alter how the system identifies itself and interacts with other hosts. These modifications may indicate reconfiguration, misconfiguration, or unauthorized tampering.

        If these events are not audited:
          •  Changes to system identity (via sethostname or setdomainname) may go untracked, affecting asset management and security visibility.
          •  Modifications to files like `/etc/hosts`, `/etc/issue`, or `/etc/sysconfig/network` could enable social engineering, redirect network traffic, or disrupt connectivity.
          •  Attackers may exploit these files to mask their activity or persist on the system.

        By auditing the sethostname and setdomainname system calls and monitoring changes to `/etc/issue`, `/etc/issue.net`, `/etc/hosts`, and `/etc/sysconfig/network`, administrators can detect critical network and identity changes. This supports system integrity, operational consistency, and incident investigation efforts.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-network.rules`

            2. Add the following lines, for SELinux:

                ```
                -a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
                -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale

                -w /etc/issue -p wa -k system-locale
                -w /etc/issue.net -p wa -k system-locale
                -w /etc/hosts -p wa -k system-locale
                ```

            3. Add the following line for Red Hat based systems:

                ```
                -w /etc/sysconfig/network -p wa -k system-locale
                ```

            4. Add the following line for Debian/Ubuntu based systems:

                ```
                -w /etc/network -p wa -k system-locale
                ```

            5. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            6. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for network environment changes:

            ```yaml
            ---
            - name: Gather network file facts
              ansible.builtin.stat:
                path: "{{ item }}"
              register: network_files
              loop:
                - /etc/sysconfig/network
                - /etc/network

            - name: Configure base audit rules
              ansible.builtin.blockinfile:
                path: /etc/audit/rules.d/50-system_local.rules
                block: |
                  -a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
                  -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale
                  -w /etc/issue -p wa -k system-locale
                  -w /etc/issue.net -p wa -k system-locale
                  -w /etc/hosts -p wa -k system-locale
                marker: "# {mark} ANSIBLE MANAGED - base network rules"
                state: present
                create: true
              register: base_audit_rules

            - name: Configure conditional network file monitoring
              ansible.builtin.blockinfile:
                path: /etc/audit/rules.d/50-system_local.rules
                block: "-w {{ item.item }} -p wa -k system-locale"
                marker: "# {mark} ANSIBLE MANAGED - {{ item.item | basename }}"
                state: present
              loop: "{{ network_files.results }}"
              when: item.stat.exists
              register: conditional_audit_rules

            - name: Set secure file permissions
              ansible.builtin.file:
                path: /etc/audit/rules.d/50-system_local.rules
                owner: root
                group: root
                mode: '0600'

            - name: Reload audit rules with proper error handling
              ansible.builtin.command: augenrules --load
              register: augenrules_result
              failed_when:
                - augenrules_result.rc != 0
                - not audit_immutable
              when: >
                base_audit_rules.changed or
                conditional_audit_rules.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure events that modify the system's network environment are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-network.rules"

            echo "Ensuring audit rules for network environment changes are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
            -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale
            -w /etc/issue -p wa -k system-locale
            -w /etc/issue.net -p wa -k system-locale
            -w /etc/hosts -p wa -k system-locale
            EOF

            if [[ -f /etc/sysconfig/network ]]; then
              echo "-w /etc/sysconfig/network -p wa -k system-locale" >> "$RULES_FILE"
            elif [[ -d /etc/network ]]; then
              echo "-w /etc/network -p wa -k system-locale" >> "$RULES_FILE"
            fi

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-debian-rhel
    filters: asset.family.contains(/redhat|debian/) == true
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /sethostname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setdomainname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /sethostname|setdomainname/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue.net/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/hosts/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/sysconfig\/network/)
        || props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/network/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/etc\/issue|\/etc\/issue.net|\/etc\/hosts|\/etc\/sysconfig\/network|\/etc\/network/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-other
    filters: asset.family.contains(/redhat|debian/) == false
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /sethostname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setdomainname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /sethostname|setdomainname/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue.net/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/hosts/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/etc\/issue|\/etc\/issue.net|\/etc\/hosts/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
  - uid: mondoo-linux-security-discretionary-access-control-permission-modification-events-are-collected
    title: Ensure discretionary access control permission modification events are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /chmod/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchmod/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchmodat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /chown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchownat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lchown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lsetxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fsetxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /removexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lremovexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fremovexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /chmod|fchmod|fchmodat|chown|fchown|fchownat|lchown|setxattr|lsetxattr|fsetxattr|removexattr|lremovexattr|fremovexattr/).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F key=perm_mod"])
            || split("-").containsAll(["k perm_mod"])
      )
    docs:
      desc: |
        This check verifies that changes to file permissions, attributes, ownership, and group are monitored. It ensures that system calls affecting these properties—such as `chmod`, `fchmod`, `fchmodat` (permissions), `chown`, `fchown`, `fchownat`, `lchown` (ownership), and `setxattr`, `lsetxattr`, `fsetxattr`, `removexattr`, `lremovexattr`, `fremovexattr` (extended attributes)—are audited.

        **Why this matters**

        Monitoring changes to file permissions and attributes is critical for maintaining system security. Unauthorized or accidental modifications can lead to privilege escalation, data leakage, or system compromise.

        If these events are not audited:
          - Changes to critical files may go undetected, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - Compliance with security standards requiring audit logging may be compromised.

        By auditing these system calls, administrators can detect and respond to unauthorized changes, ensuring the integrity of file permissions and attributes.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-perm_mod.rules`

            2. Add the following lines to the configuration file:

                ```
                -a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
                -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
                -a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
                -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
                -a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
                -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
                ```

            3. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for permission modification events:

            ```yaml
            ---
            - name: Configure audit rules for permission modification events
              hosts: all
              become: true
              tasks:
                - name: Ensure permission modification audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-perm_mod.rules
                    block: |
                      -a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
                      -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
                      -a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
                      -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
                      -a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
                      -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: perm_mod_audit_rules_updated
                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: perm_mod_audit_rules_updated.changed
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false
                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure discretionary access control permission modification events are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-perm_mod.rules"
            echo "Ensuring audit rules for permission modification events are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
            -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
            -a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
            -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
            -a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
            -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
            EOF

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-unsuccessful-unauthorized-file-access-attempts-are-collected
    title: Ensure unsuccessful unauthorized file access attempts are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / creat /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / open /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / openat /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / truncate /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / ftruncate /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == / creat | open | openat | truncate | ftruncate /).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F exit=","EPERM "])
            || split("-").containsAll(["F exit=","EACCES "])
          && split("-").containsAll(["F key=access"])
            || split("-").containsAll(["k access"])
            || split("-").containsAll(["F key=perm_mod"])
            || split("-").containsAll(["k perm_mod"])
      )
    docs:
      desc: |
        This check verifies that the system is configured to monitor unsuccessful attempts to access files by auditing system calls such as `creat`, `open`, `openat`, `truncate`, and `ftruncate`. These system calls control the creation, opening, and truncation of files. The audit log will record events where the user is a non-privileged user (auid >= 1000), is not a daemon event (auid=4294967295), and the system call returned EACCES (permission denied) or EPERM (operation not permitted). All audit records will be tagged with the identifier "access."

        **Why this matters**

        Monitoring unsuccessful file access attempts helps detect potential unauthorized access or misconfigurations. It provides visibility into failed attempts to create, open, or modify files, which may indicate malicious activity or user errors.

        If these events are not audited:
          - Unauthorized access attempts may go unnoticed, increasing the risk of data breaches.
          - Misconfigurations or permission issues may persist without detection.
          - The system may fall out of compliance with security standards requiring audit logging.

        By auditing these system calls, administrators can identify and respond to unauthorized access attempts, ensuring the integrity and security of the system.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-access.rules`

            2. Add the following lines to the configuration file:

                ```
                -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
                -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
                -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
                -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
                ```

            3. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for unsuccessful unauthorized file access attempts:

            ```yaml
            ---
            - name: Configure audit rules for unsuccessful unauthorized file access attempts
              hosts: all
              become: true
              tasks:
                - name: Ensure access audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-access.rules
                    block: |
                      -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
                      -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
                      -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
                      -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: access_audit_rules_updated
                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: access_audit_rules_updated.changed
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false
                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure unsuccessful unauthorized file access attempts are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-access.rules"
            echo "Ensuring audit rules for unsuccessful unauthorized file access attempts are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
            -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
            -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
            -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
            EOF

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-events-that-modify-usergroup-information-are-collected
    title: Ensure events that modify user/group information are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/group\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/passwd\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/gshadow\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/shadow\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/security\/opasswd\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
    docs:
      desc: |
        This check verifies that the system is configured to monitor changes to critical user and group management files, including `/etc/group`, `/etc/passwd`, `/etc/shadow`, `/etc/gshadow`, and `/etc/security/opasswd`. These files store information about user accounts, group memberships, and password policies.

        **Why this matters**

        Monitoring changes to these files is essential for maintaining system security. Unauthorized modifications can lead to privilege escalation, unauthorized access, or other malicious activities.

        If monitoring is not enabled:
          - Changes to user or group configurations may go undetected, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - The system may fall out of compliance with security standards requiring audit logging.

        By ensuring that changes to these critical files are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-identity.rules`

            2. Add the following lines to the configuration file:

                ```
                -w /etc/group -p wa -k identity
                -w /etc/passwd -p wa -k identity
                -w /etc/gshadow -p wa -k identity
                -w /etc/shadow -p wa -k identity
                -w /etc/security/opasswd -p wa -k identity
                ```

            3. To load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for user and group information changes:

            ```yaml
            ---
            - name: Configure audit rules for identity file monitoring
              hosts: all
              become: true

              tasks:
                - name: Ensure identity audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-identity.rules
                    block: |
                      -w /etc/group -p wa -k identity
                      -w /etc/passwd -p wa -k identity
                      -w /etc/gshadow -p wa -k identity
                      -w /etc/shadow -p wa -k identity
                      -w /etc/security/opasswd -p wa -k identity
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: identity_audit_rules_updated

                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: identity_audit_rules_updated.changed

                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use this Bash script to ensure events that modify user/group information are audited.

            ```bash
            #!/bin/bash
            set -e

            RULES_FILE="/etc/audit/rules.d/50-identity.rules"

            echo "Ensuring audit rules for user/group information changes are configured in $RULES_FILE"
            cat > "$RULES_FILE" <<EOF
            -w /etc/group -p wa -k identity
            -w /etc/passwd -p wa -k identity
            -w /etc/gshadow -p wa -k identity
            -w /etc/shadow -p wa -k identity
            -w /etc/security/opasswd -p wa -k identity
            EOF

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules because auditd is in immutable mode"
            fi
            ```
  - uid: mondoo-linux-security-successful-file-system-mounts-are-collected
    title: Ensure successful file system mounts are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always\,exit\s+\-F\s+arch\=b64\s+\-S\s+mount\s+\-F\s+auid\>\=1000\s+\-F\s+auid\!\=(4294967295|unset|-1)\s+\-k\s+mounts(\s+)?$/)) || props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always\,exit\s+\-F\s+arch\=b32\s+\-S\s+mount\s+\-F\s+auid\>\=1000\s+\-F\s+auid\!\=(4294967295|unset|-1)\s+\-k\s+mounts(\s+)?$/))
    docs:
      desc: |
        This check verifies that the system is configured to monitor successful file system mount events by auditing the `mount` system call. The audit log will record events where the user is a non-privileged user `(auid >= 1000)` and is not a daemon event `(auid=4294967295)`. All audit records will be tagged with the identifier "mounts."

        **Why this matters**

        Monitoring successful file system mounts is critical for maintaining system security. Unauthorized or unexpected mounts can lead to data leakage, privilege escalation, or other malicious activities.

        If these events are not audited:
          - Unauthorized mounts may go unnoticed, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - The system may fall out of compliance with security standards requiring audit logging.

        By ensuring that successful file system mount events are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-mounts.rules`

            2. Add the following lines to the configuration file:

                ```
                -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
                -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
                ```

            3. Load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for successful file system mounts:

            ```yaml
            ---
            - name: Configure audit rules for successful file system mounts
              hosts: all
              become: true

              tasks:
                - name: Ensure mount audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-mounts.rules
                    block: |
                      -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
                      -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
                    state: present
                    insertafter: EOF
                    create: yes
                    mode: '0600'
                  register: mount_audit_rules_updated
                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: mount_audit_rules_updated.changed
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false
                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            Use the following script to set the audit rules for successful file system mounts:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting up audit rules for successful file system mounts..."
            cat <<EOF > /etc/audit/rules.d/50-mounts.rules
            -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
            -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
            EOF

            echo "Loading audit rules..."
            augenrules --load > /dev/null

            # Notify if a reboot is required due to immutable audit configuration
            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules"
            fi
            ```
  - uid: mondoo-linux-security-file-deletion-events-by-users-are-collected
    title: Ensure file deletion events by users are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /unlink/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /rename/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /unlinkat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /renameat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /unlink|rename|unlinkat|renameat/).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F key=delete"])
            || split("-").containsAll(["k delete"])
      )
    docs:
      desc: |
        This check ensures that the system is configured to monitor the use of system calls associated with the deletion or renaming of files and file attributes. It verifies that the `unlink`, `unlinkat`, `rename`, and `renameat` system calls are audited, which helps track file deletions and renames.

        **Why this matters**

        Monitoring file deletion and renaming events is critical for maintaining system security and integrity. If these events are not audited:
          - Unauthorized file deletions or renames may go unnoticed, leading to data loss or tampering.
          - Malicious actors could exploit this lack of visibility to hide their tracks or disrupt system operations.
          - Compliance with security standards requiring audit logging may be compromised.

        Auditing these system calls ensures that all file deletion and renaming activities are logged, providing visibility into potential security incidents and supporting forensic investigations.

        **Note:**
        Systems may have been customized to change the default UID_MIN. To confirm the UID_MIN for your system, run this command:

        ```bash
        awk '/^\s*UID_MIN/{print $2}' /etc/login.defs
        ```

        If your system's UID_MIN is not `1000`, replace `auid>=1000` with `auid>=<UID_MIN for your system>` in the audit and remediation procedures.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-deletion.rules`

            2. Add the following lines to the configuration file:

                ```
                -a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
                -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
                ```

            3. Load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

              ```bash
              if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
              ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for file deletion and renaming:

            ```yaml
            ---
            - name: Configure audit rules for file deletion and renaming
              hosts: all
              become: true

              tasks:
                - name: Ensure file deletion and renaming audit rules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-deletion.rules
                    block: |
                      -a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
                      -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: deletion_audit_rules_updated
                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: deletion_audit_rules_updated.changed
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false
                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the audit rules for file deletion and renaming, you can use the following Bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring audit rules for file deletion and renaming..."
            cat <<EOF > /etc/audit/rules.d/50-deletion.rules
            -a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
            -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
            EOF

            echo "Loading audit rules..."
            augenrules --load > /dev/null

            # Notify if a reboot is required due to immutable audit configuration
            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules"
            fi
            ```
  - uid: mondoo-linux-security-kernel-module-loading-and-unloading-is-collected
    title: Ensure kernel module loading and unloading is audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/insmod\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/rmmod\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/modprobe\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always,exit\s+\-F\s+arch\=b64\s+\-S\s+init\_module\s+\-S\s+delete\_module\s+\-k\s+modules(\s+)?$/))
    docs:
      desc: |
        This check verifies that the loading and unloading of kernel modules is monitored by auditing the execution of related programs and system calls, such as `insmod`, `rmmod`, `modprobe`, `init_module`, and `delete_module`.

        **Why this matters**

        Kernel modules extend the functionality of the Linux kernel by adding features such as device drivers or file systems. Monitoring the loading and unloading of kernel modules is critical for maintaining system security and integrity. If these events are not audited:
          - Unauthorized or malicious modules could be loaded, compromising the system's security.
          - Attackers could use kernel modules to hide malicious activities or escalate privileges.
          - System administrators may lack visibility into critical changes to the kernel's behavior.

        By auditing the execution of module-related programs and system calls, organizations can detect and respond to unauthorized changes, ensuring the integrity and security of the kernel.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

                Example: `vi /etc/audit/rules.d/50-modules.rules`

            2. Add the following lines to the configuration file:

                ```
                -w /sbin/insmod -p x -k modules
                -w /sbin/rmmod -p x -k modules
                -w /sbin/modprobe -p x -k modules
                -a always,exit -F arch=b64 -S init_module -S delete_module -k modules
                ```

            3. Load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

                This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

                ```bash
                if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for kernel module loading and unloading:

            ```yaml
            ---
            - name: Configure audit rules for kernel modules
              hosts: all
              become: true

              tasks:
                - name: Ensure audit rules for kernel modules are present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-modules.rules
                    block: |
                      -w /sbin/insmod -p x -k modules
                      -w /sbin/rmmod -p x -k modules
                      -w /sbin/modprobe -p x -k modules
                      -a always,exit -F arch=b64 -S init_module -S delete_module -k modules
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                    register: modules_audit_rules_updated
                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: modules_audit_rules_updated.changed
                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false
                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the audit rules for kernel module loading and unloading, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting audit rules for kernel modules..."
            echo "-w /sbin/insmod -p x -k modules" > /etc/audit/rules.d/50-modules.rules
            echo "-w /sbin/rmmod -p x -k modules" >> /etc/audit/rules.d/50-modules.rules
            echo "-w /sbin/modprobe -p x -k modules" >> /etc/audit/rules.d/50-modules.rules
            echo "-a always,exit -F arch=b64 -S init_module -S delete_module -k modules" >> /etc/audit/rules.d/50-modules.rules

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules"
            fi
            ```
  - uid: mondoo-linux-security-system-administrator-actions-sudolog-are-collected
    title: Ensure system administrator actions (sudolog) are audited
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/sudo\.log\s+\-p\s+wa\s+\-k\s+actions(\s+)?$/))
    docs:
      desc: |
        This check ensures that the `sudo` log file is monitored to track all privileged commands executed by administrators. Properly configured systems disable the use of the `su` command, requiring administrators to log in and use `sudo` for privileged actions. This setup ensures that all administrator commands are logged to `/var/log/sudo.log`.

        **Why this matters**

        Monitoring the `sudo` log file provides visibility into administrative actions, ensuring accountability and enhancing security. If the `sudo` log file is not monitored:
          - Unauthorized or malicious actions by administrators may go undetected.
          - Critical audit trails may be incomplete, complicating incident response and forensic investigations.
          - Compliance with security policies requiring detailed logging of administrative actions may be compromised.

        By monitoring the `sudo` log file, organizations can ensure that all privileged commands are logged, supporting accountability, security, and compliance efforts.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

            Example: `vi /etc/audit/rules.d/50-sudo.rules`

            Add the following line:

            ```
            -w /var/log/sudo.log -p wa -k actions
            ```

            To load the newly added rules into the running configuration:

            ```bash
            augenrules --load
            ```

            This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            Check if a reboot is required, in case the running configuration is set to be immutable:

            ```bash
            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit rules for sudo log monitoring:

            ```yaml
            ---
            - name: Configure audit rule for sudo actions
              hosts: all
              become: true

              tasks:
                - name: Ensure audit rule for /var/log/sudo.log is present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-sudo.rules
                    block: |
                      -w /var/log/sudo.log -p wa -k actions
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: sudo_audit_rule_updated

                - name: Reload audit rules if updated
                  ansible.builtin.command: augenrules --load
                  when: sudo_audit_rule_updated.changed

                - name: Check if auditd is in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  failed_when: false
                  changed_when: false

                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the audit rule for sudo actions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting audit rule for sudo actions..."
            echo "-w /var/log/sudo.log -p wa -k actions" > /etc/audit/rules.d/50-sudo.rules

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules"
            fi
            ```
  - uid: mondoo-linux-security-the-audit-configuration-is-immutable
    title: Ensure the audit configuration is immutable
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/(\s+)?\-e\s+2(\s+)?$/))
    docs:
      desc: |
        This check ensures that the audit system is configured to operate in immutable mode by setting the `-e 2` flag. Immutable mode prevents any modifications to audit rules using `auditctl`, ensuring that audit configurations remain secure and consistent.

        **Why this matters**

        Immutable mode is a critical security feature for the audit system:
          - It prevents unauthorized or accidental changes to audit rules, maintaining the integrity of audit logs.
          - It ensures that audit configurations cannot be tampered with during runtime, reducing the risk of malicious activity going undetected.
          - It supports compliance with security standards that require robust and unalterable audit logging mechanisms.

        Once the audit system is set to immutable mode, changes to audit rules can only be made by rebooting the system, providing an additional layer of protection against unauthorized modifications.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure the audit configuration is immutable, follow these steps:

            1. Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`.

                Example:

                ```
                vi /etc/audit/rules.d/50-immutable.rules
                ```

            2. Add the following line to the file:

                ```
                -e 2
                ```

            3. Load the newly added rules into the running configuration:

                ```bash
                augenrules --load
                ```

            4. Check if a reboot is required, in case the running configuration is set to be immutable:

              ```bash
              if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
              ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the audit configuration to immutable mode:

            ```yaml
            ---
            - name: Ensure audit configuration is set to immutable mode (-e 2)
              hosts: all
              become: true

              tasks:
                - name: Ensure immutable audit rule is present
                  ansible.builtin.blockinfile:
                    path: /etc/audit/rules.d/50-immutable.rules
                    block: |
                      -e 2
                    create: yes
                    owner: root
                    group: root
                    mode: '0640'
                  register: immutable_rule_updated

                - name: Reload audit rules if file was updated
                  ansible.builtin.command: augenrules --load
                  when: immutable_rule_updated.changed

                - name: Check if auditd is already in immutable mode
                  ansible.builtin.shell: |
                    auditctl -s | grep -q '^enabled.*2$'
                  register: immutable_check
                  changed_when: false
                  failed_when: false

                - name: Notify if reboot is required due to immutable audit config
                  ansible.builtin.debug:
                    msg: "Reboot required to load audit rules because auditd is in immutable mode"
                  when: immutable_check.rc == 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the audit configuration to immutable mode, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting audit configuration to immutable mode..."
            echo "-e 2" > /etc/audit/rules.d/50-immutable.rules

            echo "Loading audit rules"
            augenrules --load > /dev/null

            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
              echo "Reboot required to load rules"
            fi
            ```
  - uid: mondoo-linux-security-sudo-logging-is-enabled
    title: Ensure sudo logging is enabled
    impact: 80
    props:
      - uid: mondooLinuxSecuritySudoersFiles
        title: Return the files from /etc/sudoers.d
        mql: |
          sudoersFiles = files.find(from: "/etc/sudoers.d/", type: 'file').list.map(path) + ["/etc/sudoers"]
          return sudoersFiles.map(file(_).content.lines.where(_ == /^[^#]/)).flat
    mql: |
      props.mondooLinuxSecuritySudoersFiles
        .where(_ == /Defaults/)
        .any(_ == /logfile=\"\/var\/log\/sudo\.log\"/)
    docs:
      desc: |
        This check ensures that sudo logs all events to a dedicated log file instead of the default `/var/log/auth.log` file, which contains all authentication events system-wide. Configuring a dedicated log file for sudo events improves the ability to audit and monitor sudo usage effectively.

        **Why this matters**

        By default, sudo logs are mixed with other authentication events in `/var/log/auth.log`, making it difficult to identify and analyze sudo-specific failures or activities. Without a dedicated log file:
          - Sudo failures may go unnoticed due to the volume of unrelated log entries.
          - Administrators may face challenges in auditing and investigating sudo usage.
          - Critical security events related to sudo may be obscured, increasing the risk of unauthorized access or privilege escalation.

        Configuring sudo to log to a dedicated file enhances visibility into sudo activities, supports effective auditing, and strengthens overall system security.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To enable sudo logging to a dedicated file using a sudoers.d file:

            1. Create a new file in `/etc/sudoers.d/` (for example, `/etc/sudoers.d/sudo-logging`) using the `visudo` command to prevent syntax errors:

              ```bash
              visudo -f /etc/sudoers.d/sudo-logging
              ```

            2. Add the following line to the file:

              ```
              Defaults logfile="/var/log/sudo.log"
              ```

            3. Ensure that the log file exists and has appropriate permissions:

              ```bash
              touch /var/log/sudo.log
              chmod 600 /var/log/sudo.log
              chown root:root /var/log/sudo.log
              ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To enable sudo logging to a dedicated file using a bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Creating a temporary file with the sudo logging configuration..."
            tmpfile=$(mktemp /tmp/sudo-logging.XXXXXX)
            echo 'Defaults logfile="/var/log/sudo.log"' > "$tmpfile"

            echo "Validating sudo logging configuration and installing..."
            if visudo -cf "$tmpfile"; then
              # Set correct permissions before moving
              chmod 440 "$tmpfile"
              install -o root -g root -m 440 "$tmpfile" /etc/sudoers.d/sudo-logging
              rm -f "$tmpfile"
            else
              echo "visudo config file validation failed"
              rm -f "$tmpfile"
              exit 1
            fi

            echo "Creating the sudo log file..."
            touch /var/log/sudo.log
            chmod 600 /var/log/sudo.log
            chown root:root /var/log/sudo.log
            ```
  - uid: mondoo-linux-security-permissions-on-etcsshsshd-config-are-configured
    title: Ensure secure permissions on /etc/ssh/sshd_config are set
    impact: 100
    mql: |
      file("/etc/ssh/sshd_config") {
        user.name == "root"
        group.name == "root"
        permissions.user_executable == false
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that the `/etc/ssh/sshd_config` file is secured with appropriate ownership and permissions. The file must be owned by the root user and group to prevent unauthorized modifications.

        **Why this matters**

        The `/etc/ssh/sshd_config` file contains critical configuration settings for the SSH daemon. If this file is improperly secured:
          - Unauthorized users could modify SSH settings, potentially compromising system security.
          - Malicious actors could weaken SSH configurations to allow unauthorized access or escalate privileges.
          - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `/etc/ssh/sshd_config` file is owned by the root user and group, organizations can protect critical SSH configurations and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on `/etc/ssh/sshd_config`, run the following commands:

            ```bash
            chown root:root /etc/ssh/sshd_config
            chmod og-rwx /etc/ssh/sshd_config
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on `/etc/ssh/sshd_config`, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure correct ownership and permissions for sshd_config
              hosts: all
              become: yes
              tasks:
                - name: Set ownership of /etc/ssh/sshd_config to root:root
                  ansible.builtin.file:
                    path: /etc/ssh/sshd_config
                    owner: root
                    group: root

                - name: Remove read/write/execute permissions for group and others on sshd_config
                  ansible.builtin.file:
                    path: /etc/ssh/sshd_config
                    mode: '0600'
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the ownership and permissions on `/etc/ssh/sshd_config`, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions for /etc/ssh/sshd_config..."
            chown root:root /etc/ssh/sshd_config
            chmod og-rwx /etc/ssh/sshd_config
            ```
  - uid: mondoo-linux-security-rsyslog-is-installed-and-enabled
    title: Ensure rsyslog is installed
    impact: 50
    mql: |
      package("rsyslog").installed
      service("rsyslog").enabled
    docs:
      desc: |
        This check ensures that the `rsyslog` software is installed and enabled as a replacement for the original `syslogd` daemon, providing enhanced logging capabilities and security features.

        **Why this matters**

        `rsyslog` offers several improvements over `syslogd`, including:
          - Connection-oriented (i.e., TCP) transmission of logs, ensuring reliable delivery.
          - Support for logging to database formats, enabling advanced log analysis and storage.
          - Encryption of log data during transmission, protecting sensitive information from interception.

        By using `rsyslog`, organizations can enhance their logging infrastructure, improve log reliability and security, and meet compliance requirements for secure log management.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To install and enable `rsyslog`, run the following commands:

            ### RHEL/Fedora/Amazon Linux and derivatives

            ```bash
            yum install rsyslog
            systemctl --now enable rsyslog
            ```

            ### Debian/Ubuntu and derivatives

            ```bash
            apt-get install rsyslog
            systemctl --now enable rsyslog
            ```

            ### SLES and openSUSE

            ```bash
            zypper install rsyslog
            systemctl --now enable rsyslog
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To install and enable `rsyslog`, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure rsyslog is installed and enabled
              hosts: all
              become: yes
              tasks:
                - name: Install rsyslog
                  ansible.builtin.package:
                    name: rsyslog
                    state: present

                - name: Enable and start rsyslog service
                  ansible.builtin.systemd:
                    name: rsyslog
                    enabled: yes
                    state: started
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To install and enable `rsyslog`, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Installing rsyslog..."
            if command -v yum &> /dev/null; then
              yum install -y rsyslog
            elif command -v apt-get &> /dev/null; then
              apt-get install -y rsyslog
            elif command -v zypper &> /dev/null; then
              zypper install -y rsyslog
            else
              echo "Unsupported package manager. Please install rsyslog manually."
              exit 1
            fi

            echo "Starting and enabling rsyslog service..."
            systemctl enable --now rsyslog
            ```
  - uid: mondoo-linux-security-rsyslog-default-file-permissions-configured
    title: Ensure rsyslog default file permissions configured
    impact: 60
    mql: |
      rsyslog.conf.settings.contains("$FileCreateMode 0640")
    docs:
      desc: |
        This check ensures that `rsyslog` is configured to apply appropriate permissions to newly created log files. This setting controls the default permissions for log files that do not already exist on the system.

        **Why this matters**

        Properly configured file permissions for log files are critical for maintaining system security:
          - Prevents unauthorized access to sensitive log data.
          - Ensures compliance with security policies and regulatory requirements.
          - Protects the integrity and confidentiality of log information.

        By setting appropriate permissions for newly created log files, organizations can safeguard sensitive information, maintain a secure logging environment, and reduce the risk of data exposure.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the default file permissions for `rsyslog`, edit the `/etc/rsyslog.conf` and `/etc/rsyslog.d/*.conf` files and add or modify the following line:

            ```bash
            $FileCreateMode 0640
            ```
            Restart the `rsyslog` service to apply the changes:

            ```bash
            systemctl restart rsyslog
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the default file permissions for `rsyslog`, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set default file permissions for rsyslog
              hosts: all
              become: yes
              tasks:
                - name: Ensure $FileCreateMode 0640 is set in /etc/rsyslog.conf
                  ansible.builtin.lineinfile:
                    path: /etc/rsyslog.conf
                    regexp: '^\$FileCreateMode'
                    line: '$FileCreateMode 0640'
                    state: present
                    insertafter: EOF
                    create: yes

                - name: Ensure $FileCreateMode 0640 is set in all /etc/rsyslog.d/*.conf files
                  ansible.builtin.find:
                    paths: /etc/rsyslog.d
                    patterns: '*.conf'
                    file_type: file
                  register: rsyslog_conf_files

                - name: Set $FileCreateMode 0640 in each rsyslog.d file
                  ansible.builtin.lineinfile:
                    path: "{{ item.path }}"
                    regexp: '^\$FileCreateMode'
                    line: '$FileCreateMode 0640'
                    create: yes
                    state: present
                    backup: yes
                  loop: "{{ rsyslog_conf_files.files }}"

                - name: Restart rsyslog service
                  ansible.builtin.systemd:
                    name: rsyslog
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the default file permissions for `rsyslog`, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting default file permissions for rsyslog..."

            # Update /etc/rsyslog.conf
            if grep -q '^\$FileCreateMode' /etc/rsyslog.conf; then
              sed -i 's/^\$FileCreateMode.*/\$FileCreateMode 0640/' /etc/rsyslog.conf
            else
              echo "\$FileCreateMode 0640" >> /etc/rsyslog.conf
            fi

            # Update all /etc/rsyslog.d/*.conf files
            for file in /etc/rsyslog.d/*.conf; do
              if grep -q '^\$FileCreateMode' "$file"; then
                sed -i 's/^\$FileCreateMode.*/\$FileCreateMode 0640/' "$file"
              else
                echo "\$FileCreateMode 0640" >> "$file"
              fi
            done

            echo "Restarting rsyslog service..."
            systemctl restart rsyslog
            ```
  - uid: mondoo-linux-security-journald-is-configured-to-send-logs-to-rsyslog
    title: Ensure journald is configured to send logs to rsyslog
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["ForwardToSyslog"].downcase == "yes"
        }
      }
    docs:
      desc: |
        This check ensures that journald is configured to forward logs to rsyslog, providing a consistent and reliable means of log collection and export.

        **Why this matters**

        Forwarding logs from journald to rsyslog offers several benefits:
          - Centralized log management, enabling easier analysis and troubleshooting.
          - Compatibility with existing rsyslog configurations for log forwarding and storage.
          - Enhanced reliability and flexibility in log handling, including support for remote log export.

        By configuring journald to forward logs to rsyslog, organizations can improve log management, ensure consistent log collection, and maintain compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To configure journald to forward logs to rsyslog, edit the `/etc/systemd/journald.conf` file and add the following line:

                ```ini
                ForwardToSyslog=yes
                ```

            2. Restart the service to load the new configuration values:

                ```bash
                systemctl restart systemd-journald
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To configure journald to forward logs to rsyslog, use the following Ansible playbook:

            ```yaml
            ---
            - name: Configure journald to forward logs to rsyslog
              hosts: all
              become: true

              tasks:
                - name: Ensure ForwardToSyslog=yes is set in journald.conf
                  ansible.builtin.lineinfile:
                    path: /etc/systemd/journald.conf
                    regexp: '^#?ForwardToSyslog='
                    line: 'ForwardToSyslog=yes'
                    create: yes
                    backup: yes

                - name: Restart systemd-journald to apply changes
                  ansible.builtin.systemd:
                    name: systemd-journald
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To configure journald to forward logs to rsyslog, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring journald to forward logs to rsyslog..."

            if grep -q '^ForwardToSyslog=' /etc/systemd/journald.conf; then
              sed -i 's/^ForwardToSyslog=.*/ForwardToSyslog=yes/' /etc/systemd/journald.conf
            else
              echo "ForwardToSyslog=yes" >> /etc/systemd/journald.conf
            fi

            echo "Restarting systemd-journald service..."
            systemctl restart systemd-journald
            ```
  - uid: mondoo-linux-security-journald-is-configured-to-compress-large-log-files
    title: Ensure journald is configured to compress large log files
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["Compress"] == "yes"
        }
      }
    docs:
      desc: |
        This check ensures that journald is configured to compress large log files, helping to manage disk space and maintain system performance.

        **Why this matters**

        journald's compression capability provides several benefits:
          - Prevents log files from consuming excessive disk space, ensuring system stability.
          - Reduces the risk of logs becoming unmanageably large, simplifying log management.
          - Supports efficient storage of log data, enabling better resource utilization.

        By enabling log compression in journald, organizations can maintain a reliable logging system, optimize disk usage, and ensure effective log management.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To configure journald to compress large log files, edit the `/etc/systemd/journald.conf` file and add the following line:

                ```ini
                Compress=yes
                ```

            2. Restart the service to load the new configuration values:

                ```bash
                systemctl restart systemd-journald
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To configure journald to compress large log files, use the following Ansible playbook:

            ```yaml
            ---
            - name: Configure journald to compress large log files
              hosts: all
              become: true

              tasks:
                - name: Ensure Compress=yes is set in journald.conf
                  ansible.builtin.lineinfile:
                    path: /etc/systemd/journald.conf
                    regexp: '^#?Compress='
                    line: 'Compress=yes'
                    create: yes
                    backup: yes

                - name: Restart systemd-journald to apply compression setting
                  ansible.builtin.systemd:
                    name: systemd-journald
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To configure journald to compress large log files, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring journald to compress large log files..."

            if grep -q '^Compress=' /etc/systemd/journald.conf; then
              sed -i 's/^Compress=.*/Compress=yes/' /etc/systemd/journald.conf
            else
              echo "Compress=yes" >> /etc/systemd/journald.conf
            fi

            echo "Restarting systemd-journald service..."
            systemctl restart systemd-journald
            ```
  - uid: mondoo-linux-security-journald-is-configured-to-write-logfiles-to-persistent-disk
    title: Ensure journald is configured to write logfiles to persistent disk
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["Storage"] == "persistent"
        }
      }
    docs:
      desc: |
        This check ensures that journald is configured to write log files to a persistent disk, preventing log loss during system reboots and ensuring reliable log retention.

        **Why this matters**

        Persisting logs to a local disk provides several benefits:
          - Protects logs from being lost during system reboots, ensuring continuity in log data.
          - Enhances the reliability of log retention for troubleshooting and auditing purposes.
          - Supports compliance with security policies and regulatory requirements that mandate log preservation.

        By configuring journald to write logs to a persistent disk, organizations can maintain a robust logging infrastructure, safeguard critical log data, and ensure effective system monitoring.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To configure journald to write log files to a persistent disk, edit the `/etc/systemd/journald.conf` file and add the following line:

                ```ini
                Storage=persistent
                ```

            2. Restart the service to load the new configuration values:

                ```bash
                systemctl restart systemd-journald
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To configure journald to write log files to a persistent disk, use the following Ansible playbook:

            ```yaml
            ---
            - name: Configure journald to write logs to persistent storage
              hosts: all
              become: true

              tasks:
                - name: Ensure Storage=persistent is set in journald.conf
                  ansible.builtin.lineinfile:
                    path: /etc/systemd/journald.conf
                    regexp: '^#?Storage='
                    line: 'Storage=persistent'
                    create: yes
                    backup: yes

                - name: Restart systemd-journald to apply storage setting
                  ansible.builtin.systemd:
                    name: systemd-journald
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To configure journald to write log files to a persistent disk, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring journald to write logs to persistent storage..."

            if grep -q '^Storage=' /etc/systemd/journald.conf; then
              sed -i 's/^Storage=.*/Storage=persistent/' /etc/systemd/journald.conf
            else
              echo "Storage=persistent" >> /etc/systemd/journald.conf
            fi

            echo "Restarting systemd-journald service..."
            systemctl restart systemd-journald
            ```
  - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
    title: Ensure secure permissions on all log files are set
    impact: 80
    mql: |
      files.find(from: "/var/log", type: "file").list {
        path
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that log files stored in `/var/log/` are properly secured to protect sensitive information and maintain system integrity.

        **Why this matters**

        Log files in `/var/log/` contain critical information from various services on the system. If these files are not properly secured:
          - Sensitive data may be exposed, especially on log aggregation servers that collect logs from multiple systems.
          - Unauthorized access to log files could lead to data breaches or compromise system security.
          - Compliance with security policies and regulatory requirements for log protection may be violated.

        By ensuring that log files in `/var/log/` are properly secured, organizations can protect sensitive information, maintain system integrity, and meet compliance requirements.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. Set the correct permissions on all log files in `/var/log/`, run the following command:

                ```bash
                find /var/log/ -type f -exec chmod g-wx,o-rwx {} +
                ```

            2. Configure rsyslog to set default permissions for newly created log files if using `rsyslog`:

                Edit the `/etc/rsyslog.conf` file (and any relevant files in `/etc/rsyslog.d/*.conf`) and add or update the following lines:

                ```
                $FileCreateMode 0640
                $Umask 0077
                ```

                Save the file and restart the rsyslog service to apply the changes:

                ```bash
                systemctl restart rsyslog
                ```

            3. Configure the creation, deletion, and cleaning of volatile and temporary files:

                Edit or create a file in the `/etc/tmpfiles.d/` directory, for example, `/etc/tmpfiles.d/var.conf`, and add the following lines:

                ```
                f /var/log/faillog 0640 root root -
                f /var/log/wtmp 0640 root utmp -
                f /var/log/btmp 0640 root utmp -
                f /var/log/lastlog 0640 root utmp -
                ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the ownership and permissions on all log files in /var/log, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting permissions on all log files in /var/log..."
            find /var/log/ -type f -exec chmod g-wx,o-rwx {} +

            echo "Configuring tmpfiles.d to set default permissions for newly created log files..."
            cat <<EOF >> /etc/tmpfiles.d/var.conf
            f /var/log/faillog 0640 root root -
            f /var/log/wtmp 0640 root utmp -
            f /var/log/btmp 0640 root utmp -
            f /var/log/lastlog 0640 root utmp -
            EOF
            ```
  - uid: mondoo-linux-security-permissions-on-ssh-private-host-key-files-are-configured
    title: Ensure secure permissions on SSH private host key files are set
    impact: 100
    mql: |
      files.
        find(from: "/etc/ssh", type: "file").
        where(path == /ssh_host_.*key$/).list {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
    docs:
      desc: |
        This check ensures that SSH private keys are securely stored and handled to prevent unauthorized access and maintain the integrity of SSH public key authentication.

        **Why this matters**

        SSH private keys are critical for authentication in public key cryptography. If private keys are not properly secured:
          - Unauthorized users could gain access to sensitive systems by using compromised private keys.
          - The integrity of the authentication process could be undermined, leading to potential security breaches.
          - Compliance with security policies requiring proper key management may be compromised.

        By ensuring that SSH private keys are securely stored and handled, organizations can protect sensitive systems, maintain secure authentication, and comply with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on the SSH host private key files, run the following commands:

            ```bash
            find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chown root:ssh_keys {} \; -exec chmod 0600 {} \;
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the SSH host private key files, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on SSH host private key files
              hosts: all
              become: true

              tasks:
                - name: Set ownership to root:ssh_keys for SSH private key files
                  ansible.builtin.find:
                    paths: /etc/ssh
                    patterns: 'ssh_host_*_key'
                    file_type: file
                    recurse: no
                    follow: false
                  register: ssh_private_keys

                - name: Set correct ownership and permissions on SSH host private keys
                  ansible.builtin.file:
                    path: "{{ item.path }}"
                    owner: root
                    group: ssh_keys
                    mode: '0600'
                  loop: "{{ ssh_private_keys.files }}"
                  when: ssh_private_keys.matched > 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the ownership and permissions on the SSH host private key files, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chown root:ssh_keys {} \; -exec chmod 0600 {} \;
            ```
  - uid: mondoo-linux-security-permissions-on-ssh-public-host-key-files-are-configured
    title: Ensure secure permissions on SSH public host key files are set
    impact: 80
    mql: |
      files.
        find(from: "/etc/ssh", type: "file").
        where(path == /ssh_host_.*key.pub$/).list {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
    docs:
      desc: |
        This check ensures that SSH public keys are properly configured and secured as part of the SSH public key authentication mechanism. Public keys are used to verify digital signatures generated by their corresponding private keys, enabling secure and reliable authentication.

        **Why this matters**

        SSH public key authentication provides several benefits:
          - Enhances security by eliminating the need for password-based authentication, reducing the risk of brute-force attacks.
          - Ensures that only users with the corresponding private key can authenticate successfully.
          - Supports compliance with security policies requiring strong authentication mechanisms.

        By properly configuring and securing SSH public keys, organizations can strengthen their authentication processes, protect sensitive systems, and maintain a secure environment.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on the SSH host public key files, run the following commands:

            ```bash
            find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chown root:root {} \; -exec chmod 0644 {} \;
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the SSH host public key files, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on SSH host public key files
              hosts: all
              become: true

              tasks:
                - name: Find SSH host public key files
                  ansible.builtin.find:
                    paths: /etc/ssh
                    patterns: 'ssh_host_*_key.pub'
                    file_type: file
                    recurse: no
                    follow: false
                  register: ssh_public_keys

                - name: Set correct ownership and permissions on SSH host public keys
                  ansible.builtin.file:
                    path: "{{ item.path }}"
                    owner: root
                    group: root
                    mode: '0644'
                  loop: "{{ ssh_public_keys.files }}"
                  when: ssh_public_keys.matched > 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the ownership and permissions on the SSH host public key files, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chown root:root {} \; -exec chmod 0644 {} \;
            ```
  - uid: mondoo-linux-security-ssh-protocol-is-set-to-2
    title: Ensure SSH Protocol is set to 2
    impact: 80
    filters: package('openssh-server').version  >= semver("6") && package('openssh-server').version < semver("7.6")
    mql: |
      sshd.config.params["Protocol"] == 2
    docs:
      desc: |
        This check ensures that the SSH protocol is set to version 2, which provides enhanced security and addresses vulnerabilities present in the older SSH1 protocol.

        **Why this matters**

        SSH1 is an outdated protocol with known security issues, including:
          - Weak encryption algorithms that are susceptible to attacks.
          - Vulnerabilities that can be exploited to compromise the confidentiality and integrity of SSH sessions.

        SSH2 is a more advanced and secure protocol, offering:
          - Stronger encryption algorithms to protect data in transit.
          - Improved authentication mechanisms to prevent unauthorized access.
          - Enhanced security features to mitigate modern threats.

        By enforcing the use of SSH2, organizations can ensure secure remote access, protect sensitive data, and maintain compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the SSH protocol to version 2, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            Protocol 2
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the SSH protocol to version 2, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH Protocol is set to 2
              hosts: all
              become: true

              tasks:
                - name: Set Protocol 2 in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^Protocol'
                    line: 'Protocol 2'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the SSH Protocol to 2, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^Protocol' /etc/ssh/sshd_config; then
              echo "Updating Protocol to 2 in /etc/ssh/sshd_config..."
              sed -i 's/^Protocol.*/Protocol 2/' /etc/ssh/sshd_config
            else
              echo "Adding Protocol 2 to /etc/ssh/sshd_config..."
              echo "Protocol 2" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-loglevel-is-appropriate
    title: Ensure SSH LogLevel is appropriate
    impact: 60
    mql: |
      sshd.config.params["LogLevel"] == /INFO|VERBOSE/
    docs:
      desc: |
        This check ensures that the `LogLevel` parameter in the SSH configuration is set to an appropriate level to log user login and logout activity, as well as key fingerprints for SSH key-based logins.

        **Why this matters**

        The `INFO` level logs basic login activity, which is essential for tracking user access to the system. This helps identify when users were active and supports incident response efforts by narrowing down potential suspects during investigations.

        The `VERBOSE` level provides additional details, including the key fingerprint for any SSH key used during login. This is particularly useful for SSH key management, especially in environments with legacy systems or shared keys.

        By configuring the `LogLevel` parameter to `INFO` or `VERBOSE`, organizations can enhance visibility into SSH activity, improve auditability, and strengthen overall security.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the SSH LogLevel to an appropriate value, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            LogLevel VERBOSE
            ```

            or

            ```bash
            LogLevel INFO
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the SSH LogLevel to an appropriate value, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH LogLevel is set to VERBOSE
              hosts: all
              become: true

              tasks:
                - name: Set LogLevel in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^LogLevel'
                    line: 'LogLevel VERBOSE'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the SSH LogLevel to an appropriate value, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^LogLevel' /etc/ssh/sshd_config; then
              echo "Updating LogLevel to VERBOSE in /etc/ssh/sshd_config..."
              sed -i 's/^LogLevel.*/LogLevel VERBOSE/' /etc/ssh/sshd_config
            else
              echo "Adding LogLevel VERBOSE to /etc/ssh/sshd_config..."
              echo "LogLevel VERBOSE" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-x11-forwarding-is-disabled
    title: Ensure SSH X11 forwarding is disabled
    impact: 50
    mql: |
      sshd.config.params["X11Forwarding"] == "no"
    docs:
      desc: |
        This check ensures that the `X11Forwarding` parameter in the SSH configuration is disabled to prevent tunneling of X11 traffic through the connection, which could expose the system to security risks.

        **Why this matters**

        The `X11Forwarding` parameter allows remote graphical connections by tunneling X11 traffic through the SSH connection. If enabled:
          - It could expose the system to unauthorized access or data leakage through the X11 protocol.
          - Attackers could exploit this feature to capture sensitive information or compromise the system.
          - It increases the attack surface of the SSH server, potentially leading to security vulnerabilities.

        By disabling `X11Forwarding`, organizations can reduce the attack surface, enhance system security, and maintain compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To disable SSH X11 forwarding, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            X11Forwarding no
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To disable SSH X11 forwarding, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH X11Forwarding is disabled
              hosts: all
              become: true

              tasks:
                - name: Set X11Forwarding to no in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^X11Forwarding'
                    line: 'X11Forwarding no'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To disable SSH X11 forwarding, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^X11Forwarding' /etc/ssh/sshd_config; then
              echo "Updating X11Forwarding to no in /etc/ssh/sshd_config..."
              sed -i 's/^X11Forwarding.*/X11Forwarding no/' /etc/ssh/sshd_config
            else
              echo "Adding X11Forwarding no to /etc/ssh/sshd_config..."
              echo "X11Forwarding no" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-maxauthtries-is-set-to-4-or-less
    title: Ensure SSH MaxAuthTries is set to 4 or less
    impact: 75
    mql: |
      sshd.config.params["MaxAuthTries"] <= 4
    docs:
      desc: |
        This check ensures that the `MaxAuthTries` parameter is configured to limit the maximum number of authentication attempts permitted per connection. Properly setting this parameter helps prevent brute-force attacks and enhances system security.

        **Why this matters**

        The `MaxAuthTries` parameter controls the number of authentication attempts allowed before the connection is terminated. If this parameter is not properly configured:

        - Attackers could exploit unlimited or high authentication attempts to perform brute-force attacks.
        - System logs could be flooded with failed login attempts, making it harder to detect legitimate security incidents.
        - The overall security posture of the system could be weakened, increasing the risk of unauthorized access.

        By configuring `MaxAuthTries` to an appropriate value, organizations can mitigate the risk of brute-force attacks, protect sensitive data, and maintain compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the SSH MaxAuthTries to 4 or less, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            MaxAuthTries 4
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the SSH MaxAuthTries to 4 or less, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH MaxAuthTries is set to 4 or less
              hosts: all
              become: true

              tasks:
                - name: Set MaxAuthTries in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^MaxAuthTries'
                    line: 'MaxAuthTries 4'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To set the SSH MaxAuthTries to 4 or less, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^MaxAuthTries' /etc/ssh/sshd_config; then
              echo "Updating MaxAuthTries to 4 in /etc/ssh/sshd_config..."
              sed -i 's/^MaxAuthTries.*/MaxAuthTries 4/' /etc/ssh/sshd_config
            else
              echo "Adding MaxAuthTries 4 to /etc/ssh/sshd_config..."
              echo "MaxAuthTries 4" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-ignorerhosts-is-enabled
    title: Ensure SSH IgnoreRhosts is enabled
    impact: 60
    mql: |
      sshd.config.params["IgnoreRhosts"] == "yes"
    docs:
      desc: |
        This check ensures that the `IgnoreRhosts` parameter in the SSH configuration is enabled to prevent the use of `.rhosts` and `.shosts` files for authentication. Disabling these files enhances the security of the SSH server by enforcing stricter authentication mechanisms.

        **Why this matters**

        The `IgnoreRhosts` parameter ensures that `.rhosts` and `.shosts` files are not used in `RhostsRSAAuthentication` or `HostbasedAuthentication`. If these files are allowed:

        - Unauthorized users could exploit trusted host relationships to gain access to the system.
        - Malicious actors could use compromised `.rhosts` or `.shosts` files to bypass authentication mechanisms.
        - System integrity and compliance with security policies could be compromised.

        By enabling the `IgnoreRhosts` parameter, organizations can reduce the attack surface and ensure that authentication relies on more secure mechanisms, such as public key or password-based authentication.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To enable SSH IgnoreRhosts, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            IgnoreRhosts yes
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To enable SSH IgnoreRhosts, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH IgnoreRhosts is enabled
              hosts: all
              become: true

              tasks:
                - name: Set IgnoreRhosts to yes in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^IgnoreRhosts'
                    line: 'IgnoreRhosts yes'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To enable SSH IgnoreRhosts, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^IgnoreRhosts' /etc/ssh/sshd_config; then
              echo "Updating IgnoreRhosts to yes in /etc/ssh/sshd_config..."
              sed -i 's/^IgnoreRhosts.*/IgnoreRhosts yes/' /etc/ssh/sshd_config
            else
              echo "Adding IgnoreRhosts yes to /etc/ssh/sshd_config..."
              echo "IgnoreRhosts yes" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-hostbasedauthentication-is-disabled
    title: Ensure SSH HostbasedAuthentication is disabled
    impact: 70
    mql: |
      sshd.config.params["HostbasedAuthentication"] == "no"
    docs:
      desc: |
        This check ensures that the `HostbasedAuthentication` parameter in the SSH configuration is properly set to prevent authentication through trusted hosts using `.rhosts` or `/etc/hosts.equiv` files, combined with public key client host authentication. This setting applies only to SSH Protocol Version 2.

        **Why this matters**

        Allowing host-based authentication can introduce significant security risks:

        - Unauthorized users could exploit trusted host relationships to gain access to the system.
        - Malicious actors could use compromised `.rhosts` or `/etc/hosts.equiv` files to bypass authentication mechanisms.
        - System integrity and compliance with security policies could be compromised.

        By disabling `HostbasedAuthentication`, organizations can reduce the attack surface and ensure that authentication relies on more secure mechanisms, such as public key or password-based authentication.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To disable SSH HostbasedAuthentication, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            HostbasedAuthentication no
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To disable SSH HostbasedAuthentication, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH HostbasedAuthentication is disabled
              hosts: all
              become: true

              tasks:
                - name: Set HostbasedAuthentication to no in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^HostbasedAuthentication'
                    line: 'HostbasedAuthentication no'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To disable SSH HostbasedAuthentication, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^HostbasedAuthentication' /etc/ssh/sshd_config; then
              echo "Updating HostbasedAuthentication to no in /etc/ssh/sshd_config..."
              sed -i 's/^HostbasedAuthentication.*/HostbasedAuthentication no/' /etc/ssh/sshd_config
            else
              echo "Adding HostbasedAuthentication no to /etc/ssh/sshd_config..."
              echo "HostbasedAuthentication no" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-root-login-is-disabled
    title: Ensure SSH root login is disabled or set to prohibit-password
    impact: 100
    mql: |
      sshd.config.params["PermitRootLogin"] == "no" || sshd.config.params["PermitRootLogin"] == "prohibit-password" || sshd.config.params["PermitRootLogin"] == "without-password"
    docs:
      desc: |
        This check ensures that the `PermitRootLogin` parameter in the SSH configuration is set to restrict root login access. Disabling root login enhances the security of the SSH server by preventing direct access to the root account.

        **Why this matters**

        Allowing root login via SSH poses significant security risks:

        - Attackers could target the root account with brute-force attacks, increasing the likelihood of unauthorized access.
        - Direct root access bypasses the accountability provided by individual user accounts.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `PermitRootLogin` parameter is disabled or set to `prohibit-password`, organizations can enforce secure authentication practices, reduce the attack surface, and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To disable SSH root login or set it to prohibit password authentication, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            PermitRootLogin no
            ```

            or

            ```bash
            PermitRootLogin prohibit-password
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To disable SSH root login or set it to prohibit password authentication, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH root login is disabled or set to prohibit-password
              hosts: all
              become: true

              tasks:
                - name: Set PermitRootLogin to no in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^PermitRootLogin'
                    line: 'PermitRootLogin no'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To disable SSH PermitRootLogin, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^PermitRootLogin' /etc/ssh/sshd_config; then
              echo "Updating PermitRootLogin in sshd_config..."
              sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
            else
              echo "Adding PermitRootLogin to sshd_config..."
              echo "PermitRootLogin no" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-permitemptypasswords-is-disabled
    title: Ensure SSH PermitEmptyPasswords is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitEmptyPasswords"] == "no"
    docs:
      desc: |
        This check ensures that the `PermitEmptyPasswords` parameter in the SSH configuration is disabled to prevent accounts with empty password strings from being used for login. Disabling this option enhances the security of the SSH server by enforcing password-based authentication.

        **Why this matters**

        Allowing accounts with empty passwords to log in via SSH poses significant security risks:

        - Unauthorized users could gain access to the system without providing any credentials.
        - Malicious actors could exploit this vulnerability to compromise sensitive data or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `PermitEmptyPasswords` parameter is disabled, organizations can enforce secure authentication practices, reduce the attack surface, and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To disable SSH PermitEmptyPasswords, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            PermitEmptyPasswords no
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To disable SSH PermitEmptyPasswords, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH PermitEmptyPasswords is disabled
              hosts: all
              become: true

              tasks:
                - name: Set PermitEmptyPasswords to no in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^PermitEmptyPasswords'
                    line: 'PermitEmptyPasswords no'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To disable SSH PermitEmptyPasswords, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^PermitEmptyPasswords' /etc/ssh/sshd_config; then
              echo "Updating PermitEmptyPasswords in sshd_config..."
              sed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' /etc/ssh/sshd_config
            else
              echo "Adding PermitEmptyPasswords to sshd_config..."
              echo "PermitEmptyPasswords no" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-permituserenvironment-is-disabled
    title: Ensure SSH PermitUserEnvironment is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitUserEnvironment"] == "no"
    docs:
      desc: |
        This check ensures that the `PermitUserEnvironment` option in the SSH configuration is disabled to prevent users from passing environment variables to the SSH daemon. Disabling this option helps maintain a secure and controlled SSH environment.

        **Why this matters**

        The `PermitUserEnvironment` option allows users to specify environment variables that are passed to the SSH daemon. If enabled:

        - Malicious users could exploit this feature to inject unauthorized environment variables, potentially compromising system security.
        - It increases the risk of privilege escalation or unauthorized access to sensitive resources.
        - System integrity and compliance with security policies could be jeopardized.

        By disabling the `PermitUserEnvironment` option, organizations can reduce the attack surface, maintain a secure SSH configuration, and ensure compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To disable SSH PermitUserEnvironment, edit the `/etc/ssh/sshd_config` file and add or modify the following line:

            ```bash
            PermitUserEnvironment no
            ```

            Restart the SSH service to apply the changes:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To disable SSH PermitUserEnvironment, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure SSH PermitUserEnvironment is disabled
              hosts: all
              become: true

              tasks:
                - name: Set PermitUserEnvironment to no in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^PermitUserEnvironment'
                    line: 'PermitUserEnvironment no'
                  register: ssh_config_change

                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: ssh_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To disable SSH PermitUserEnvironment, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^PermitUserEnvironment' /etc/ssh/sshd_config; then
              echo "Updating PermitUserEnvironment in sshd_config..."
              sed -i 's/^PermitUserEnvironment.*/PermitUserEnvironment no/' /etc/ssh/sshd_config
            else
              echo "Adding PermitUserEnvironment to sshd_config..."
              echo "PermitUserEnvironment no" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-only-strong-ciphers-are-used
    title: Ensure only strong ciphers are used
    impact: 100
    filters: package('openssh-server').installed
    props:
      - uid: mondooLinuxSecuritySshdCiphers
        title: Define the hardened ciphers for all SSH configurations
        mql: |
          if( package('openssh-server').version >= semver("6") && package('openssh-server').version < semver("7")  ) {
            return ["aes256-ctr", "aes192-ctr", "aes128-ctr"]
          }
          return ["chacha20-poly1305@openssh.com","aes256-gcm@openssh.com","aes128-gcm@openssh.com","aes256-ctr","aes192-ctr","aes128-ctr"]
    mql: |
      sshd.config.ciphers != empty
      sshd.config.ciphers.containsOnly(props.mondooLinuxSecuritySshdCiphers)
    docs:
      desc: |
        This check ensures that the SSH configuration limits the ciphers used during communication to secure and approved algorithms. Restricting the ciphers helps prevent the use of weak or deprecated encryption methods that could compromise the confidentiality and integrity of SSH sessions.

        **Why this matters**

        SSH is a critical protocol for secure remote access and management of systems. If weak or deprecated ciphers are allowed:

        - Attackers could exploit vulnerabilities in outdated encryption methods to intercept or manipulate SSH communications.
        - Sensitive data transmitted during SSH sessions could be exposed to unauthorized parties.
        - The overall security posture of the system could be weakened, increasing the risk of compromise.

        By enforcing the use of strong and approved ciphers, organizations can ensure secure SSH communication, protect sensitive data, and maintain compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To configure SSH to use only strong ciphers, edit the `/etc/ssh/sshd_config` file and add or modify the `Ciphers` parameter to include a comma-separated list of approved ciphers.

            Example:

            ```bash
            Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To configure SSH to use only strong ciphers, use the following Ansible playbook:

            ```yaml
            ---
            - name: Configure SSH to use only strong ciphers
              hosts: all
              become: true

              tasks:
                - name: Ensure Ciphers are set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^Ciphers'
                    line: 'Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr'
                    create: yes
                    state: present
                    register: ssh_ciphers_config_change
                - name: Restart SSH service to apply changes
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                    when: ssh_ciphers_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that only strong ciphers are used in SSH, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            CIPHER_LINE="Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr"

            if grep -q '^Ciphers' /etc/ssh/sshd_config; then
              echo "Updating Ciphers in sshd_config..."
              sed -i "s/^Ciphers.*/$CIPHER_LINE/" /etc/ssh/sshd_config
            else
              echo "Adding Ciphers to sshd_config..."
              echo "$CIPHER_LINE" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-only-strong-mac-algorithms-are-used
    title: Ensure only strong MAC algorithms are used
    impact: 80
    props:
      - uid: mondooLinuxSecurityMacAlgos
        title: Define the accepted MAC algorithms
        mql: |
          return ["umac-128-etm@openssh.com","hmac-sha2-256-etm@openssh.com","hmac-sha2-512-etm@openssh.com",
                  "umac-128@openssh.com","hmac-sha2-256","hmac-sha2-512"]
    mql: |
      sshd.config.macs != empty
      sshd.config.macs.containsOnly(props.mondooLinuxSecurityMacAlgos)
    docs:
      desc: |
        This check ensures that the types of MAC (Message Authentication Code) algorithms used by SSH during communication are restricted to secure and approved options. Limiting the MAC algorithms helps to prevent the use of weak or deprecated algorithms that could compromise the integrity of SSH connections.

        **Why this matters**

        SSH communication relies on MAC algorithms to ensure the integrity and authenticity of transmitted data. If insecure or outdated MAC algorithms are allowed:

        - Attackers could exploit vulnerabilities in weak algorithms to intercept or tamper with SSH communications.
        - The confidentiality and integrity of sensitive data transmitted over SSH could be compromised.
        - Compliance with security standards and best practices could be violated.

        By enforcing the use of secure MAC algorithms, organizations can strengthen the security of SSH connections, protect sensitive data, and maintain compliance with security policies.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To configure SSH to use only strong MAC algorithms, edit the `/etc/ssh/sshd_config` file and add or modify the `MACs` parameter to include a comma-separated list of approved MAC algorithms.

            Example:

            ```bash
            MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To configure SSH to use only strong MAC algorithms, use the following Ansible playbook:

            ```yaml
            ---
            - name: Configure SSH to use only strong MAC algorithms
              hosts: all
              become: true

              tasks:
                - name: Ensure MACs are set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^MACs'
                    line: 'MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256'
                    create: yes
                    state: present
                    register: ssh_mac_config_change
                - name: Restart SSH service if config changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                    when: ssh_mac_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that only strong MAC algorithms are used in SSH, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            MAC_LINE="MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256"

            if grep -q '^MACs' /etc/ssh/sshd_config; then
              echo "Updating MACs in sshd_config..."
              sed -i "s/^MACs.*/$MAC_LINE/" /etc/ssh/sshd_config
            else
              echo "Adding MACs to sshd_config..."
              echo "$MAC_LINE" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-only-strong-kex-algorithms-are-used
    title: Ensure that strong Key Exchange algorithms are used
    impact: 100
    filters: package('openssh-server').installed
    props:
      - uid: mondooLinuxSecurityKexAlgos
        title: Define the hardened key exchange algorithms for all SSH configurations
        mql: |
          if( package('openssh-server').version  >= semver("6") && package('openssh-server').version  < semver("7") ) {
            return ["curve25519-sha256@libssh.org"]
          }
          if( package('openssh-server').version  >= semver("7") && package('openssh-server').version  < semver("8") ) {
            return ["curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
          }
          if( package('openssh-server').version  >= semver("8") && package('openssh-server').version  < semver("9") ) {
            return ["sntrup4591761x25519-sha512@tinyssh.org","curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
          }
          return ["sntrup761x25519-sha512@openssh.com","curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
    mql: |
      sshd.config.kexs != empty
      sshd.config.kexs.containsOnly(props.mondooLinuxSecurityKexAlgos)
    docs:
      desc: |
        This check ensures that strong key exchange algorithms are used in the SSH configuration to secure the exchange of cryptographic keys between two parties. Key exchange is a critical component of cryptography, enabling secure communication by allowing both parties to establish a shared secret.

        **Why this matters**

        Key exchange algorithms play a vital role in establishing secure communication channels. If weak or outdated algorithms are used:

        - Attackers could exploit vulnerabilities to intercept or manipulate the key exchange process.
        - The confidentiality and integrity of encrypted communications could be compromised.
        - Compliance with security standards requiring strong cryptographic practices may be violated.

        By ensuring that only strong key exchange algorithms are used, organizations can protect sensitive data, maintain secure communications, and comply with cryptographic best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To configure SSH to use only approved key exchange algorithms, edit the `/etc/ssh/sshd_config` file and add or modify the `KexAlgorithms` parameter based on your `openssh-server` version.

            First, determine your SSH server version:

            ```bash
            cnquery run -c "package('openssh-server').version"
            ```

            Then, based on the version, set the appropriate `KexAlgorithms` value:

            - **OpenSSH 6.x**:
              ```
              KexAlgorithms curve25519-sha256@libssh.org
              ```

            - **OpenSSH 7.x**:
              ```
              KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
              ```

            - **OpenSSH 8.0 to 8.5**:
              ```
              KexAlgorithms sntrup4591761x25519-sha512@tinyssh.org,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
              ```

            - **OpenSSH 8.6 or later**:
              ```
              KexAlgorithms sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
              ```

            After editing the file, restart the SSH service:

            Debian/Ubuntu distros:

            ```bash
            systemctl restart ssh
            ```

            OR

            All other Linux distros:

            ```bash
            systemctl restart sshd
            ```
        - id: ansible
          desc: |
            **Using Ansible**
            To configure SSH to use only approved key exchange algorithms, use the following Ansible playbook:

            ```yaml
            ---
            - name: Configure SSH with approved KexAlgorithms based on OpenSSH version
              hosts: all
              become: true
              gather_facts: true
              tasks:
                - name: Get OpenSSH version from sshd binary
                  ansible.builtin.shell: |
                    /usr/sbin/sshd -v 2>&1 | grep -oP 'OpenSSH_\K\d+\.\d+'
                  register: sshd_version
                  changed_when: false
                  failed_when: sshd_version.rc != 0 or sshd_version.stdout == ""

                - name: Set parsed OpenSSH version
                  ansible.builtin.set_fact:
                    openssh_version_float: "{{ sshd_version.stdout | float }}"

                - name: Determine appropriate KexAlgorithms value
                  ansible.builtin.set_fact:
                    kexalgos: >-
                      {% if openssh_version_float < 7.0 %}
                        curve25519-sha256@libssh.org
                      {% elif openssh_version_float < 8.0 %}
                        curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
                      {% elif openssh_version_float < 8.6 %}
                        sntrup4591761x25519-sha512@tinyssh.org,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
                      {% else %}
                        sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
                      {% endif %}

                - name: Ensure KexAlgorithms is set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^KexAlgorithms'
                    line: "KexAlgorithms {{ kexalgos }}"
                    create: yes
                    state: present
                    register: kexalgos_config_change

                - name: Restart SSHD to apply configuration
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                    when: kexalgos_config_change.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that SSH uses only strong key exchange algorithms, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring SSH with strong KexAlgorithms"
            openssh_version=$(sshd -v 2>&1 | grep -oP 'OpenSSH_\K\d+\.\d+')

            if (( $(echo "$openssh_version < 7.0" | bc -l) )); then
              kex_algos="curve25519-sha256@libssh.org"
            elif (( $(echo "$openssh_version < 8.0" | bc -l) )); then
              kex_algos="curve25519-sha256@libssh.org,diffie-hellman-group18-sha512"
            elif (( $(echo "$openssh_version < 8.6" | bc -l) )); then
              kex_algos="sntrup4591761x25519-sha512@tinyssh.org,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512"
            else
              kex_algos="sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512"
            fi

            if grep -q '^KexAlgorithms' /etc/ssh/sshd_config; then
              echo "Updating existing KexAlgorithms configuration value"
              sed -i "s/^KexAlgorithms.*/KexAlgorithms $kex_algos/" /etc/ssh/sshd_config
            else
              echo "Adding KexAlgorithms configuration value to SSH config"
              echo "KexAlgorithms $kex_algos" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-idle-timeout-interval-is-configured
    title: Ensure SSH Idle Timeout Interval is configured
    impact: 60
    props:
      - uid: excludedMatchBlocks
        title: A list of match blocks to exclude from checking, add items such as "User ansible"
        mql: |
          return [
            "placeholder-do-not-delete",
          ]
      - uid: checkDefaultMatchBlock
        title: Set to true if you want to check the default "" match block
        mql: |
          return true
    mql: |
      defaultBlock = sshd.config.blocks.where(criteria.in([""]) == props.checkDefaultMatchBlock && criteria == "");

      userBlocks = sshd.config.blocks.where(criteria.contains(props.excludedMatchBlocks) == false && criteria != "");

      userBlocks.all(params.ClientAliveInterval >= 1)
      userBlocks.all(params.ClientAliveInterval <= 900)
      userBlocks.all(params.ClientAliveCountMax > 0)
      userBlocks.all(params.ClientAliveCountMax <= 3)

      defaultBlock.all(params.ClientAliveInterval >= 1)
      defaultBlock.all(params.ClientAliveInterval <= 900)
      defaultBlock.all(params.ClientAliveCountMax > 0)
      defaultBlock.all(params.ClientAliveCountMax <= 3)
    docs:
      desc: |
        This check ensures that the `ClientAliveInterval` and `ClientAliveCountMax` parameters in the SSH configuration are set to control the timeout of SSH sessions. These parameters help terminate idle SSH sessions after a specified period of inactivity.

        **Why this matters**

        The `ClientAliveInterval` parameter specifies the interval (in seconds) at which the SSH server sends keepalive messages to the client. The `ClientAliveCountMax` parameter determines the maximum number of keepalive messages sent without a response before terminating the session. If these parameters are not configured:

        - Idle SSH sessions may remain open indefinitely, increasing the risk of unauthorized access.
        - System resources may be consumed by inactive connections, potentially impacting performance.
        - Compliance with security policies requiring session timeouts may be compromised.

        By configuring `ClientAliveInterval` and `ClientAliveCountMax`, organizations can enforce session timeouts, reduce the risk of unauthorized access, and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the SSH idle timeout interval, edit the `/etc/ssh/sshd_config` file and add or modify the `ClientAliveInterval` and `ClientAliveCountMax` parameters.

            Example:

            ```bash
            ClientAliveInterval 300
            ClientAliveCountMax 0
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the SSH idle timeout interval using Ansible, use the following playbook:

            ```yaml
            ---
            - name: Configure SSH Idle Timeout Interval
              hosts: all
              become: true

              tasks:
                - name: Ensure ClientAliveInterval is set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^ClientAliveInterval'
                    line: 'ClientAliveInterval 300'
                    create: yes
                    state: present

                - name: Ensure ClientAliveCountMax is set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^ClientAliveCountMax'
                    line: 'ClientAliveCountMax 0'
                    create: yes
                    state: present
                - name: Restart SSH service to apply changes
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that SSH LoginGraceTime is set to one minute or less, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            if grep -q '^ClientAliveInterval' /etc/ssh/sshd_config; then
              echo "Updating existing ClientAliveInterval configuration value"
              sed -i 's/^ClientAliveInterval.*/ClientAliveInterval 300/' /etc/ssh/sshd_config
            else
              echo "Adding ClientAliveInterval configuration value to SSH config"
              echo 'ClientAliveInterval 300' >> /etc/ssh/sshd_config
            fi

            if grep -q '^ClientAliveCountMax' /etc/ssh/sshd_config; then
              echo "Updating existing ClientAliveCountMax configuration value"
              sed -i 's/^ClientAliveCountMax.*/ClientAliveCountMax 0/' /etc/ssh/sshd_config
            else
              echo "Adding ClientAliveCountMax configuration value to SSH config"
              echo 'ClientAliveCountMax 0' >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-logingracetime-is-set-to-one-minute-or-less
    title: Ensure SSH LoginGraceTime is set to one minute or less
    impact: 80
    mql: |
      sshd.config.params["LoginGraceTime"] >= 1
      sshd.config.params["LoginGraceTime"] <= 60
    docs:
      desc: |
        This check ensures that the `LoginGraceTime` parameter in the SSH configuration is set to an appropriate value, limiting the time allowed for successful authentication to the SSH server. This configuration helps reduce the risk of unauthenticated connections lingering on the system.

        **Why this matters**

        The `LoginGraceTime` parameter specifies the time (in seconds) allowed for successful authentication to the SSH server. If this value is set too high:

        - Unauthenticated connections may remain open for extended periods, increasing the risk of unauthorized access.
        - System resources may be consumed by idle connections, potentially impacting performance.
        - Compliance with security policies requiring strict session controls may be compromised.

        By setting the `LoginGraceTime` parameter to a minimal value, organizations can reduce the risk of unauthorized access, maintain system performance, and ensure compliance with security best practices.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the SSH LoginGraceTime, edit the `/etc/ssh/sshd_config` file and add or modify the `LoginGraceTime` parameter.

            Example:

            ```bash
            LoginGraceTime 60
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the SSH LoginGraceTime using Ansible, use the following playbook:

            ```yaml
            ---
            - name: Configure SSH LoginGraceTime
              hosts: all
              become: true

              tasks:
                - name: Ensure LoginGraceTime is set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^LoginGraceTime'
                    line: 'LoginGraceTime 60'
                    create: yes
                    state: present
              - name: Restart SSH service to apply changes
                ansible.builtin.systemd:
                  name: sshd
                  state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that SSH access is limited, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Configuring SSH access restrictions"
            echo "AllowUsers user1 user2" >> /etc/ssh/sshd_config
            echo "AllowGroups sshusers" >> /etc/ssh/sshd_config
            echo "DenyUsers user3" >> /etc/ssh/sshd_config
            echo "DenyGroups nogroup" >> /etc/ssh/sshd_config

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-access-is-limited
    title: Ensure SSH access is limited
    impact: 60
    mql: |
      sshd.config.params["AllowUsers"] != empty || sshd.config.params["AllowGroups"] != empty || sshd.config.params["DenyUsers"] != empty || sshd.config.params["DenyGroups"] != empty

      if (sshd.config.params["AllowUsers"] != empty) { sshd.config.params["AllowUsers"] != "" }
      if (sshd.config.params["AllowGroups"] != empty) { sshd.config.params["AllowGroups"] != "" }
      if (sshd.config.params["DenyUsers"] != empty) { sshd.config.params["DenyUsers"] != "" }
      if (sshd.config.params["DenyGroups"] != empty) { sshd.config.params["DenyGroups"] != "" }
    docs:
      desc: |
        This check ensures that SSH access is restricted to specific users or groups by configuring the `AllowUsers`, `AllowGroups`, `DenyUsers`, or `DenyGroups` parameters in the `/etc/ssh/sshd_config` file. These options provide granular control over who can access the system via SSH.

        **Why this matters**

        Restricting SSH access to authorized users and groups is critical for maintaining system security. If SSH access is not properly restricted:

        - Unauthorized users could gain access to the system, potentially compromising sensitive data or escalating privileges.
        - Malicious actors could exploit open access to perform brute-force attacks or other unauthorized actions.
        - System integrity and compliance with security policies could be jeopardized.

        By configuring the `AllowUsers`, `AllowGroups`, `DenyUsers`, or `DenyGroups` parameters, organizations can enforce strict access controls, reduce the attack surface, and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To limit SSH access, edit the `/etc/ssh/sshd_config` file and add or modify the `AllowUsers`, `AllowGroups`, `DenyUsers`, or `DenyGroups` parameters as needed.

            Example:

            ```bash
            AllowUsers user1 user2
            AllowGroups sshusers
            DenyUsers user3
            DenyGroups nogroup
            ```
        - id: ansible
          desc: |
            **Using Ansible**
            To limit SSH access using Ansible, use the following playbook:

            ```yaml
            ---
            - name: Restrict SSH access using AllowUsers, AllowGroups, DenyUsers, and DenyGroups
              hosts: all
              become: true
              vars:
                ssh_allow_users: "user1 user2"
                ssh_allow_groups: "sshusers"
                ssh_deny_users: "user3"
                ssh_deny_groups: "nogroup"

              tasks:
                - name: Set AllowUsers in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^AllowUsers'
                    line: "AllowUsers {{ ssh_allow_users }}"
                    create: yes
                    state: present
                  register: allow_users_changed

                - name: Set AllowGroups in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^AllowGroups'
                    line: "AllowGroups {{ ssh_allow_groups }}"
                    create: yes
                    state: present
                  register: allow_groups_changed

                - name: Set DenyUsers in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^DenyUsers'
                    line: "DenyUsers {{ ssh_deny_users }}"
                    create: yes
                    state: present
                  register: deny_users_changed

                - name: Set DenyGroups in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^DenyGroups'
                    line: "DenyGroups {{ ssh_deny_groups }}"
                    create: yes
                    state: present
                  register: deny_groups_changed

                - name: Restart sshd if any config was changed
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
                  when: >
                    allow_users_changed.changed or
                    allow_groups_changed.changed or
                    deny_users_changed.changed or
                    deny_groups_changed.changed
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that SSH access is limited, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            # Define variables for users and groups
            ALLOW_USERS="user1 user2"
            ALLOW_GROUPS="sshusers"
            DENY_USERS="user3"
            DENY_GROUPS="nogroup"

            if grep -q '^AllowUsers' /etc/ssh/sshd_config; then
              echo "Updating existing AllowUsers configuration value"
              sed -i "s/^AllowUsers.*/AllowUsers $ALLOW_USERS/" /etc/ssh/sshd_config
            else
              echo "Adding AllowUsers configuration value to SSH config"
              echo "AllowUsers $ALLOW_USERS" >> /etc/ssh/sshd_config
            fi

            # Set or update AllowGroups
            if grep -q '^AllowGroups' /etc/ssh/sshd_config; then
              echo "Updating existing AllowGroups configuration value"
              sed -i "s/^AllowGroups.*/AllowGroups $ALLOW_GROUPS/" /etc/ssh/sshd_config
            else
              echo "Adding AllowGroups configuration value to SSH config"
              echo "AllowGroups $ALLOW_GROUPS" >> /etc/ssh/sshd_config
            fi

            # Set or update DenyUsers
            if grep -q '^DenyUsers' /etc/ssh/sshd_config; then
              echo "Updating existing DenyUsers configuration value"
              sed -i "s/^DenyUsers.*/DenyUsers $DENY_USERS/" /etc/ssh/sshd_config
            else
              echo "Adding DenyUsers configuration value to SSH config"
              echo "DenyUsers $DENY_USERS" >> /etc/ssh/sshd_config
            fi

            # Set or update DenyGroups
            if grep -q '^DenyGroups' /etc/ssh/sshd_config; then
              echo "Updating existing DenyGroups configuration value"
              sed -i "s/^DenyGroups.*/DenyGroups $DENY_GROUPS/" /etc/ssh/sshd_config
            else
              echo "Adding DenyGroups configuration value to SSH config"
              echo "DenyGroups $DENY_GROUPS" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-ssh-warning-banner-is-configured
    title: Ensure SSH warning banner is configured
    impact: 30
    mql: |
      sshd.config.params["Banner"] == "/etc/issue.net"
    docs:
      desc: |
        This check ensures that the `Banner` parameter in the SSH configuration is set to display a warning banner to remote users before authentication. The banner file typically contains legal or security notices to inform users of acceptable use policies.

        **Why this matters**

        Displaying a warning banner before authentication serves several purposes:

        - It informs users of the system's acceptable use policy and legal restrictions.
        - It provides a deterrent to unauthorized access by clearly stating the consequences of misuse.
        - It supports compliance with security standards and regulatory requirements that mandate the use of warning banners.

        By ensuring that the `Banner` parameter is configured, organizations can enhance security awareness, deter unauthorized access, and maintain compliance with security policies.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the SSH warning banner, edit the `/etc/ssh/sshd_config` file and add or modify the `Banner` parameter to point to the desired banner file.

            Example:

            ```bash
            Banner /etc/issue.net
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the SSH warning banner using Ansible, use the following playbook:

            ```yaml
            ---
            - name: Configure SSH warning banner
              hosts: all
              become: true

              tasks:
                - name: Ensure Banner is set in sshd_config
                  ansible.builtin.lineinfile:
                    path: /etc/ssh/sshd_config
                    regexp: '^Banner'
                    line: 'Banner /etc/issue.net'
                    create: yes
                    state: present
                - name: Restart SSH service to apply changes
                  ansible.builtin.systemd:
                    name: sshd
                    state: restarted
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the SSH warning banner is configured, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting SSH warning banner"
            if grep -q '^Banner' /etc/ssh/sshd_config; then
              echo "Updating existing Banner configuration value"
              sed -i 's|^Banner.*|Banner /etc/issue.net|' /etc/ssh/sshd_config
            else
              echo "Adding Banner configuration value to SSH config"
              echo "Banner /etc/issue.net" >> /etc/ssh/sshd_config
            fi

            systemctl restart sshd
            ```
  - uid: mondoo-linux-security-permissions-on-etcpasswd-are-configured
    title: Ensure secure permissions on /etc/passwd are set
    impact: 100
    mql: |
      file("/etc/passwd") {
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that the `/etc/passwd` file, which contains user account information, is secured with appropriate permissions. The file must be readable for system utilities to operate correctly, but write access should be restricted to the root user to prevent unauthorized modifications.

        **Why this matters**

        The `/etc/passwd` file is critical for managing user accounts and system operations. If this file is improperly secured:

        - Unauthorized users could modify account information, potentially escalating privileges or disrupting system operations.
        - Malicious actors could exploit this information to compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has write access to the `/etc/passwd` file, organizations can protect critical account data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on the `/etc/passwd` file, run the following commands:

            ```bash
            chown root:root /etc/passwd
            chmod 644 /etc/passwd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/passwd` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/passwd
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/passwd
                  ansible.builtin.file:
                    path: /etc/passwd
                    owner: root
                    group: root
                    mode: '0644'
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/passwd` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/passwd"
            chown root:root /etc/passwd
            chmod 0644 /etc/passwd
            echo "f /etc/passwd 0644 root root -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcshadow-are-configured
    title: Ensure secure permissions on /etc/shadow are set
    impact: 100
    mql: |
      if (file("/etc/shadow").exists) {
        file("/etc/shadow") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/shadow` file, which stores sensitive information about user accounts, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to critical account data.

        **Why this matters**

        The `/etc/shadow` file contains hashed passwords and other security-related information for user accounts. If this file is improperly secured:

        - Unauthorized users could access sensitive password data.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/shadow` file, organizations can protect critical account data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on the `/etc/shadow` file, run the following commands:

            ```bash
            chown root:shadow /etc/shadow
            chmod 640 /etc/shadow
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/shadow` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/shadow
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/shadow
                  ansible.builtin.file:
                    path: /etc/shadow
                    owner: root
                    group: shadow
                    mode: '0640'
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/shadow` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/shadow"
            chown root:shadow /etc/shadow
            chmod 0640 /etc/shadow
            echo "f /etc/shadow 0640 root shadow -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcgroup-are-configured
    title: Ensure secure permissions on /etc/group are set
    impact: 100
    mql: |
      file("/etc/group") {
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that the `/etc/group` file, which contains a list of all valid groups defined in the system, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized modifications to group definitions.

        **Why this matters**

        The `/etc/group` file defines group memberships on the system. If this file is improperly secured:

        - Unauthorized users could modify group definitions, potentially escalating privileges or disrupting access control.
        - Malicious actors could exploit this information to compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/group` file, organizations can protect critical group membership data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on the `/etc/group` file, run the following commands:

            ```bash
            chown root:root /etc/group
            chmod 644 /etc/group
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/group` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/group
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/group
                  ansible.builtin.file:
                    path: /etc/group
                    owner: root
                    group: root
                    mode: '0644'
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/group` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/group"
            chown root:root /etc/group
            chmod 0644 /etc/group
            echo "f /etc/group 0644 root root -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcgshadow-are-configured
    title: Ensure secure permissions on /etc/gshadow are set
    impact: 100
    mql: |
      if (file("/etc/gshadow").exists) {
        file("/etc/gshadow") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |-
        This check ensures that the `/etc/gshadow` file, which stores hashed group passwords, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive group password information.

        **Why this matters**

        The `/etc/gshadow` file serves as a companion to `/etc/group`, listing group memberships while storing sensitive password information. If this file is improperly secured:

        - Unauthorized users could access sensitive group password data.
        - Malicious actors could exploit this information to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/gshadow` file, organizations can protect critical group password data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To set the ownership and permissions on the `/etc/gshadow` file, run the following commands:

            ```bash
            chown root:shadow /etc/gshadow
            chmod 640 /etc/gshadow
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/gshadow` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/gshadow
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/gshadow
                  ansible.builtin.file:
                    path: /etc/gshadow
                    owner: root
                    group: root
                    mode: '0640'
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/gshadow` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/gshadow"
            chown root:shadow /etc/gshadow
            chmod 0640 /etc/gshadow
            echo "f /etc/gshadow 0640 root shadow -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcpasswd--are-configured
    title: Ensure secure permissions on /etc/passwd- are set
    impact: 100
    mql: |
      if (file("/etc/passwd-").exists) {
        file("/etc/passwd-") {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/passwd-` file, which contains a backup of the `/etc/passwd` file, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive user account information.

        **Why this matters**

        The `/etc/passwd-` file serves as a backup for the `/etc/passwd` file, which stores essential information about system users. If this file is improperly secured:

        - Unauthorized users could access sensitive user account information.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/passwd-` file, organizations can protect critical user account data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To set the ownership and permissions on the `/etc/passwd-` file, run the following commands:

                ```bash
                chown root:root /etc/passwd-
                chmod 600 /etc/passwd-
                ```

            2. To ensure these permissions are not reverted by automated actions, add the following line to `/etc/tmpfiles.d/etc.conf`:

                ```
                f /etc/passwd- 0600 root root -
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/passwd-` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/passwd-
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/passwd-
                  ansible.builtin.file:
                    path: /etc/passwd-
                    owner: root
                    group: root
                    mode: '0600'
                - name: Ensure /etc/passwd- is not reverted
                  ansible.builtin.lineinfile:
                    path: /etc/tmpfiles.d/etc.conf
                    line: 'f /etc/passwd- 0600 root root -'
                    state: present
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/passwd-` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/passwd-"
            chown root:root /etc/passwd-
            chmod 0600 /etc/passwd-
            echo "f /etc/passwd- 0600 root root -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcshadow--are-configured
    title: Ensure secure permissions on /etc/shadow- are set
    impact: 100
    mql: |
      if (file("/etc/shadow-").exists) {
        file("/etc/shadow-") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/shadow-` file, which contains a backup of the `/etc/shadow` file, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive user account information.

        **Why this matters**

        The `/etc/shadow-` file serves as a backup for the `/etc/shadow` file, which stores hashed passwords and other critical security information about user accounts. If this file is improperly secured:

        - Unauthorized users could access sensitive password data.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/shadow-` file, organizations can protect critical user account data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To set the ownership and permissions on the `/etc/shadow-` file, run the following commands:

                ```bash
                chown root:shadow /etc/shadow-
                chmod 640 /etc/shadow-
                ```

            2. To ensure these permissions are not reverted by automated actions, add the following line to `/etc/tmpfiles.d/etc.conf`:

                ```
                f /etc/shadow- 0640 root shadow -
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/shadow-` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/shadow-
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/shadow-
                  ansible.builtin.file:
                  ansible.builtin.file:
                    path: /etc/shadow-
                    owner: root
                    group: shadow
                    mode: '0640'
                - name: Ensure /etc/shadow- is not reverted
                  ansible.builtin.lineinfile:
                    path: /etc/tmpfiles.d/etc.conf
                    line: 'f /etc/shadow- 0640 root shadow -'
                    state: present
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/shadow-` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/shadow-"
            chown root:shadow /etc/shadow-
            chmod 0640 /etc/shadow-
            echo "f /etc/shadow- 0640 root shadow -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcgroup--are-configured
    title: Ensure secure permissions on /etc/group- are set
    impact: 100
    mql: |
      if (file("/etc/group-").exists) {
        file("/etc/group-") {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/group-` file, which contains a backup of all valid groups defined in the system, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to group names and user membership information.

        **Why this matters**

        The `/etc/group-` file serves as a backup for the `/etc/group` file, which defines group memberships on the system. If this file is improperly secured:

        - Unauthorized users could access sensitive group membership information.
        - Malicious actors could exploit this information to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/group-` file, organizations can protect critical group membership data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To set the ownership and permissions on the `/etc/group-` file, run the following commands:

                ```bash
                chown root:root /etc/group-
                chmod 600 /etc/group-
                ```

            2. To ensure these permissions are not reverted by automated actions, add the following line to `/etc/tmpfiles.d/etc.conf`:

                ```
                f /etc/group- 0600 root root -
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/group-` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/group-
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/group-
                  ansible.builtin.file:
                    path: /etc/group-
                    owner: root
                    group: root
                    mode: '0600'
                - name: Ensure /etc/group- is not reverted
                  ansible.builtin.lineinfile:
                    path: /etc/tmpfiles.d/etc.conf
                    line: 'f /etc/group- 0600 root root -'
                    state: present
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/group-` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/group-"
            chown root:root /etc/group-
            chmod 0600 /etc/group-
            echo "f /etc/group- 0600 root root -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-permissions-on-etcgshadow--are-configured
    title: Ensure secure permissions on /etc/gshadow- are set
    impact: 100
    mql: |
      if (file("/etc/gshadow-").exists) {
        file("/etc/gshadow-") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/gshadow-` file, which contains a backup of the `/etc/gshadow` file, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive group password information.

        **Why this matters**

        The `/etc/gshadow-` file serves as a backup for the `/etc/gshadow` file, which stores information about group administrators, group members, and encrypted group passwords. If this file is improperly secured:

        - Unauthorized users could access sensitive group password information.
        - Malicious actors could exploit this information to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/gshadow-` file, organizations can protect critical group password data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To set the ownership and permissions on the `/etc/gshadow-` file, run the following commands:

                ```bash
                chown root:root /etc/gshadow-
                chmod 640 /etc/gshadow-
                ```

            2. To ensure these permissions are not reverted by automated actions, add the following line to `/etc/tmpfiles.d/etc.conf`:

                ```
                f /etc/gshadow- 0640 root root -
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To set the ownership and permissions on the `/etc/gshadow-` file, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set ownership and permissions on /etc/gshadow-
              hosts: all
              become: true

              tasks:
                - name: Set correct ownership and permissions on /etc/gshadow-
                  ansible.builtin.file:
                    path: /etc/gshadow-
                    owner: root
                    group: root
                    mode: '0640'
                - name: Ensure /etc/gshadow- is not reverted
                  ansible.builtin.lineinfile:
                    path: /etc/tmpfiles.d/etc.conf
                    line: 'f /etc/gshadow- 0640 root root -'
                    state: present
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `/etc/gshadow-` file has the correct permissions, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting ownership and permissions on /etc/gshadow-"
            chown root:root /etc/gshadow-
            chmod 0640 /etc/gshadow-
            echo "f /etc/gshadow- 0640 root root -" >> /etc/tmpfiles.d/etc.conf
            ```
  - uid: mondoo-linux-security-no-duplicate-uids-exist
    title: Ensure no duplicate UIDs exist
    impact: 80
    mql: |
      users.list.duplicates(uid).none()
    docs:
      desc: |
        This check ensures that each user ID (UID), login name, and group ID (GID) is unique across the system. Duplicate UIDs, user names, or GIDs can lead to security and operational issues, making it critical to maintain uniqueness.

        **Why this matters**

        Unique UIDs, user names, and GIDs are essential for proper system management and security. If duplicates exist:

        - It becomes difficult to track user activity and file ownership, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in user or group identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that UIDs, user names, and GIDs are unique, organizations can maintain a secure and well-functioning system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure no duplicate UIDs exist, you can use the following command to list users with duplicate UIDs:

            ```bash
            awk -F: '{print $3}' /etc/passwd | sort | uniq -d
            ```

            If duplicates are found, you can change the UID of a user using the `usermod` command:

            ```bash
            usermod -u <new uid> <user>
            ```
  - uid: mondoo-linux-security-no-duplicate-user-names-exist
    title: Ensure no duplicate user names exist
    impact: 80
    mql: |
      users.list.duplicates(name).none()
    docs:
      desc: |
        This check ensures that each user name in the system is unique and does not have duplicates in the `/etc/passwd` file. Unique user names are critical for maintaining proper user identification and system security.

        **Why this matters**

        Duplicate user names can lead to confusion and security risks:

        - It becomes difficult to track user activity and file ownership, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in user identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that user names are unique, organizations can maintain a secure and well-functioning system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure no duplicate user names exist, you can use the following command to list users with duplicate names:

            ```bash
            awk -F: '{print $1}' /etc/passwd | sort | uniq -d
            ```

            If duplicates are found, you can change the user name of a user using the `usermod` command:

            ```bash
            usermod -l <new login-name> <old username>
            ```
  - uid: mondoo-linux-security-no-duplicate-gids-exist
    title: Ensure no duplicate GIDs exist
    impact: 80
    mql: |
      groups.list.duplicates(gid).none()
    docs:
      desc: |
        This check ensures that each group ID (GID) in the system is unique and does not have duplicates in the `/etc/group` file. Unique GIDs are critical for maintaining proper group identification and system security.

        **Why this matters**

        Duplicate GIDs can lead to confusion and security risks:

        - It becomes difficult to track group ownership and permissions, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in group identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that GIDs are unique, organizations can maintain a secure and well-functioning system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure no duplicate GIDs exist, you can use the following command to list groups with duplicate GIDs:

            ```bash
            awk -F: '{print $3}' /etc/group | sort | uniq -d
            ```

            If duplicates are found, you can change the GID of a group using the `groupmod` command:

            ```bash
            groupmod -g <new gid> <old groupname>
            ```
  - uid: mondoo-linux-security-no-duplicate-group-names-exist
    title: Ensure no duplicate group names exist
    impact: 80
    mql: |
      groups.list.duplicates(name).none()
    docs:
      desc: |
        This check ensures that each login name, user ID (UID), and group ID (GID) is unique across the system. It also ensures that every user is a member of at least one group, and that every GID mentioned in the `/etc/passwd` file is defined in the `/etc/group` file.

        **Why this matters**

        Unique UIDs, user names, and GIDs are essential for proper system management and security. If duplicates or inconsistencies exist:

        - It becomes difficult to track user activity and file ownership, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in user or group identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that UIDs, user names, and GIDs are unique, and that group memberships are properly defined, organizations can maintain a secure and well-functioning system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure no duplicate group names exist, you can use the following command to list groups with duplicate names:

            ```bash
            awk -F: '{print $1}' /etc/group | sort | uniq -d
            ```

            If duplicates are found, you can change the group name of a group using the `groupmod` command:

            ```bash
            groupmod -n <new group name> <old groupname>
            ```
  - uid: mondoo-linux-security-default-group-for-the-root-account-is-gid-0
    title: Ensure default group for the root account is GID 0
    impact: 80
    mql: |
      users.where(name == "root").list.all(gid == 0)
    docs:
      desc: |
        This check ensures that the default group for the root account is set to GID 0, which is the standard group for administrative privileges on Linux systems. This configuration ensures proper access control and consistency in file ownership and permissions.

        **Why this matters**

        The root account is the most privileged account on a Linux system. Ensuring that its default group is set to GID 0 is critical for maintaining system security and proper access control. If the root account is assigned to a different group:

        - Files created by the root user may have incorrect group ownership, leading to potential security risks.
        - System utilities and processes that rely on the root group may behave unpredictably.
        - Compliance with security standards and best practices may be compromised.

        By ensuring that the root account's default group is GID 0, organizations can maintain a secure and consistent system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Run this command to set the `root` user default group to GID `0`:

            ```bash
            usermod -g 0 root
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To ensure that the default group for the root account is set to GID 0, you can use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure default group for root account is GID 0
              hosts: all
              become: true

              tasks:
                - name: Set root user default group to GID 0
                  ansible.builtin.user:
                    name: root
                    group: 0
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the default group for the root account is set to GID 0, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting default group for root account to GID 0"
            usermod -g 0 root
            ```
  - uid: mondoo-linux-security-each-user-member-of-a-group
    title: Ensure each user is a member of a group
    impact: 70
    mql: |
      users.list.all(gid != empty)
    docs:
      desc: |
        This check ensures that each user is a member of at least one group, as defined in the `/etc/group` file. Group memberships are essential for managing access control and permissions on Linux systems.

        **Why this matters**

        Group memberships provide a mechanism for assigning permissions and access rights to multiple users. If a user is not a member of any group:

        - The user may lack necessary permissions to access files or resources.
        - System administrators may face challenges in managing access control effectively.
        - Compliance with security policies that require group-based access control may be compromised.

        By ensuring that each user is a member of at least one group, organizations can maintain proper access control, streamline user management, and enhance system security.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure that each user is a member of a group, you can run the following command to list users who are not members of any group:

            ```bash
            awk -F: '($4 == "") {print $1}' /etc/passwd
            ```

            If any users are found without a group, you can add them to a primary group using the `usermod` command:

            ```bash
            usermod -g <primary group> <user>
            ```
  - uid: mondoo-linux-security-gid-in-passwd-exists-in-group
    title: Ensure all GIDs in /etc/passwd exist in /etc/group
    impact: 80
    mql: |
      users.list.all(group != empty)
    docs:
      desc: |
        This check ensures that every GID mentioned in the `/etc/passwd` file is defined in the `/etc/group` file. This ensures consistency and proper mapping of user groups across the system.

        **Why this matters**

        The `/etc/passwd` file associates users with their respective GIDs, while the `/etc/group` file defines the groups and their memberships. If a GID in `/etc/passwd` is not defined in `/etc/group`:

        - Users may encounter issues with group-based permissions and access control.
        - System utilities and applications may behave unpredictably due to missing group definitions.
        - Compliance with security policies requiring proper group management may be compromised.

        By ensuring that all GIDs in `/etc/passwd` exist in `/etc/group`, organizations can maintain a consistent and secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To ensure that all GIDs in `/etc/passwd` exist in `/etc/group`, you can run the following command to list GIDs that are not defined in `/etc/group`:

            ```bash
            awk -F: '{print $4}' /etc/passwd | sort | uniq | comm -13 <(cut -d: -f3 /etc/group | sort) -
            ```

            If any GIDs are found that do not exist in `/etc/group`, you can create a group for each missing GID using the `groupadd` command:

            ```bash
            groupadd -g <gid> <groupname>
            ```
  - uid: mondoo-linux-security-uid-min-is-set-to-1000
    title: Ensure UID_MIN is set to 1000
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      logindefs.params{ _['UID_MIN'] == 1000 }
    docs:
      desc: |
        This check ensures that the `UID_MIN` parameter in the `/etc/login.defs` file is set to 1000, which defines the starting UID for newly created user accounts. This configuration ensures consistency and proper user management on the system.

        **Why this matters**

        The `UID_MIN` parameter determines the range of UIDs assigned to regular user accounts. If this value is not set correctly:

        - User accounts may overlap with system accounts, leading to potential security and operational issues.
        - System utilities and applications may behave unpredictably due to conflicts in UID assignments.
        - Compliance with security policies requiring separation of system and user accounts may be compromised.

        By ensuring that `UID_MIN` is set to 1000, organizations can maintain a secure and consistent user management configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            Edit the `/etc/login.defs` file and set UID_MIN:

            ```
            UID_MIN                  1000
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To ensure that `UID_MIN` is set to 1000, you can use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure UID_MIN is set to 1000
              hosts: all
              become: true

              tasks:
                - name: Set UID_MIN in /etc/login.defs
                  ansible.builtin.lineinfile:
                    path: /etc/login.defs
                    regexp: '^UID_MIN'
                    line: 'UID_MIN                  1000'
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that `UID_MIN` is set to 1000, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting UID_MIN to 1000 in /etc/login.defs"
            if grep -q '^UID_MIN' /etc/login.defs; then
              sed -i 's/^UID_MIN.*/UID_MIN                  1000/' /etc/login.defs
            else
              echo 'UID_MIN                  1000' >> /etc/login.defs
            fi
            ```
  - uid: mondoo-linux-security-shadow-group-is-empty
    title: Ensure shadow group is empty
    impact: 80
    mql: |
      groups.where(name == "shadow").all(members.length == 0)
    docs:
      desc: |
        This check ensures that the `shadow` group, which allows access to the `/etc/shadow` file, is empty. No users should be assigned to this group to prevent unauthorized access to sensitive password information.

        **Why this matters**

        The `shadow` group provides access to the `/etc/shadow` file, which contains hashed passwords and other sensitive account information. If users are improperly assigned to this group:

        - Unauthorized users could gain access to sensitive password data.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `shadow` group is empty, organizations can protect critical account data and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To ensure that the `shadow` group is empty, you can run the following command to remove all users from the `shadow` group:

                ```bash
                gpasswd -d <user> shadow
                ```

            2. To change the primary group of any users with `shadow` as their primary group, you can run:

                ```bash
                usermod -g <new_group> <user>
                ```

                Replace `<user>` with the username and `<new_group>` with the desired primary group.
        - id: ansible
          desc: |
            **Using Ansible**

            To ensure that the `shadow` group is empty, you can use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure shadow group is empty
              hosts: all
              become: true

              tasks:
                - name: Remove users from shadow group
                  ansible.builtin.user:
                    name: "{{ item }}"
                    groups: shadow
                    state: absent
                  loop: "{{ ansible_users | selectattr('groups', 'contains', 'shadow') | map(attribute='name') | list }}"

                - name: Change primary group for users in shadow group
                  ansible.builtin.user:
                    name: "{{ item }}"
                    group: <new_group>
                  loop: "{{ ansible_users | selectattr('gid', 'eq', 42) | map(attribute='name') | list }}"
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `shadow` group is empty, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Removing users from shadow group"
            for user in $(getent group shadow | cut -d: -f4 | tr ',' ' '); do
              echo "Removing $user from shadow group"
              gpasswd -d $user shadow || true
            done

            echo "Changing primary group for users in shadow group"
            for user in $(getent passwd | awk -F: '$4 == 42 {print $1}'); do
              usermod -g <new_group> $user || true
            done
            ```
  - uid: mondoo-linux-security-root-group-is-empty
    title: Ensure root group is empty
    impact: 100
    mql: |
      groups.where(name == "root").all(members == empty || members.all(name == 'root'))
    docs:
      desc: |
        This check ensures that the `root` group, which allows system programs or defined users the ability to read and write configurations and files on the system, is properly secured by ensuring no users other than the `root` user are assigned to it.

        **Why this matters**

        The `root` group provides elevated privileges that can impact the security and stability of the system. If unauthorized users are assigned to the `root` group:

        - They could gain access to sensitive system configurations and files.
        - Malicious actors could exploit this access to compromise system security or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the `root` user is assigned to the `root` group, organizations can maintain a secure and well-functioning system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To remove all users from the `root` group, you can run the following command:

                ```bash
                gpasswd -d <user> root
                ```

            2. To change the primary group of any users with `root` as their primary group, except the `root` user, you can run:

                ```bash
                usermod -g <new_group> <user>
                ```

                Replace `<user>` with the username and `<new_group>` with the desired primary group.
        - id: ansible
          desc: |
            **Using Ansible**

            To ensure that the `root` group is empty, you can use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure root group is empty
              hosts: all
              become: true

              tasks:
                - name: Remove users from root group
                  ansible.builtin.user:
                    name: "{{ item }}"
                    groups: root
                    state: absent
                  loop: "{{ ansible_users | selectattr('name', 'ne', 'root') | map(attribute='name') | list }}"

                - name: Change primary group for users in root group
                  ansible.builtin.user:
                    name: "{{ item }}"
                    group: <new_group>
                  loop: "{{ ansible_users | selectattr('gid', 'eq', 0) | map(attribute='name') | list }}"
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that the `root` group is empty, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Removing users from root group"
            for user in $(getent group root | cut -d: -f4 | tr ',' ' '); do
              if [ "$user" != "root" ]; then
                echo "Removing $user from root group"
                gpasswd -d $user root || true
              fi
            done

            echo "Changing primary group for users in root group"
            for user in $(getent passwd | awk -F: '$4 == 0 {print $1}'); do
              if [ "$user" != "root" ]; then
                usermod -g <new_group> $user || true
              fi
            done
            ```
  - uid: mondoo-linux-security-system-accounts-are-non-login
    title: Ensure system accounts are non-login
    impact: 70
    mql: |
      users.where( name != "root" && name != "sync" && name != "shutdown" && name != "halt" ).where( uid < 1000 ).list {
        shell == "/usr/bin/nologin" || shell == "/sbin/nologin" || shell == "/usr/sbin/nologin"
      }
    docs:
      desc: |
        This check ensures that system accounts, which are used to manage applications and services, are configured as non-login accounts. These accounts do not require a shell for interactive use.

        **Why this matters**

        System accounts are intended for managing applications and services, not for interactive user access. If these accounts are configured with login shells:

        - Unauthorized users could exploit these accounts to gain access to the system.
        - Malicious actors could use these accounts to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that system accounts are non-login, organizations can reduce the attack surface and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            1. To list all system accounts (UID < 1000, excluding root) where /sbin/nologin is not the shell, run:

                ```bash
                awk -F: '($3 < 1000 && $1 != "root" && $7 != "/sbin/nologin") {print $1}' /etc/passwd
                ```

            2. To set the shell for each system account to `/sbin/nologin`, run:

                ```bash
                usermod -s /sbin/nologin <user>
                ```

            3. Lock the `sync`, `shutdown`, and `halt` users to prevent login:

                ```bash
                usermod -L sync
                usermod -L shutdown
                usermod -L halt
                ```
        - id: ansible
          desc: |
            **Using Ansible**

            To ensure that system accounts are non-login, you can use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure system accounts are non-login
              hosts: all
              become: true

              tasks:
                - name: Set shell for system accounts to /sbin/nologin
                  ansible.builtin.user:
                    name: "{{ item }}"
                    shell: /sbin/nologin
                  loop: "{{ ansible_users | selectattr('uid', 'lt', 1000) | map(attribute='name') | list }}"

                - name: Lock sync, shutdown, and halt users
                  ansible.builtin.user:
                    name: "{{ item }}"
                    state: locked
                  loop:
                    - sync
                    - shutdown
                    - halt
            ```
        - id: bash
          desc: |
            **Using a Bash Script**

            To ensure that all system accounts are non-login, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Setting shell for system accounts to /sbin/nologin"
            for user in $(awk -F: '($3 < 1000 && $1 != "root") {print $1}' /etc/passwd); do
              echo "Setting nologin shell for user: $user"
              usermod -s /sbin/nologin $user
            done

            echo "Locking sync, shutdown, and halt users"
            usermod -L sync
            usermod -L shutdown
            usermod -L halt
            ```
  - uid: mondoo-linux-security-access-to-the-su-command-is-restricted
    title: Ensure access to the su command is restricted
    impact: 80
    filters: |
      asset.kind != "container-image"
    props:
      - uid: mondooLinuxSecuritySudoGroup
        title: Define the members of the sudo or wheel group
        mql: |
          return /root|ec2-user|centos|ubuntu|admin|mondoo/
    mql: |
      pam.conf.entries["/etc/pam.d/su"].where(pamType == "auth" && module == "pam_wheel.so").any(options.contains("use_uid"))
      groups.any(name == "wheel" || name == "sudo")
      groups.where(name == "wheel" || name == "sudo") {
        members {
          name
          name == props.mondooLinuxSecuritySudoGroup
        }
      }
    docs:
      desc: |
        This check ensures that access to the `su` command is restricted to authorized users by configuring the `pam_wheel.so` module in the `/etc/pam.d/su` file. This configuration limits the use of the `su` command to members of the `wheel` or `sudo` group, enhancing system security.

        **Why this matters**

        The `su` command allows a user to switch to another user account, including the root account, without logging out. If unrestricted:

        - Unauthorized users could gain elevated privileges, potentially compromising system security.
        - Malicious actors could exploit the `su` command to escalate privileges or perform unauthorized actions.
        - System integrity and compliance with security policies could be jeopardized.

        By restricting access to the `su` command, organizations can ensure that only authorized users can perform privileged actions, reducing the risk of unauthorized access and maintaining a secure system configuration.

        NOTE: The users allowed in the wheel group are defined in the property `props.mondooLinuxSecuritySudoGroup` field of this policy. By default the users "root", "ec2-user", "centos" and "ubuntu" are included. To include custom users you need to define additional users in this property.
      audit: |
        Run this command and verify output includes matching line:

        ```
        # grep pam_wheel.so /etc/pam.d/su
        auth required pam_wheel.so use_uid
        ```

        Run this command and verify users in wheel group match site policy:

        ```
        # grep wheel /etc/group
        wheel:x:10:root,<user list>
        ```
      remediation:
        - id: cli
          desc: |
            **Using the CLI**

            To restrict access to the `su` command, you can edit the `/etc/pam.d/su` file and add the following line:

            ```bash
            echo "auth required pam_wheel.so use_uid" >> /etc/pam.d/su
            ```

            If users need `su` access, add their username to the comma-separated list of users in the `wheel` group within the `/etc/group` file:

            ```bash
            sed -i 's/^wheel:x:10:root/wheel:x:10:root,<user list>/' /etc/group
            ```

            If you want to lock down the use of the command `su` entirely instead, you need to create an empty group, for example `sugroup`:

            ```bash
            groupadd sugroup
            ```

            Then add the following line to the `/etc/pam.d/su` file:

            ```
            auth required pam_wheel.so use_uid group=sugroup
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            To restrict access to the `su` command, you can use the following Ansible playbook:

            ```yaml
            ---
            - name: Restrict access to su command
              hosts: all
              become: true

              tasks:
                - name: Ensure pam_wheel.so is configured in /etc/pam.d/su
                  ansible.builtin.lineinfile:
                    path: /etc/pam.d/su
                    regexp: '^auth required pam_wheel.so use_uid'
                    line: 'auth required pam_wheel.so use_uid'
                    create: yes
                - name: Ensure users are in the wheel group
                  ansible.builtin.user:
                    name: "{{ item }}"
                    group: wheel
                    append: yes
                  loop: "{{ props.mondooLinuxSecuritySudoGroup }}"
            ```
        - id: bash
          desc: |
            **Using a Bash Script**
            To restrict access to the `su` command, you can run the following bash script:

            ```bash
            #!/bin/bash
            set -e

            echo "Restricting access to su command"
            echo "auth required pam_wheel.so use_uid" >> /etc/pam.d/su
            echo "wheel:x:10:root,<user list>" >> /etc/group

            echo "Adding a group named sugroup and configuring it for su access"
            groupadd sugroup
            echo "auth required pam_wheel.so use_uid group=sugroup" >> /etc/pam.d/su
            ```

