# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-tls-security
    name: Mondoo TLS/SSL Security
    version: 1.5.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: host
    require:
      - provider: network
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |
        The Mondoo TLS/SSL Security policy identifies weak or misconfigured TLS/SSL settings that could expose encrypted communications to interception and tampering. Outdated protocols, weak cipher suites, and certificate issues can enable man-in-the-middle attacks, allowing attackers to eavesdrop on sensitive data or inject malicious content into encrypted connections.

        This policy validates TLS/SSL configurations including protocol versions, cipher suite strength, certificate validity, key exchange mechanisms, and protection against known vulnerabilities like BEAST and POODLE.

        ## Remote scan a host

        ```bash
        cnspec scan host <fqdn>
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Secure TLS/SSL connection
        filters: |
          asset.platform == 'host' && tls.params != empty
        checks:
          - uid: mondoo-tls-security-ciphers-include-aead-ciphers
          - uid: mondoo-tls-security-ciphers-include-pfs
          - uid: mondoo-tls-security-mitigate-beast
          - uid: mondoo-tls-security-no-diffie-hellman-cipher-suites
          - uid: mondoo-tls-security-no-export-cipher-suites
          - uid: mondoo-tls-security-no-null-cipher-suites
          - uid: mondoo-tls-security-no-old-cipher-suites
          - uid: mondoo-tls-security-no-rc4-ciphers
          - uid: mondoo-tls-security-no-rsa-key-exchange
          - uid: mondoo-tls-security-no-weak-block-cipher-modes
          - uid: mondoo-tls-security-no-weak-block-ciphers
          - uid: mondoo-tls-security-no-weak-tls-versions
      - title: Valid TLS/SSL certificate
        filters: |
          asset.platform == 'host' && tls.params != empty
        checks:
          - uid: mondoo-tls-security-cert-domain-name-match
          - uid: mondoo-tls-security-cert-is-valid
          - uid: mondoo-tls-security-cert-no-cert-expired
          - uid: mondoo-tls-security-cert-no-certs-expired
          - uid: mondoo-tls-security-cert-no-weak-signature
          - uid: mondoo-tls-security-cert-not-revoked
          - uid: mondoo-tls-security-cert-not-self-signed
    scoring_system: highest impact
queries:
  - uid: mondoo-tls-security-cert-domain-name-match
    title: Certificate's domain name must match
    impact: 90
    mql: |
      checkA1 = tls.certificates.first.subject.commonName == asset.fqdn

      if(tls.certificates.first.subject.commonName.contains(/^\*/)) {
        checkA1 == asset.fqdn.contains(tls.certificates.first.subject.commonName.split("*.")[1])
      }

      checkA2 = tls.certificates.first.sanExtension.dnsNames.contains(asset.fqdn)


      checkA3 = tls.certificates.first.sanExtension.dnsNames.where(_ == /\*/).where(_.split(".")[-2] + "." + _.split(".")[-1]).any(asset.name.contains(_.split("*.")[1]))

      checkA1 || checkA2 || checkA3
    docs:
      desc: |
        This check verifies that the SSL/TLS certificate's domain name matches the hostname being secured, either through the Common Name (CN) or Subject Alternative Name (SAN) fields.

        **Why this matters**

        Certificate domain mismatches undermine the authentication foundation of TLS, creating both security and operational risks:

          - **Man-in-the-middle exposure**: When domain validation fails, clients cannot confirm they are connecting to the legitimate server, enabling interception attacks.
          - **Browser security warnings**: Users encounter alarming security warnings that damage brand trust and may train them to ignore legitimate security alerts.
          - **Service disruptions**: API clients, mobile apps, and automated systems typically reject mismatched certificates, causing integration failures.
          - **Compliance violations**: PCI DSS, HIPAA, and other standards require valid TLS certificates for data protection.
          - **Configuration errors undetected**: A mismatch often indicates a deployment mistake that should be identified and corrected.

        Ensure certificates include all required domain names in the SAN field, as modern browsers prefer SAN over Common Name for validation.
      remediation: |
        To resolve this issue:

        1. Verify the domain name your server is using by checking your DNS configuration and web server virtual host settings.

        2. Check your current certificate's domain coverage using OpenSSL:
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep -A1 "Subject:"
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep -A1 "Subject Alternative Name"
           ```

        3. If the certificate does not cover your domain, request a new certificate that includes either:
           - The exact domain name in the Common Name (CN) field
           - The domain name in the Subject Alternative Name (SAN) extension (recommended for modern certificates)
           - A wildcard certificate (e.g., *.example.com) if you need to cover multiple subdomains

        4. For free certificates, use Let's Encrypt with Certbot:
           ```bash
           certbot certonly --webroot -w /var/www/html -d yourdomain.com -d www.yourdomain.com
           ```

        5. Install the new certificate on your web server and restart the service to apply changes.
  - uid: mondoo-tls-security-cert-is-valid
    title: Certificate is valid
    impact: 95
    mql: |
      tls.certificates.first {
        subject.commonName
        notBefore < time.now
        notAfter - notBefore < 398*time.day
      }
    docs:
      desc: |
        This check verifies that the SSL/TLS certificate is currently within its validity period and that the certificate validity does not exceed 398 days (per browser policy requirements since September 2020).

        **Why this matters**

        Invalid or non-compliant certificates expose services to security risks and operational disruptions:

          - **Immediate connection failures**: Clients reject certificates that are not yet valid or have expired, causing service outages.
          - **Browser rejection**: Certificates with validity periods exceeding 398 days are rejected by major browsers, even if otherwise valid.
          - **Trust chain failures**: Certificates not signed by a trusted CA cannot be verified, enabling man-in-the-middle attacks.
          - **Compliance requirements**: Industry standards require valid certificates from trusted authorities for handling sensitive data.
          - **Incident response delays**: Invalid certificates may indicate compromise or misconfiguration requiring immediate investigation.

        Use automated certificate management to ensure certificates are renewed before expiration and comply with current validity period requirements.
      remediation: |
        To resolve this issue:

        1. Check the certificate's validity period and ensure it has not expired:
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -dates
           ```

        2. Verify the certificate chain is complete and trusted:
           ```bash
           openssl s_client -connect yourdomain.com:443 -showcerts </dev/null 2>&1 | grep -E "verify|depth"
           ```

        3. Ensure the certificate validity period does not exceed 398 days (13 months), as required by browser certificate policies since September 2020. Certificates with longer validity periods may be rejected by browsers.

        4. If the certificate is invalid, obtain a new certificate from a trusted Certificate Authority (CA) such as:
           - Let's Encrypt (free, automated): `certbot certonly -d yourdomain.com`
           - Commercial CAs: DigiCert, Sectigo, GlobalSign, or your organization's preferred CA

        5. Install the complete certificate chain on your server, including any required intermediate certificates. Most CAs provide a "full chain" or "certificate bundle" file for this purpose.

        6. After installation, verify the certificate is properly configured using an online tool like SSL Labs (ssllabs.com/ssltest) or by running the OpenSSL commands above.
  - uid: mondoo-tls-security-cert-no-cert-expired
    title: Certificate is not near expiration or expired
    impact: 95
    mql: |
      tls.certificates.first.subject.commonName
      switch {
        case tls.certificates.first.expiresIn.days > 30: score(100);
        case tls.certificates.first.expiresIn.days > 21: score(50);
        case tls.certificates.first.expiresIn.days > 14: score(20);
        case tls.certificates.first.expiresIn.days > 7: score(9);
        default: score(0);
      }
    docs:
      desc: |
        This check monitors the certificate's remaining validity period and provides graduated scoring based on proximity to expiration (full score above 30 days, decreasing as expiration approaches).

        **Why this matters**

        Certificate expiration creates a time-sensitive security and operational risk that worsens as the deadline approaches:

          - **Service outages**: Expired certificates cause immediate connection failures across all clients, with no graceful degradation.
          - **Emergency renewals**: Last-minute certificate replacements are error-prone and often occur during off-hours when the issue is discovered.
          - **Trust degradation**: Users encountering certificate warnings lose confidence in the service's security practices.
          - **Compliance gaps**: Many security frameworks require proactive certificate lifecycle management with documented renewal processes.
          - **Attack window**: During the confusion of an expired certificate, users may be more susceptible to phishing or bypass security warnings.

        Implement certificate monitoring with alerts at 30, 14, and 7 days before expiration, and use automated renewal tools like cert-manager or Certbot.
      remediation: |
        To resolve this issue:

        1. Check your certificate's current expiration date:
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -enddate
           ```

        2. Renew the certificate before expiration:
           - For Let's Encrypt certificates, run: `certbot renew`
           - For commercial certificates, contact your CA or use their renewal portal

        3. Set up automated certificate renewal to prevent future expirations:
           - Let's Encrypt: Add a cron job or systemd timer for `certbot renew`
           - Commercial CAs: Enable auto-renewal in your CA's management portal if available

        4. Implement certificate monitoring to receive alerts before expiration:
           - Use monitoring tools like Nagios, Zabbix, or cloud provider certificate managers
           - Set alerts for 30, 14, and 7 days before expiration
           - Consider using certificate management platforms that provide automated renewal and alerting

        5. After renewal, restart your web server to load the new certificate:
           - Apache: `systemctl restart apache2` or `systemctl restart httpd`
           - Nginx: `systemctl restart nginx`
           - Other services: Consult your application's documentation
  - uid: mondoo-tls-security-cert-no-certs-expired
    title: None of the certificates (intermediate or root) have expired
    impact: 90
    mql: |
      tls.certificates {
        subject.commonName
        expiresIn.days > 0
      }
    docs:
      desc: |
        This check verifies that all certificates in the trust chain (including intermediate and root certificates) have not expired.

        **Why this matters**

        Expired intermediate or root certificates break the entire trust chain, creating widespread service disruption:

          - **Cascading failures**: A single expired intermediate certificate can simultaneously affect all services using that trust chain.
          - **Silent trust failures**: Unlike leaf certificates, intermediate expiration may not trigger renewal automation, catching teams off-guard.
          - **Client verification failures**: Even with a valid leaf certificate, clients cannot complete chain validation if intermediates are expired.
          - **Cross-signed complexity**: Root and intermediate certificate expirations may have complex cross-signing relationships that require careful management.
          - **Delayed diagnosis**: Trust chain issues are often harder to diagnose than simple leaf certificate problems.

        Regularly audit the complete certificate chain and monitor all certificates for expiration, not just the leaf certificate.
      remediation: |
        To resolve this issue:

        1. Identify which certificates in the chain have expired:
           ```bash
           openssl s_client -connect yourdomain.com:443 -showcerts </dev/null 2>/dev/null | openssl x509 -noout -subject -enddate
           ```

        2. For expired intermediate certificates:
           - Download the current intermediate certificate bundle from your CA's website
           - Most CAs maintain a repository of their current intermediate certificates
           - Update your server's certificate chain file to include the new intermediates

        3. For expired root certificates:
           - Root certificate updates are typically handled by operating system or browser updates
           - Ensure your server's CA certificate bundle is up to date:
             - On Debian/Ubuntu: `apt update && apt install ca-certificates`
             - On RHEL/CentOS: `yum update ca-certificates`

        4. Rebuild your certificate chain file in the correct order:
           - Your server certificate first
           - Intermediate certificate(s) next
           - Root certificate last (optional, as clients typically have these)

        5. Update your web server configuration to use the new chain file and restart the service.

        6. Verify the complete chain is valid:
           ```bash
           openssl verify -CAfile /path/to/ca-bundle.crt /path/to/your-certificate.crt
           ```
  - uid: mondoo-tls-security-cert-not-self-signed
    title: Do not use a self-signed certificate
    impact: 85
    mql: |
      tls.certificates.last.isCA
    docs:
      desc: |
        This check verifies that the certificate chain terminates at a trusted Certificate Authority root certificate, rather than being self-signed.

        **Why this matters**

        Self-signed certificates bypass the trust model that TLS depends on, creating significant security and usability risks:

          - **No third-party verification**: Self-signed certificates provide no external validation of server identity, enabling impersonation attacks.
          - **User warning fatigue**: Clients display security warnings that users must bypass, training them to ignore legitimate security alerts.
          - **Integration failures**: APIs, automated systems, and mobile apps typically reject self-signed certificates without manual override.
          - **Man-in-the-middle vulnerability**: Attackers can present their own self-signed certificate and users may accept it as "normal."
          - **Compliance failures**: Security standards and audits require certificates from trusted CAs for production systems.

        Use certificates from recognized Certificate Authorities. Free options like Let's Encrypt provide trusted certificates with automated renewal.
      remediation: |
        To resolve this issue:

        1. Obtain a certificate from a trusted Certificate Authority (CA). Options include:
           - Let's Encrypt (free, automated):
             ```bash
             apt install certbot  # or yum install certbot
             certbot certonly --standalone -d yourdomain.com
             ```
           - Commercial CAs (DigiCert, Sectigo, GlobalSign) for extended validation or specific compliance requirements
           - Your organization's internal CA if one exists and is trusted by your clients

        2. Generate a Certificate Signing Request (CSR) if required by your CA:
           ```bash
           openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr
           ```

        3. Submit the CSR to your chosen CA and complete their domain validation process.

        4. Install the issued certificate and any intermediate certificates on your server:
           - Apache: Update `SSLCertificateFile`, `SSLCertificateKeyFile`, and `SSLCertificateChainFile` directives
           - Nginx: Update `ssl_certificate` (full chain) and `ssl_certificate_key` directives

        5. Restart your web server to apply the changes.

        6. Verify the certificate is properly trusted:
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>&1 | grep "Verify return code"
           ```
           A return code of 0 indicates the certificate is trusted.
  - uid: mondoo-tls-security-cert-not-revoked
    title: Do not use revoked certificates
    impact: 100
    mql: |
      tls.certificates {
        subject.commonName
        isRevoked != true
      }
    docs:
      desc: |
        This check verifies that none of the certificates in the chain have been revoked by their issuing Certificate Authority.

        **Why this matters**

        Certificate revocation indicates that a certificate should no longer be trusted, often due to security compromise:

          - **Active security incident**: Revocation typically occurs after private key compromise, meaning attackers may have the ability to impersonate your service.
          - **Continued vulnerability**: Using a revoked certificate maintains the security exposure that triggered the revocation.
          - **Client rejection**: Modern clients check revocation status via OCSP or CRL and will reject connections to revoked certificates.
          - **Compliance violations**: Using revoked certificates violates virtually all security frameworks and may trigger audit findings.
          - **Reputation damage**: Security-conscious users and partners will lose trust when encountering revoked certificates.

        Replace revoked certificates immediately with newly-generated key pairs, and investigate the cause of revocation to prevent recurrence.
      remediation: |
        To resolve this issue:

        1. Check if your certificate has been revoked using OCSP (Online Certificate Status Protocol):
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -ocsp_uri
           # Then query the OCSP responder with the URI returned
           ```

        2. Alternatively, check revocation status using the CA's Certificate Revocation List (CRL):
           - Locate the CRL distribution point in your certificate
           - Download and check your certificate against the CRL

        3. If your certificate is revoked, you must obtain a new certificate:
           - Contact your CA to understand why the certificate was revoked
           - Generate a new private key (do not reuse the old key if it was compromised)
           - Create a new CSR and request a replacement certificate
           - Install the new certificate on your server

        4. Investigate the cause of revocation:
           - Private key compromise: Audit your systems for unauthorized access
           - Domain ownership issues: Verify your domain registration and DNS settings
           - CA policy violation: Review the CA's terms of service

        5. Enable OCSP stapling on your server to improve revocation checking performance:
           - Apache: `SSLUseStapling on` and `SSLStaplingCache shmcb:/tmp/stapling_cache(128000)`
           - Nginx: `ssl_stapling on;` and `ssl_stapling_verify on;`

        6. After installing the new certificate, verify it is not revoked using online tools like SSL Labs.
  - uid: mondoo-tls-security-cert-no-weak-signature
    title: Do not use weak certificate signatures
    impact: 90
    mql: |
      tls.certificates {
        subject.commonName
        signingAlgorithm != /md2|md5|sha1/i
      }
    docs:
      desc: |
        This check verifies that certificates do not use weak signature algorithms such as MD2, MD5, or SHA-1.

        **Why this matters**

        Weak signature algorithms can be exploited to forge certificates, completely undermining TLS security:

          - **Certificate forgery**: MD5 and SHA-1 collision attacks allow creation of fraudulent certificates that appear legitimately signed.
          - **Historical attacks**: Real-world attacks like Flame malware used MD5 weaknesses to forge Windows Update certificates.
          - **Browser deprecation**: Major browsers reject certificates signed with SHA-1 and weaker algorithms.
          - **Compliance requirements**: PCI DSS, NIST, and other frameworks prohibit weak signature algorithms.
          - **Future vulnerability**: As computing power increases, even SHA-1 becomes more vulnerable to practical attacks.

        Ensure all certificates use SHA-256 or stronger (SHA-384, SHA-512) signature algorithms, and verify the complete chain uses strong signatures.
      remediation: |
        To resolve this issue:

        1. Check your current certificate's signature algorithm:
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep "Signature Algorithm"
           ```

        2. If the certificate uses MD2, MD5, or SHA-1, you must replace it with a certificate using SHA-256 or stronger (SHA-384, SHA-512).

        3. Generate a new private key and CSR specifying a strong signature algorithm:
           ```bash
           openssl req -new -newkey rsa:2048 -sha256 -nodes -keyout server.key -out server.csr
           ```

        4. When requesting the certificate from your CA:
           - Explicitly request SHA-256 or SHA-384 signing
           - Most modern CAs use SHA-256 by default, but verify this during the order process
           - Let's Encrypt certificates use SHA-256 by default

        5. Also verify that intermediate certificates in your chain use strong signature algorithms. If your CA provides intermediates with weak signatures, contact them for updated certificates.

        6. Install the new certificate and restart your web server.

        7. Verify the new signature algorithm is in use:
           ```bash
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep "Signature Algorithm"
           ```
  - uid: mondoo-tls-security-no-weak-tls-versions
    title: Avoid weak SSL and TLS versions
    impact: 95
    mql: |
      tls.versions.containsOnly(["tls1.2", "tls1.3"])
    docs:
      desc: |
        This check verifies that only TLS 1.2 and TLS 1.3 are enabled, and that older, vulnerable protocol versions (SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1) are disabled.

        **Why this matters**

        Older SSL/TLS versions have fundamental cryptographic weaknesses that cannot be mitigated through configuration:

          - **POODLE attack**: SSL 3.0 can be exploited to decrypt sensitive data through padding oracle attacks.
          - **BEAST attack**: TLS 1.0's CBC implementation allows chosen-plaintext attacks against session cookies.
          - **Downgrade attacks**: Attackers can force connections to use weaker protocols if they remain enabled.
          - **Compliance requirements**: PCI DSS 3.2+ requires TLS 1.2 minimum; many frameworks now mandate TLS 1.2 or 1.3 exclusively.
          - **Browser deprecation**: Major browsers have removed support for TLS 1.0 and 1.1 entirely.

        Enable only TLS 1.2 and TLS 1.3, which provide modern cryptographic protections and are required by current security standards.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add or modify the `SSLProtocol` directive to disable weak protocols:

                ```apache
                SSLProtocol -all +TLSv1.2 +TLSv1.3
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify the configuration:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file under `/etc/nginx/sites-available/`).

            2. Inside the `server` block (or `http` block for global settings), add or modify:

                ```nginx
                ssl_protocols TLSv1.2 TLSv1.3;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify the configuration:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. In the `global` section or your `bind` lines, add:

                ```haproxy
                ssl-default-bind-options ssl-min-ver TLSv1.2
                ```

                Or for specific frontends:

                ```haproxy
                bind *:443 ssl crt /path/to/cert.pem ssl-min-ver TLSv1.2
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```
        - id: aws-alb
          desc: |
            **Using AWS Application Load Balancer**

            1. Open the AWS Management Console and navigate to EC2 > Load Balancers.

            2. Select your Application Load Balancer and go to the Listeners tab.

            3. Edit the HTTPS listener and change the Security Policy to `ELBSecurityPolicy-TLS13-1-2-2021-06` or a newer policy that only supports TLS 1.2 and TLS 1.3.

            4. Save the changes. The update takes effect immediately without requiring a restart.

            **Using AWS CLI:**

            ```bash
            aws elbv2 modify-listener --listener-arn <listener-arn> \
              --ssl-policy ELBSecurityPolicy-TLS13-1-2-2021-06
            ```
        - id: iis
          desc: |
            **Using IIS (Windows Server)**

            **Option 1: Using IIS Crypto (Recommended)**

            1. Download and run IIS Crypto from Nartac Software (https://www.nartac.com/Products/IISCrypto).

            2. Click "Best Practices" or manually uncheck SSL 2.0, SSL 3.0, TLS 1.0, and TLS 1.1.

            3. Ensure TLS 1.2 and TLS 1.3 are checked.

            4. Click "Apply" and reboot the server.

            **Option 2: Manual Registry Configuration**

            1. Open Registry Editor (`regedit.exe`) as Administrator.

            2. Navigate to `HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\`.

            3. For each protocol to disable (SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1), create the following structure:

                ```text
                [Protocol Name]\Server\Enabled = 0 (DWORD)
                [Protocol Name]\Server\DisabledByDefault = 1 (DWORD)
                [Protocol Name]\Client\Enabled = 0 (DWORD)
                [Protocol Name]\Client\DisabledByDefault = 1 (DWORD)
                ```

            4. Restart the server:

                ```powershell
                Restart-Computer
                ```
  - uid: mondoo-tls-security-no-rc4-ciphers
    title: Avoid RC4 ciphers
    impact: 90
    mql: |
      tls.ciphers.none( /rc4/i )
    docs:
      desc: |
        This check verifies that RC4 cipher suites are not enabled, as RC4 has known cryptographic weaknesses that compromise data confidentiality.

        **Why this matters**

        RC4 has fundamental cryptographic flaws that enable practical attacks against encrypted traffic:

          - **Statistical biases**: RC4's keystream has detectable biases that allow plaintext recovery with sufficient captured traffic.
          - **Bar mitzvah attack**: Weak keys in RC4 create exploitable patterns in the first bytes of ciphertext.
          - **RFC 7465 prohibition**: The IETF has officially prohibited RC4 in all TLS versions due to its weaknesses.
          - **Browser removal**: All major browsers have removed RC4 support entirely, causing connection failures.
          - **Real-world exploitation**: Attacks against RC4 are practical with modern computing resources, not just theoretical.

        Remove all RC4 cipher suites and use only modern AEAD ciphers like AES-GCM or ChaCha20-Poly1305.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Set a cipher suite that excludes RC4:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:!RC4
                SSLHonorCipherOrder on
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify RC4 is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i rc4
                ```

                This should return no results.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Set a cipher suite that excludes RC4:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:!RC4';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify RC4 is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i rc4
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Set a cipher suite that excludes RC4:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!RC4
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify RC4 is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i rc4
                ```
  - uid: mondoo-tls-security-no-null-cipher-suites
    title: Avoid NULL cipher suites
    impact: 100
    mql: |
      tls.ciphers.none( /null/i )
    docs:
      desc: |
        This check verifies that NULL cipher suites are not enabled, as these provide no encryption whatsoever despite using TLS.

        **Why this matters**

        NULL ciphers transmit data in plaintext, completely defeating the purpose of TLS:

          - **No confidentiality**: All data is transmitted in cleartext, fully visible to anyone monitoring the network.
          - **False security**: Applications believe they have a "secure" TLS connection while data is actually unprotected.
          - **Credential exposure**: Passwords, session tokens, and sensitive data are transmitted without any encryption.
          - **Compliance violations**: NULL ciphers violate every security standard requiring encrypted data transmission.
          - **Downgrade attacks**: Attackers may attempt to negotiate NULL ciphers if they remain enabled.

        Ensure NULL ciphers (including aNULL and eNULL variants) are explicitly disabled in your TLS configuration.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add `!NULL`, `!aNULL`, and `!eNULL` to exclude NULL cipher suites:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!NULL:!aNULL:!eNULL
                SSLHonorCipherOrder on
                ```

                These directives exclude:
                - `!NULL`: Cipher suites offering no encryption
                - `!aNULL`: Cipher suites offering no authentication
                - `!eNULL`: Cipher suites with NULL encryption

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify NULL ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i null
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add `!NULL`, `!aNULL`, and `!eNULL` to exclude NULL cipher suites:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!NULL:!aNULL:!eNULL';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify NULL ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i null
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add `!NULL`, `!aNULL`, and `!eNULL` to exclude NULL cipher suites:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!NULL:!aNULL:!eNULL
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify NULL ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i null
                ```
  - uid: mondoo-tls-security-no-export-cipher-suites
    title: Avoid export cipher suites
    impact: 95
    mql: |
      tls.ciphers.none( /export/i )
    docs:
      desc: |
        This check verifies that export-grade cipher suites are not enabled, as these use intentionally weakened encryption that can be easily broken.

        **Why this matters**

        Export ciphers were deliberately weakened to comply with 1990s-era US export restrictions and provide minimal security:

          - **40/56-bit keys**: Export ciphers use key sizes that can be brute-forced in minutes to hours on modern hardware.
          - **FREAK attack**: Attackers can force servers to use export-grade RSA keys, enabling decryption of captured traffic.
          - **Logjam attack**: Export-grade Diffie-Hellman parameters allow downgrade attacks against supposedly secure connections.
          - **Historical artifact**: Export restrictions were lifted decades ago, making these ciphers serve no legitimate purpose.
          - **Active exploitation**: These attacks are practical and have been demonstrated against real-world servers.

        Remove all export cipher suites and ensure only ciphers with adequate key sizes (128-bit or higher) are enabled.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add `!EXPORT` to exclude export cipher suites:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!EXPORT:!EXPORT40:!EXPORT56
                SSLHonorCipherOrder on
                ```

                Export cipher suites use intentionally weak 40-bit or 56-bit keys and are vulnerable to attacks like FREAK and Logjam.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify export ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i export
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add `!EXPORT` to exclude export cipher suites:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!EXPORT';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify export ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i export
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add `!EXPORT` to exclude export cipher suites:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!EXPORT
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify export ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i export
                ```
  - uid: mondoo-tls-security-no-diffie-hellman-cipher-suites
    title: Avoid anonymous Diffie-Hellman suites
    impact: 95
    mql: |
      tls.ciphers.none( /dh_anon/i )
    docs:
      desc: |
        This check verifies that anonymous Diffie-Hellman cipher suites are not enabled, as these provide no server authentication.

        **Why this matters**

        Anonymous Diffie-Hellman performs key exchange without verifying server identity, enabling trivial man-in-the-middle attacks:

          - **No authentication**: The server cannot prove its identity, allowing any attacker to intercept and relay traffic.
          - **Trivial MITM**: Unlike attacks requiring certificate forgery, anonymous DH makes interception straightforward.
          - **Full traffic visibility**: Attackers can decrypt, inspect, and modify all traffic in both directions.
          - **Credential theft**: Session tokens, passwords, and sensitive data can be captured without detection.
          - **Certificate bypass**: The entire PKI trust model is circumvented when authentication is skipped.

        Disable all ADH (anonymous Diffie-Hellman) cipher suites and use only authenticated key exchange mechanisms like ECDHE with certificate verification.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add `!ADH` and `!aNULL` to exclude anonymous Diffie-Hellman cipher suites:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!ADH:!aNULL
                SSLHonorCipherOrder on
                ```

                Anonymous Diffie-Hellman (ADH) performs key exchange without server authentication, making it vulnerable to man-in-the-middle attacks.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify anonymous DH ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "anon|ADH"
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add `!ADH` and `!aNULL` to exclude anonymous Diffie-Hellman cipher suites:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!ADH:!aNULL';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify anonymous DH ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "anon|ADH"
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add `!ADH` and `!aNULL` to exclude anonymous Diffie-Hellman cipher suites:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!ADH:!aNULL
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify anonymous DH ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "anon|ADH"
                ```
  - uid: mondoo-tls-security-no-weak-block-ciphers
    title: Avoid weak block ciphers
    impact: 85
    mql: tls.ciphers.none( /des|rc2|idea/i )
    docs:
      desc: |
        This check verifies that weak block ciphers (DES, 3DES, RC2, IDEA) are not enabled, as these have insufficient security for modern threats.

        **Why this matters**

        Legacy block ciphers have fundamental weaknesses that make them unsuitable for protecting sensitive data:

          - **DES brute-force**: 56-bit DES keys can be cracked in hours using dedicated hardware or cloud computing.
          - **Sweet32 attack**: 3DES and other 64-bit block ciphers are vulnerable to birthday attacks that recover plaintext after capturing enough traffic.
          - **RC2 weaknesses**: RC2 has known related-key attacks and provides inadequate security margins.
          - **IDEA obsolescence**: While not broken, IDEA is obsolete and lacks the security margin of modern algorithms.
          - **Compliance failures**: Current security standards require AES or equivalent strength ciphers.

        Replace weak block ciphers with AES-GCM or ChaCha20-Poly1305, which provide both strong encryption and authenticated data integrity.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add exclusions for weak block ciphers:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!DES:!3DES:!RC2:!IDEA
                SSLHonorCipherOrder on
                ```

                Why these ciphers are weak:
                - **DES**: Uses only a 56-bit key, easily brute-forced
                - **3DES**: Vulnerable to the Sweet32 attack
                - **RC2**: Outdated with known weaknesses
                - **IDEA**: Obsolete and no longer considered secure

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify weak ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "DES|RC2|IDEA"
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add exclusions for weak block ciphers:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!DES:!3DES:!RC2:!IDEA';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify weak ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "DES|RC2|IDEA"
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add exclusions for weak block ciphers:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!DES:!3DES:!RC2:!IDEA
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify weak ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "DES|RC2|IDEA"
                ```
  - uid: mondoo-tls-security-no-weak-block-cipher-modes
    title: Avoid weak block cipher modes
    impact: 90
    mql: tls.ciphers.none( /cbc/i )
    docs:
      desc: |
        This check verifies that CBC (Cipher Block Chaining) mode cipher suites are not enabled, as CBC is vulnerable to multiple well-documented attacks.

        **Why this matters**

        CBC mode has fundamental vulnerabilities that authenticated encryption modes like GCM address:

          - **BEAST attack**: TLS 1.0's predictable IV selection in CBC mode enables chosen-plaintext attacks.
          - **POODLE attack**: Padding oracle vulnerabilities in CBC allow byte-by-byte plaintext recovery.
          - **Lucky Thirteen**: Timing side-channels in CBC padding verification leak information about plaintext.
          - **No integrity protection**: CBC provides only confidentiality; attackers can modify ciphertext without detection in some scenarios.
          - **Implementation complexity**: CBC's padding requirements create opportunities for implementation errors.

        Use AEAD (Authenticated Encryption with Associated Data) modes like AES-GCM or ChaCha20-Poly1305, which provide both confidentiality and integrity protection by design.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Use a cipher suite that only includes AEAD modes (GCM, ChaCha20-Poly1305) and excludes CBC:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                SSLHonorCipherOrder on
                ```

                CBC is vulnerable to BEAST, POODLE, and padding oracle attacks. GCM and ChaCha20-Poly1305 provide authenticated encryption.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify CBC ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i CBC
                ```

            **Note:** Enabling TLS 1.3 automatically enforces AEAD cipher usage.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Use a cipher suite that only includes AEAD modes:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify CBC ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i CBC
                ```

            **Note:** Enabling TLS 1.3 automatically enforces AEAD cipher usage.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Use a cipher suite that only includes AEAD modes:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify CBC ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i CBC
                ```
  - uid: mondoo-tls-security-no-rsa-key-exchange
    title: Avoid cipher suites with RSA key exchange
    impact: 85
    mql: tls.ciphers.none( /^tls_rsa/i )
    docs:
      desc: |
        This check verifies that cipher suites using RSA key exchange (TLS_RSA_*) are not enabled, as these lack forward secrecy.

        **Why this matters**

        RSA key exchange creates long-term cryptographic risk because past traffic can be decrypted if the private key is ever compromised:

          - **No forward secrecy**: Captured traffic can be decrypted retroactively if the server's private key is later obtained.
          - **"Store now, decrypt later"**: Adversaries may capture encrypted traffic today and decrypt it years later when the key becomes available.
          - **Key compromise impact**: A single key compromise exposes all historical communications, not just future ones.
          - **Quantum computing threat**: Future quantum computers may break RSA, exposing all traffic encrypted with RSA key exchange.
          - **TLS 1.3 exclusion**: RSA key exchange was intentionally removed from TLS 1.3 due to its security limitations.

        Use cipher suites with ECDHE or DHE key exchange, which generate ephemeral keys for each session and provide forward secrecy.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Use cipher suites with ECDHE or DHE key exchange and exclude RSA key exchange with `!kRSA`:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:!kRSA
                SSLHonorCipherOrder on
                ```

                Note: `ECDHE-RSA-*` uses RSA for authentication only (with forward secrecy), while `TLS_RSA_*` uses RSA for key exchange (no forward secrecy).

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify RSA key exchange is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -E "TLS_RSA"
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Use cipher suites with ECDHE or DHE key exchange only:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify RSA key exchange is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -E "TLS_RSA"
                ```

            **Note:** TLS 1.3 only supports forward secrecy by design.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Use cipher suites with ECDHE or DHE key exchange only:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify RSA key exchange is disabled using SSL Labs or:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -E "TLS_RSA"
                ```
  - uid: mondoo-tls-security-no-old-cipher-suites
    title: Avoid old cipher suites
    impact: 90
    mql: tls.ciphers.none( /^old/i )
    docs:
      desc: |
        This check verifies that legacy cipher suites from older TLS/SSL versions are not enabled, as these use outdated algorithms with known vulnerabilities.

        **Why this matters**

        Legacy cipher suites accumulate multiple security weaknesses that make them unsuitable for modern use:

          - **Weak hash functions**: Older suites use MD5 or SHA-1, which have known collision vulnerabilities.
          - **Weak encryption**: Algorithms like RC4, DES, and 3DES provide insufficient protection against current threats.
          - **Vulnerable modes**: CBC mode implementations are susceptible to padding oracle and timing attacks.
          - **No forward secrecy**: Many legacy suites use static RSA key exchange without ephemeral keys.
          - **Cumulative risk**: The combination of weaknesses in old cipher suites compounds overall vulnerability.

        Configure your server to use only modern cipher suites with AEAD encryption, forward secrecy, and SHA-256 or stronger hash functions.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Replace your cipher configuration with a modern cipher suite:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                SSLProtocol -all +TLSv1.2 +TLSv1.3
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify using SSL Labs (ssllabs.com/ssltest) or:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com
                ```

            **Resource:** Use the [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/) for tested configurations.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Replace your cipher configuration with a modern cipher suite:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ssl_protocols TLSv1.2 TLSv1.3;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify using SSL Labs (ssllabs.com/ssltest) or:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com
                ```

            **Resource:** Use the [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/) for tested configurations.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Replace your cipher configuration with a modern cipher suite:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ssl-default-bind-options ssl-min-ver TLSv1.2
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify using SSL Labs (ssllabs.com/ssltest) to ensure your configuration scores A or A+.

            **Resource:** Use the [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/) for tested configurations.
  - uid: mondoo-tls-security-ciphers-include-aead-ciphers
    title: Preferred ciphers must include AEAD ciphers
    impact: 85
    mql: tls.ciphers.any( /chacha20_poly1305|gcm|ccm/i )
    docs:
      desc: |
        This check verifies that the server's preferred cipher suites include AEAD ciphers such as AES-GCM, ChaCha20-Poly1305, or AES-CCM.

        **Why this matters**

        AEAD ciphers provide superior security by combining encryption and authentication in a single operation:

          - **Built-in integrity**: AEAD ciphers detect any tampering with ciphertext, preventing manipulation attacks.
          - **No padding oracle attacks**: Unlike CBC mode, AEAD ciphers are not vulnerable to padding-based timing attacks.
          - **Performance benefits**: AES-GCM leverages hardware acceleration on modern CPUs for high throughput.
          - **TLS 1.3 standard**: TLS 1.3 exclusively uses AEAD ciphers, making them the direction of secure communication.
          - **Simpler implementation**: Combining encryption and authentication reduces the risk of implementation errors.

        Prioritize AES-GCM and ChaCha20-Poly1305 cipher suites, which are widely supported and provide excellent security and performance.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Configure cipher suites that include AEAD ciphers (GCM, ChaCha20-Poly1305):

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                ```

                AEAD cipher suites provide both confidentiality and integrity protection:
                - **AES-GCM**: Hardware-accelerated on most modern CPUs
                - **ChaCha20-Poly1305**: Excellent on devices without AES acceleration

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify AEAD ciphers are available:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "GCM|CHACHA|CCM"
                ```

            **Note:** TLS 1.3 only supports AEAD cipher suites by design.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Configure cipher suites that include AEAD ciphers:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify AEAD ciphers are available:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "GCM|CHACHA|CCM"
                ```

            **Note:** TLS 1.3 only supports AEAD cipher suites by design.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Configure cipher suites that include AEAD ciphers:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify AEAD ciphers are available:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "GCM|CHACHA|CCM"
                ```
  - uid: mondoo-tls-security-ciphers-include-pfs
    title: Preferred ciphers must include perfect forward secrecy (PFS)
    impact: 95
    mql: tls.ciphers.any( /ecdhe_(rsa|ecdsa)|dhe_(rsa|dss)|cecpq/i )
    docs:
      desc: |
        This check verifies that the server's cipher suites include options providing Perfect Forward Secrecy (PFS) through ECDHE or DHE key exchange.

        **Why this matters**

        Perfect Forward Secrecy protects past communications even if the server's private key is compromised in the future:

          - **Ephemeral keys**: Each session uses unique key exchange parameters that are discarded after use.
          - **Retroactive protection**: Previously captured traffic cannot be decrypted even with the server's long-term private key.
          - **Quantum resistance**: PFS limits the impact of future quantum computing attacks on historical data.
          - **Regulatory compliance**: Many security frameworks now require forward secrecy for sensitive data protection.
          - **Defense in depth**: PFS provides an additional layer of protection if other security controls fail.

        Enable ECDHE-based cipher suites for optimal forward secrecy with good performance. TLS 1.3 provides forward secrecy by design for all connections.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Configure cipher suites that use ECDHE or DHE for forward secrecy:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                ```

                If using DHE, generate a strong DH parameter (2048-bit minimum):

                ```bash
                openssl dhparam -out /etc/ssl/dhparam.pem 2048
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify PFS is enabled using SSL Labs (look for "Forward Secrecy: Yes").

            **Note:** TLS 1.3 only supports forward secrecy by design.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Configure cipher suites that use ECDHE or DHE for forward secrecy:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. If using DHE, generate and configure a strong DH parameter:

                ```bash
                openssl dhparam -out /etc/ssl/dhparam.pem 2048
                ```

                Then add to your Nginx config:

                ```nginx
                ssl_dhparam /etc/ssl/dhparam.pem;
                ```

            4. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            5. Verify PFS is enabled using SSL Labs (look for "Forward Secrecy: Yes").
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Configure cipher suites that use ECDHE or DHE for forward secrecy:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify PFS is enabled using SSL Labs (look for "Forward Secrecy: Yes").

            **Note:** TLS 1.3 only supports forward secrecy by design.
  - uid: mondoo-tls-security-mitigate-beast
    title: Mitigate BEAST attacks on the server-side
    impact: 70
    mql: |-
      switch {
        case tls.versions.containsOnly(["tls1.2", "tls1.3"]):
          score(100);
        case tls.ciphers.all( /rc4/i ):
          score(100);
        case tls.ciphers.none( /null|dh_anon|export|des|rc2|idea/ ):
          score(80);
        default:
          score(0);
      }
    docs:
      desc: |
        This check evaluates the server's mitigation of BEAST (Browser Exploit Against SSL/TLS) attacks by verifying protocol versions and cipher configuration.

        **Why this matters**

        BEAST exploits a vulnerability in TLS 1.0's CBC implementation to decrypt sensitive data like session cookies:

          - **Predictable IV**: TLS 1.0 uses the last ciphertext block as the IV for the next record, enabling chosen-plaintext attacks.
          - **Session hijacking**: Attackers can recover authentication cookies to impersonate users.
          - **Client-side targeting**: The attack requires malicious code running in the victim's browser to inject chosen plaintext.
          - **Protocol-level flaw**: BEAST cannot be fully mitigated without disabling TLS 1.0 or using non-CBC ciphers.
          - **Historical significance**: BEAST demonstrated that TLS 1.0 has fundamental security weaknesses requiring protocol upgrades.

        The recommended mitigation is to disable TLS 1.0 and TLS 1.1 entirely, using only TLS 1.2 and TLS 1.3 with AEAD cipher suites.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            The recommended approach to mitigate BEAST is to disable TLS 1.0 and TLS 1.1 entirely.

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Configure protocols and cipher suites:

                ```apache
                SSLProtocol -all +TLSv1.2 +TLSv1.3
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                ```

                TLS 1.2 uses a different IV selection mechanism that prevents BEAST. TLS 1.3 only supports AEAD ciphers which are not vulnerable.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify TLS 1.0/1.1 are disabled:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```

            **Important:** Do not use RC4 as a BEAST mitigation. RC4 has severe cryptographic weaknesses.
        - id: nginx
          desc: |
            **Using Nginx**

            The recommended approach to mitigate BEAST is to disable TLS 1.0 and TLS 1.1 entirely.

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Configure protocols and cipher suites:

                ```nginx
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify TLS 1.0/1.1 are disabled:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```

            **Important:** Do not use RC4 as a BEAST mitigation. RC4 has severe cryptographic weaknesses.
        - id: haproxy
          desc: |
            **Using HAProxy**

            The recommended approach to mitigate BEAST is to disable TLS 1.0 and TLS 1.1 entirely.

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Configure protocols and cipher suites:

                ```haproxy
                ssl-default-bind-options ssl-min-ver TLSv1.2
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify TLS 1.0/1.1 are disabled:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```

            **Important:** Do not use RC4 as a BEAST mitigation. RC4 has severe cryptographic weaknesses.
    refs:
      - url: https://kb.vmware.com/s/article/2008784
        title: VMware mitigation of CVE-2011-3389 (BEAST) for web server administrators
