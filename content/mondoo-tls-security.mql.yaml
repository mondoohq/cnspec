# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1
policies:
  - uid: mondoo-tls-security
    name: Mondoo TLS/SSL Security
    version: 1.5.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: host
    require:
      - provider: network
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |
        The Transport Layer Security (TLS) protocol is the primary means of protecting network communications.

        The Mondoo TLS/SSL Security policy includes checks for ensuring the security and configuration of TLS/SSL connections and certificates.

        ## Remote scan a host

        ```bash
        cnspec scan host <fqdn>
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Secure TLS/SSL connection
        filters: |
          asset.platform == 'host' && tls.params != empty
        checks:
          - uid: mondoo-tls-security-ciphers-include-aead-ciphers
          - uid: mondoo-tls-security-ciphers-include-pfs
          - uid: mondoo-tls-security-mitigate-beast
          - uid: mondoo-tls-security-no-diffie-hellman-cipher-suites
          - uid: mondoo-tls-security-no-export-cipher-suites
          - uid: mondoo-tls-security-no-null-cipher-suites
          - uid: mondoo-tls-security-no-old-cipher-suites
          - uid: mondoo-tls-security-no-rc4-ciphers
          - uid: mondoo-tls-security-no-rsa-key-exchange
          - uid: mondoo-tls-security-no-weak-block-cipher-modes
          - uid: mondoo-tls-security-no-weak-block-ciphers
          - uid: mondoo-tls-security-no-weak-tls-versions
      - title: Valid TLS/SSL certificate
        filters: |
          asset.platform == 'host' && tls.params != empty
        checks:
          - uid: mondoo-tls-security-cert-domain-name-match
          - uid: mondoo-tls-security-cert-is-valid
          - uid: mondoo-tls-security-cert-no-cert-expired
          - uid: mondoo-tls-security-cert-no-certs-expired
          - uid: mondoo-tls-security-cert-no-weak-signature
          - uid: mondoo-tls-security-cert-not-revoked
          - uid: mondoo-tls-security-cert-not-self-signed
    scoring_system: highest impact
queries:
  - uid: mondoo-tls-security-cert-domain-name-match
    title: Certificate's domain name must match
    impact: 90
    mql: |
      checkA1 = tls.certificates.first.subject.commonName == asset.fqdn

      if(tls.certificates.first.subject.commonName.contains(/^\*/)) {
        checkA1 == asset.fqdn.contains(tls.certificates.first.subject.commonName.split("*.")[1])
      }

      checkA2 = tls.certificates.first.sanExtension.dnsNames.contains(asset.fqdn)


      checkA3 = tls.certificates.first.sanExtension.dnsNames.where(_ == /\*/).where(_.split(".")[-2] + "." + _.split(".")[-1]).any(asset.name.contains(_.split("*.")[1]))

      checkA1 || checkA2 || checkA3
    docs:
      desc: |
        The domain name specified in an SSL/TLS certificate must match the hostname being secured. When a certificate does not match the requested domain, clients cannot reliably confirm they are connecting to the intended server. This mismatch may indicate a configuration error or an attempted interception, and it often results in browser warnings or failed connections. Such failures reduce user trust and can lead to service disruptions or loss of confidence in the security of the site.
      remediation: |
        To resolve this issue:

        1. Verify the domain name your server is using by checking your DNS configuration and web server virtual host settings.

        2. Check your current certificate's domain coverage using OpenSSL:
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep -A1 "Subject:"
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep -A1 "Subject Alternative Name"
           ```

        3. If the certificate does not cover your domain, request a new certificate that includes either:
           - The exact domain name in the Common Name (CN) field
           - The domain name in the Subject Alternative Name (SAN) extension (recommended for modern certificates)
           - A wildcard certificate (e.g., *.example.com) if you need to cover multiple subdomains

        4. For free certificates, use Let's Encrypt with Certbot:
           ```
           certbot certonly --webroot -w /var/www/html -d yourdomain.com -d www.yourdomain.com
           ```

        5. Install the new certificate on your web server and restart the service to apply changes.
  - uid: mondoo-tls-security-cert-is-valid
    title: Certificate is valid
    impact: 95
    mql: |
      tls.certificates.first {
        subject.commonName
        notBefore < time.now
        notAfter - notBefore < 398*time.day
      }
    docs:
      desc: |
        This check confirms that the SSL/TLS certificate is currently valid, has not expired, and is signed by a trusted Certificate Authority (CA). A certificate that is expired, self-signed, or issued by an unknown CA cannot be reliably used to authenticate the server. Invalid certificates cause clients to display security warnings or terminate the connection, which can disrupt service availability and undermine user trust.
      remediation: |
        To resolve this issue:

        1. Check the certificate's validity period and ensure it has not expired:
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -dates
           ```

        2. Verify the certificate chain is complete and trusted:
           ```
           openssl s_client -connect yourdomain.com:443 -showcerts </dev/null 2>&1 | grep -E "verify|depth"
           ```

        3. Ensure the certificate validity period does not exceed 398 days (13 months), as required by browser certificate policies since September 2020. Certificates with longer validity periods may be rejected by browsers.

        4. If the certificate is invalid, obtain a new certificate from a trusted Certificate Authority (CA) such as:
           - Let's Encrypt (free, automated): `certbot certonly -d yourdomain.com`
           - Commercial CAs: DigiCert, Sectigo, GlobalSign, or your organization's preferred CA

        5. Install the complete certificate chain on your server, including any required intermediate certificates. Most CAs provide a "full chain" or "certificate bundle" file for this purpose.

        6. After installation, verify the certificate is properly configured using an online tool like SSL Labs (ssllabs.com/ssltest) or by running the OpenSSL commands above.
  - uid: mondoo-tls-security-cert-no-cert-expired
    title: Certificate is not near expiration or expired
    impact: 95
    mql: |
      tls.certificates.first.subject.commonName
      switch {
        case tls.certificates.first.expiresIn.days > 30: score(100);
        case tls.certificates.first.expiresIn.days > 21: score(50);
        case tls.certificates.first.expiresIn.days > 14: score(20);
        case tls.certificates.first.expiresIn.days > 7: score(9);
        default: score(0);
      }
    docs:
      desc: |
        Certificates nearing expiration or expired can lead to service interruptions and browser security warnings. This can affect user trust and potentially allow MITM attacks if not addressed promptly.
      remediation: |
        To resolve this issue:

        1. Check your certificate's current expiration date:
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -enddate
           ```

        2. Renew the certificate before expiration:
           - For Let's Encrypt certificates, run: `certbot renew`
           - For commercial certificates, contact your CA or use their renewal portal

        3. Set up automated certificate renewal to prevent future expirations:
           - Let's Encrypt: Add a cron job or systemd timer for `certbot renew`
           - Commercial CAs: Enable auto-renewal in your CA's management portal if available

        4. Implement certificate monitoring to receive alerts before expiration:
           - Use monitoring tools like Nagios, Zabbix, or cloud provider certificate managers
           - Set alerts for 30, 14, and 7 days before expiration
           - Consider using certificate management platforms that provide automated renewal and alerting

        5. After renewal, restart your web server to load the new certificate:
           - Apache: `systemctl restart apache2` or `systemctl restart httpd`
           - Nginx: `systemctl restart nginx`
           - Other services: Consult your application's documentation
  - uid: mondoo-tls-security-cert-no-certs-expired
    title: None of the certificates (intermediate or root) have expired
    impact: 90
    mql: |
      tls.certificates {
        subject.commonName
        expiresIn.days > 0
      }
    docs:
      desc: |
        The expiration of intermediate or root certificates can disrupt the trust chain, rendering SSL/TLS communications insecure. This affects multiple services relying on the expired certificate.
      remediation: |
        To resolve this issue:

        1. Identify which certificates in the chain have expired:
           ```
           openssl s_client -connect yourdomain.com:443 -showcerts </dev/null 2>/dev/null | openssl x509 -noout -subject -enddate
           ```

        2. For expired intermediate certificates:
           - Download the current intermediate certificate bundle from your CA's website
           - Most CAs maintain a repository of their current intermediate certificates
           - Update your server's certificate chain file to include the new intermediates

        3. For expired root certificates:
           - Root certificate updates are typically handled by operating system or browser updates
           - Ensure your server's CA certificate bundle is up to date:
             - On Debian/Ubuntu: `apt update && apt install ca-certificates`
             - On RHEL/CentOS: `yum update ca-certificates`

        4. Rebuild your certificate chain file in the correct order:
           - Your server certificate first
           - Intermediate certificate(s) next
           - Root certificate last (optional, as clients typically have these)

        5. Update your web server configuration to use the new chain file and restart the service.

        6. Verify the complete chain is valid:
           ```
           openssl verify -CAfile /path/to/ca-bundle.crt /path/to/your-certificate.crt
           ```
  - uid: mondoo-tls-security-cert-not-self-signed
    title: Do not use a self-signed certificate
    impact: 85
    mql: |
      tls.certificates.last.isCA
    docs:
      desc: |
        Self-signed certificates are not trusted by default in browsers or operating systems. They lack authentication from a trusted CA, exposing the service to MITM attacks and reducing user trust.
      remediation: |
        To resolve this issue:

        1. Obtain a certificate from a trusted Certificate Authority (CA). Options include:
           - Let's Encrypt (free, automated):
             ```
             apt install certbot  # or yum install certbot
             certbot certonly --standalone -d yourdomain.com
             ```
           - Commercial CAs (DigiCert, Sectigo, GlobalSign) for extended validation or specific compliance requirements
           - Your organization's internal CA if one exists and is trusted by your clients

        2. Generate a Certificate Signing Request (CSR) if required by your CA:
           ```
           openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr
           ```

        3. Submit the CSR to your chosen CA and complete their domain validation process.

        4. Install the issued certificate and any intermediate certificates on your server:
           - Apache: Update `SSLCertificateFile`, `SSLCertificateKeyFile`, and `SSLCertificateChainFile` directives
           - Nginx: Update `ssl_certificate` (full chain) and `ssl_certificate_key` directives

        5. Restart your web server to apply the changes.

        6. Verify the certificate is properly trusted:
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>&1 | grep "Verify return code"
           ```
           A return code of 0 indicates the certificate is trusted.
  - uid: mondoo-tls-security-cert-not-revoked
    title: Do not use revoked certificates
    impact: 100
    mql: |
      tls.certificates {
        subject.commonName
        isRevoked != true
      }
    docs:
      desc: |
        Revoked certificates are flagged as compromised or untrustworthy by the CA. Continuing to use them exposes the service to significant security risks and compliance violations.
      remediation: |
        To resolve this issue:

        1. Check if your certificate has been revoked using OCSP (Online Certificate Status Protocol):
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -ocsp_uri
           # Then query the OCSP responder with the URI returned
           ```

        2. Alternatively, check revocation status using the CA's Certificate Revocation List (CRL):
           - Locate the CRL distribution point in your certificate
           - Download and check your certificate against the CRL

        3. If your certificate is revoked, you must obtain a new certificate:
           - Contact your CA to understand why the certificate was revoked
           - Generate a new private key (do not reuse the old key if it was compromised)
           - Create a new CSR and request a replacement certificate
           - Install the new certificate on your server

        4. Investigate the cause of revocation:
           - Private key compromise: Audit your systems for unauthorized access
           - Domain ownership issues: Verify your domain registration and DNS settings
           - CA policy violation: Review the CA's terms of service

        5. Enable OCSP stapling on your server to improve revocation checking performance:
           - Apache: `SSLUseStapling on` and `SSLStaplingCache shmcb:/tmp/stapling_cache(128000)`
           - Nginx: `ssl_stapling on;` and `ssl_stapling_verify on;`

        6. After installing the new certificate, verify it is not revoked using online tools like SSL Labs.
  - uid: mondoo-tls-security-cert-no-weak-signature
    title: Do not use weak certificate signatures
    impact: 90
    mql: |
      tls.certificates {
        subject.commonName
        signingAlgorithm != /md2|md5|sha1/i
      }
    docs:
      desc: |
        Weak certificate signatures (e.g., SHA-1) are vulnerable to cryptographic attacks. Using them undermines the encryption and allows attackers to forge certificates.
      remediation: |
        To resolve this issue:

        1. Check your current certificate's signature algorithm:
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep "Signature Algorithm"
           ```

        2. If the certificate uses MD2, MD5, or SHA-1, you must replace it with a certificate using SHA-256 or stronger (SHA-384, SHA-512).

        3. Generate a new private key and CSR specifying a strong signature algorithm:
           ```
           openssl req -new -newkey rsa:2048 -sha256 -nodes -keyout server.key -out server.csr
           ```

        4. When requesting the certificate from your CA:
           - Explicitly request SHA-256 or SHA-384 signing
           - Most modern CAs use SHA-256 by default, but verify this during the order process
           - Let's Encrypt certificates use SHA-256 by default

        5. Also verify that intermediate certificates in your chain use strong signature algorithms. If your CA provides intermediates with weak signatures, contact them for updated certificates.

        6. Install the new certificate and restart your web server.

        7. Verify the new signature algorithm is in use:
           ```
           openssl s_client -connect yourdomain.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text | grep "Signature Algorithm"
           ```
  - uid: mondoo-tls-security-no-weak-tls-versions
    title: Avoid weak SSL and TLS versions
    impact: 95
    mql: |
      tls.versions.containsOnly(["tls1.2", "tls1.3"])
    docs:
      desc: |
        Weak SSL/TLS versions (e.g., SSL 3.0, TLS 1.0) are vulnerable to numerous exploits like POODLE. Their continued use compromises encrypted communication security.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add or modify the `SSLProtocol` directive to disable weak protocols:

                ```apache
                SSLProtocol -all +TLSv1.2 +TLSv1.3
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify the configuration:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file under `/etc/nginx/sites-available/`).

            2. Inside the `server` block (or `http` block for global settings), add or modify:

                ```nginx
                ssl_protocols TLSv1.2 TLSv1.3;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify the configuration:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. In the `global` section or your `bind` lines, add:

                ```haproxy
                ssl-default-bind-options ssl-min-ver TLSv1.2
                ```

                Or for specific frontends:

                ```haproxy
                bind *:443 ssl crt /path/to/cert.pem ssl-min-ver TLSv1.2
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```
        - id: aws-alb
          desc: |
            **Using AWS Application Load Balancer**

            1. Open the AWS Management Console and navigate to EC2 > Load Balancers.

            2. Select your Application Load Balancer and go to the Listeners tab.

            3. Edit the HTTPS listener and change the Security Policy to `ELBSecurityPolicy-TLS13-1-2-2021-06` or a newer policy that only supports TLS 1.2 and TLS 1.3.

            4. Save the changes. The update takes effect immediately without requiring a restart.

            **Using AWS CLI:**

            ```bash
            aws elbv2 modify-listener --listener-arn <listener-arn> \
              --ssl-policy ELBSecurityPolicy-TLS13-1-2-2021-06
            ```
        - id: iis
          desc: |
            **Using IIS (Windows Server)**

            **Option 1: Using IIS Crypto (Recommended)**

            1. Download and run IIS Crypto from Nartac Software (https://www.nartac.com/Products/IISCrypto).

            2. Click "Best Practices" or manually uncheck SSL 2.0, SSL 3.0, TLS 1.0, and TLS 1.1.

            3. Ensure TLS 1.2 and TLS 1.3 are checked.

            4. Click "Apply" and reboot the server.

            **Option 2: Manual Registry Configuration**

            1. Open Registry Editor (`regedit.exe`) as Administrator.

            2. Navigate to `HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\`.

            3. For each protocol to disable (SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1), create the following structure:

                ```
                [Protocol Name]\Server\Enabled = 0 (DWORD)
                [Protocol Name]\Server\DisabledByDefault = 1 (DWORD)
                [Protocol Name]\Client\Enabled = 0 (DWORD)
                [Protocol Name]\Client\DisabledByDefault = 1 (DWORD)
                ```

            4. Restart the server:

                ```powershell
                Restart-Computer
                ```
  - uid: mondoo-tls-security-no-rc4-ciphers
    title: Avoid RC4 ciphers
    impact: 90
    mql: |
      tls.ciphers.none( /rc4/i )
    docs:
      desc: |
        RC4 is a weak cipher prone to cryptographic attacks. Its use is discouraged as it does not provide sufficient encryption strength for modern applications.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Set a cipher suite that excludes RC4:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:!RC4
                SSLHonorCipherOrder on
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify RC4 is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i rc4
                ```

                This should return no results.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Set a cipher suite that excludes RC4:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:!RC4';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify RC4 is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i rc4
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Set a cipher suite that excludes RC4:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!RC4
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify RC4 is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i rc4
                ```
  - uid: mondoo-tls-security-no-null-cipher-suites
    title: Avoid NULL cipher suites
    impact: 100
    mql: |
      tls.ciphers.none( /null/i )
    docs:
      desc: |
        NULL cipher suites do not encrypt data during transmission, exposing the data to interception and unauthorized access. Their use undermines the purpose of secure communication.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add `!NULL`, `!aNULL`, and `!eNULL` to exclude NULL cipher suites:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!NULL:!aNULL:!eNULL
                SSLHonorCipherOrder on
                ```

                These directives exclude:
                - `!NULL`: Cipher suites offering no encryption
                - `!aNULL`: Cipher suites offering no authentication
                - `!eNULL`: Cipher suites with NULL encryption

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify NULL ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i null
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add `!NULL`, `!aNULL`, and `!eNULL` to exclude NULL cipher suites:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!NULL:!aNULL:!eNULL';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify NULL ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i null
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add `!NULL`, `!aNULL`, and `!eNULL` to exclude NULL cipher suites:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!NULL:!aNULL:!eNULL
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify NULL ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i null
                ```
  - uid: mondoo-tls-security-no-export-cipher-suites
    title: Avoid export ciphers suites
    impact: 95
    mql: |
      tls.ciphers.none( /export/i )
    docs:
      desc: |
        Export cipher suites are intentionally weakened cryptographic algorithms designed to meet outdated export regulations. They are vulnerable to brute-force attacks and compromise encryption security.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add `!EXPORT` to exclude export cipher suites:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!EXPORT:!EXPORT40:!EXPORT56
                SSLHonorCipherOrder on
                ```

                Export cipher suites use intentionally weak 40-bit or 56-bit keys and are vulnerable to attacks like FREAK and Logjam.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify export ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i export
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add `!EXPORT` to exclude export cipher suites:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!EXPORT';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify export ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i export
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add `!EXPORT` to exclude export cipher suites:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!EXPORT
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify export ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i export
                ```
  - uid: mondoo-tls-security-no-diffie-hellman-cipher-suites
    title: Avoid anonymous Diffie-Hellman suites
    impact: 95
    mql: |
      tls.ciphers.none( /dh_anon/i )
    docs:
      desc: |
        Anonymous Diffie-Hellman suites lack authentication, allowing attackers to impersonate the server or client. This can lead to man-in-the-middle (MITM) attacks and data compromise.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add `!ADH` and `!aNULL` to exclude anonymous Diffie-Hellman cipher suites:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!ADH:!aNULL
                SSLHonorCipherOrder on
                ```

                Anonymous Diffie-Hellman (ADH) performs key exchange without server authentication, making it vulnerable to man-in-the-middle attacks.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify anonymous DH ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "anon|ADH"
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add `!ADH` and `!aNULL` to exclude anonymous Diffie-Hellman cipher suites:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!ADH:!aNULL';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify anonymous DH ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "anon|ADH"
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add `!ADH` and `!aNULL` to exclude anonymous Diffie-Hellman cipher suites:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!ADH:!aNULL
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify anonymous DH ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "anon|ADH"
                ```
  - uid: mondoo-tls-security-no-weak-block-ciphers
    title: Avoid weak block ciphers
    impact: 85
    mql: tls.ciphers.none( /des|rc2|idea/i )
    docs:
      desc: |
        Weak block ciphers, such as DES or 3DES, are vulnerable to modern cryptographic attacks, including brute force and collision attacks, reducing the overall security of the communication.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Add exclusions for weak block ciphers:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!DES:!3DES:!RC2:!IDEA
                SSLHonorCipherOrder on
                ```

                Why these ciphers are weak:
                - **DES**: Uses only a 56-bit key, easily brute-forced
                - **3DES**: Vulnerable to the Sweet32 attack
                - **RC2**: Outdated with known weaknesses
                - **IDEA**: Obsolete and no longer considered secure

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify weak ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "DES|RC2|IDEA"
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Add exclusions for weak block ciphers:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:!DES:!3DES:!RC2:!IDEA';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify weak ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "DES|RC2|IDEA"
                ```
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Add exclusions for weak block ciphers:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:!DES:!3DES:!RC2:!IDEA
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify weak ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "DES|RC2|IDEA"
                ```
  - uid: mondoo-tls-security-no-weak-block-cipher-modes
    title: Avoid weak block cipher modes
    impact: 90
    mql: tls.ciphers.none( /cbc/i )
    docs:
      desc: |
        Weak block cipher modes, such as CBC when used without proper padding or initialization vector (IV) handling, expose encrypted traffic to well-known cryptographic attacks including BEAST and padding oracle attacks. These vulnerabilities can allow an attacker to gradually recover plaintext, manipulate encrypted data, or compromise session confidentiality. Using modern authenticated encryption modes, such as GCM or ChaCha20-Poly1305, provides stronger protection because they are designed to resist these classes of attacks and enforce data integrity.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Use a cipher suite that only includes AEAD modes (GCM, ChaCha20-Poly1305) and excludes CBC:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                SSLHonorCipherOrder on
                ```

                CBC is vulnerable to BEAST, POODLE, and padding oracle attacks. GCM and ChaCha20-Poly1305 provide authenticated encryption.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify CBC ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i CBC
                ```

            **Note:** Enabling TLS 1.3 automatically enforces AEAD cipher usage.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Use a cipher suite that only includes AEAD modes:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify CBC ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i CBC
                ```

            **Note:** Enabling TLS 1.3 automatically enforces AEAD cipher usage.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Use a cipher suite that only includes AEAD modes:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify CBC ciphers are disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -i CBC
                ```
  - uid: mondoo-tls-security-no-rsa-key-exchange
    title: Avoid cipher suites with RSA key exchange
    impact: 85
    mql: tls.ciphers.none( /^tls_rsa/i )
    docs:
      desc: |
        Cipher suites that use RSA for key exchange do not provide forward secrecy. If an attacker obtains the server's private key, whether through compromise, theft, or future cryptographic advances, they can retroactively decrypt any previously captured TLS traffic. This means the confidentiality of past communications depends entirely on the long-term protection of the private key, making RSA key-exchange suites significantly less secure than modern alternatives such as ECDHE.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Use cipher suites with ECDHE or DHE key exchange and exclude RSA key exchange with `!kRSA`:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:!kRSA
                SSLHonorCipherOrder on
                ```

                Note: `ECDHE-RSA-*` uses RSA for authentication only (with forward secrecy), while `TLS_RSA_*` uses RSA for key exchange (no forward secrecy).

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify RSA key exchange is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -E "TLS_RSA"
                ```
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Use cipher suites with ECDHE or DHE key exchange only:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify RSA key exchange is disabled:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -E "TLS_RSA"
                ```

            **Note:** TLS 1.3 only supports forward secrecy by design.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Use cipher suites with ECDHE or DHE key exchange only:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify RSA key exchange is disabled using SSL Labs or:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -E "TLS_RSA"
                ```
  - uid: mondoo-tls-security-no-old-cipher-suites
    title: Avoid old cipher suites
    impact: 90
    mql: tls.ciphers.none( /^old/i )
    docs:
      desc: |
        Old cipher suites are outdated, less secure sets of encryption algorithms (like those using MD5, RC4, 3DES, or older CBC modes) used in older TLS/SSL versions (SSLv3, TLS 1.0, 1.1, and even some in 1.2) that are vulnerable to modern attacks. Modern cipher suites offer stronger encryption, better performance, and improved security features.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Replace your cipher configuration with a modern cipher suite:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                SSLProtocol -all +TLSv1.2 +TLSv1.3
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify using SSL Labs (ssllabs.com/ssltest) or:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com
                ```

            **Resource:** Use the [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/) for tested configurations.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Replace your cipher configuration with a modern cipher suite:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ssl_protocols TLSv1.2 TLSv1.3;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify using SSL Labs (ssllabs.com/ssltest) or:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com
                ```

            **Resource:** Use the [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/) for tested configurations.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Replace your cipher configuration with a modern cipher suite:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ssl-default-bind-options ssl-min-ver TLSv1.2
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify using SSL Labs (ssllabs.com/ssltest) to ensure your configuration scores A or A+.

            **Resource:** Use the [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/) for tested configurations.
  - uid: mondoo-tls-security-ciphers-include-aead-ciphers
    title: Preferred ciphers must include AEAD ciphers
    impact: 85
    mql: tls.ciphers.any( /chacha20_poly1305|gcm|ccm/i )
    docs:
      desc: |
        AEAD (Authenticated Encryption with Associated Data) ciphers provide both confidentiality and integrity protection, making them a critical component of modern secure communication protocols.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Configure cipher suites that include AEAD ciphers (GCM, ChaCha20-Poly1305):

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                ```

                AEAD cipher suites provide both confidentiality and integrity protection:
                - **AES-GCM**: Hardware-accelerated on most modern CPUs
                - **ChaCha20-Poly1305**: Excellent on devices without AES acceleration

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify AEAD ciphers are available:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "GCM|CHACHA|CCM"
                ```

            **Note:** TLS 1.3 only supports AEAD cipher suites by design.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Configure cipher suites that include AEAD ciphers:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify AEAD ciphers are available:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "GCM|CHACHA|CCM"
                ```

            **Note:** TLS 1.3 only supports AEAD cipher suites by design.
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Configure cipher suites that include AEAD ciphers:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify AEAD ciphers are available:

                ```bash
                nmap --script ssl-enum-ciphers -p 443 yourdomain.com | grep -iE "GCM|CHACHA|CCM"
                ```
  - uid: mondoo-tls-security-ciphers-include-pfs
    title: Preferred ciphers must include perfect forward secrecy (PFS)
    impact: 95
    mql: tls.ciphers.any( /ecdhe_(rsa|ecdsa)|dhe_(rsa|dss)|cecpq/i )
    docs:
      desc: |
        PFS ensures that session keys cannot be derived from a compromised private key, protecting past communications even if future keys are exposed.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Configure cipher suites that use ECDHE or DHE for forward secrecy:

                ```apache
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                ```

                If using DHE, generate a strong DH parameter (2048-bit minimum):

                ```bash
                openssl dhparam -out /etc/ssl/dhparam.pem 2048
                ```

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify PFS is enabled using SSL Labs (look for "Forward Secrecy: Yes").

            **Note:** TLS 1.3 only supports forward secrecy by design.
        - id: nginx
          desc: |
            **Using Nginx**

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Configure cipher suites that use ECDHE or DHE for forward secrecy:

                ```nginx
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. If using DHE, generate and configure a strong DH parameter:

                ```bash
                openssl dhparam -out /etc/ssl/dhparam.pem 2048
                ```

                Then add to your Nginx config:

                ```nginx
                ssl_dhparam /etc/ssl/dhparam.pem;
                ```

            4. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            5. Verify PFS is enabled using SSL Labs (look for "Forward Secrecy: Yes").
        - id: haproxy
          desc: |
            **Using HAProxy**

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Configure cipher suites that use ECDHE or DHE for forward secrecy:

                ```haproxy
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify PFS is enabled using SSL Labs (look for "Forward Secrecy: Yes").

            **Note:** TLS 1.3 only supports forward secrecy by design.
  - uid: mondoo-tls-security-mitigate-beast
    title: Mitigate BEAST attacks on the server-side
    impact: 70
    mql: |-
      switch {
        case tls.versions.containsOnly(["tls1.2", "tls1.3"]):
          score(100);
        case tls.ciphers.all( /rc4/i ):
          score(100);
        case tls.ciphers.none( /null|dh_anon|export|des|rc2|idea/ ):
          score(80);
        default:
          score(0);
      }
    docs:
      desc: |
        BEAST attacks exploit vulnerabilities in SSL/TLS protocols using CBC encryption. This allows attackers to decrypt sensitive data by manipulating block boundaries.
      remediation:
        - id: apache
          desc: |
            **Using Apache**

            The recommended approach to mitigate BEAST is to disable TLS 1.0 and TLS 1.1 entirely.

            1. Open your Apache SSL configuration file (typically `/etc/httpd/conf.d/ssl.conf` or `/etc/apache2/sites-available/default-ssl.conf`).

            2. Configure protocols and cipher suites:

                ```apache
                SSLProtocol -all +TLSv1.2 +TLSv1.3
                SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
                SSLHonorCipherOrder on
                ```

                TLS 1.2 uses a different IV selection mechanism that prevents BEAST. TLS 1.3 only supports AEAD ciphers which are not vulnerable.

            3. Save the file and restart Apache:

                ```bash
                systemctl restart apache2   # Debian/Ubuntu
                systemctl restart httpd     # RHEL/CentOS
                ```

            4. Verify TLS 1.0/1.1 are disabled:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```

            **Important:** Do not use RC4 as a BEAST mitigation. RC4 has severe cryptographic weaknesses.
        - id: nginx
          desc: |
            **Using Nginx**

            The recommended approach to mitigate BEAST is to disable TLS 1.0 and TLS 1.1 entirely.

            1. Open your Nginx configuration file (typically `/etc/nginx/nginx.conf` or a site-specific file).

            2. Configure protocols and cipher suites:

                ```nginx
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers on;
                ```

            3. Save the file and reload Nginx:

                ```bash
                nginx -t && systemctl reload nginx
                ```

            4. Verify TLS 1.0/1.1 are disabled:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```

            **Important:** Do not use RC4 as a BEAST mitigation. RC4 has severe cryptographic weaknesses.
        - id: haproxy
          desc: |
            **Using HAProxy**

            The recommended approach to mitigate BEAST is to disable TLS 1.0 and TLS 1.1 entirely.

            1. Open your HAProxy configuration file (typically `/etc/haproxy/haproxy.cfg`).

            2. Configure protocols and cipher suites:

                ```haproxy
                ssl-default-bind-options ssl-min-ver TLSv1.2
                ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
                ```

            3. Save the file and restart HAProxy:

                ```bash
                systemctl restart haproxy
                ```

            4. Verify TLS 1.0/1.1 are disabled:

                ```bash
                openssl s_client -connect yourdomain.com:443 -tls1   # Should fail
                openssl s_client -connect yourdomain.com:443 -tls1_2 # Should succeed
                ```

            **Important:** Do not use RC4 as a BEAST mitigation. RC4 has severe cryptographic weaknesses.
    refs:
      - url: https://kb.vmware.com/s/article/2008784
        title: VMware mitigation of CVE-2011-3389 (BEAST) for web server administrators
