# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1

policies:
  - uid: mondoo-gcp-security
    name: Mondoo Google Cloud (GCP) Security
    version: 2.0.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: gcp,cloud
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |
        The Mondoo Google Cloud (GCP) Security policy is designed to identify critical misconfigurations that could leave your Google Cloud infrastructure vulnerable to attackers. This policy helps organizations detect and remediate security risks before they can be exploited, reducing the likelihood of unauthorized access, data breaches, privilege escalation, and operational disruptions.

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable. This policy is open-source and we welcome contributions from the community, whether it's adding new checks, refining existing ones, or providing feedback. If you have suggestions to improve this policy, visit our [cnspec-policies repository](https://github.com/mondoohq/cnspec-policies).
    groups:
      - title: GCP Project
        checks:
          - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account
          - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api
          - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances
          - uid: mondoo-gcp-security-oslogin-enabled-project
          - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible
          - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled
          - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed
          - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls
          - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled
          - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled
          - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose
          - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled
          - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled
          - uid: mondoo-gcp-security-compute-instances-no-public-ip
          - uid: mondoo-gcp-security-compute-instances-no-default-service-account
          - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys
          - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled
          - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled
          - uid: mondoo-gcp-security-compute-instances-vtpm-enabled
          - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled
          - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed
          - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed
          - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls
          - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls
    scoring_system: highest impact
queries:
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account
    title: Ensure that instances are not configured to use the default service account
    impact: 95
    variants:
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-single
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-hcl
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-plan
      - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Compute Engine instances are not configured to use the default service account (-compute@developer.gserviceaccount.com). Instead, instances should use custom service accounts with only the permissions required for their specific function, adhering to the principle of least privilege.

        Rationale:

        When the Compute Engine API is enabled on a new Google Cloud project, Google automatically creates a default Compute Engine service account with the IAM Editor role. This account has broad permissions across many Google Cloud services and is frequently used by default unless explicitly overridden:
          •	Using the default service account grants more privileges than most applications require, increasing the risk of privilege escalation or lateral movement in the event of compromise.
          •	The default service account is shared across all instances in the project, reducing visibility and control over which workloads can access which resources.
          •	Misuse or over-permissioning of default service accounts has been the cause of multiple cloud security incidents, particularly when combined with metadata API access.

        If instances continue to use the default service account, it can lead to:
          •	Excessive permissions, violating least privilege principles and security best practices.
          •	Difficult-to-audit access patterns, as many services share a single identity with broad permissions.
          •	Increased blast radius if the service account credentials are leaked or the instance is compromised.
          •	Non-compliance with security benchmarks such as CIS Google Cloud Platform Foundations Benchmark and NIST 800-53.

        Risk mitigation:
          •	Replace default service accounts with custom service accounts that have narrowly scoped IAM roles tailored to the workload.
          •	Regularly review and audit service account usage to ensure they are aligned with current access needs.
          •	Disable or delete the default service account only after ensuring that no dependent applications or services will be disrupted.
          •	Leverage IAM Conditions and organization policies to prevent the use of default service accounts in new deployments.

        By avoiding the use of the default Compute Engine service account, organizations can enforce better identity isolation, minimize unnecessary permissions, and enhance the overall security posture of their Google Cloud environment.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            To provision or update a compute instance with a custom service account:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ["terraform"]

              service_account {
                email  = "example@example.com"
                scopes = ["user-email", "compute-ro", "storage-ro"]
              }
            }
            ```
        - id: console
          desc: |
            **Google Cloud Console**

            To change the policy using the GCP Console, follow these steps:

            1. Log in to the GCP Console at https://console.cloud.google.com.
            2. Select the Organization and Project where the instance you want to update is running.
            3. Navigate to **Compute Engine**.
            4. Select the compute instance that you want to update.
            5. If the instance is not stopped, select **Stop**. Wait for the instance to stop.
            6. Select **Edit**.
            7. Scroll down to the Service Account section.
            8. Select a different service account.
            9. Select **Save**.
            10. Select **START**.
        - id: cli
          desc: |
            **gcloud cli**

            To update the service account using the `gcloud` cli:

            1. Stop the instance:

              ```bash
              gcloud compute instances stop INSTANCE_NAME
              ```

            2. Update the instance:

              ```bash
              gcloud compute instances set-service-account INSTANCE_NAME --service-account=SERVICE_ACCOUNT --scopes [SCOPE1,SCOPE2...]
              ```

            3. Restart the instance:

              ```bash
              gcloud compute instances start INSTANCE_NAME
              ```
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
        gcp.compute.instance.serviceAccounts.none(
          email == /^.*compute@developer\.gserviceaccount\.com$/
        )
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance').any(
        blocks.where(type == 'service_account').one(type == 'service_account')
      )
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance').none(
        change.after.contains(/^.*compute@developer\.gserviceaccount\.com$/)
      )
  - uid: mondoo-gcp-security-instances-are-not-configured-use-default-service-account-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance') { 
        values.service_account.contains(/^.*compute@developer\.gserviceaccount\.com$/) 
      }



  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api
    title: Ensure instances are not configured to use the default service account with full access to all Cloud APIs
    impact: 90
    variants:
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-single
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-hcl
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-plan
      - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Compute Engine instances are not provisioned with full access to all Google Cloud APIs. Instead, instances should be assigned custom service accounts with narrowly scoped permissions, adhering to the principle of least privilege.

        Rationale:

        By default, when creating a Compute Engine instance, users can assign it “Allow full access to all Cloud APIs”, granting unrestricted access to most Google Cloud services. This setting is overly permissive and introduces significant security risk:
          •	It allows the instance to interact with nearly any Google Cloud API, regardless of the workload's actual needs.
          •	In the event of a compromise, an attacker could use the instance's credentials to access sensitive resources, manipulate cloud infrastructure, or move laterally across services.
          •	The broad access complicates auditing and access management, making it harder to identify excessive privileges or detect misuse.

        If instances are provisioned with full API access, it can lead to:
          •	Privilege escalation and lateral movement, especially if metadata APIs are accessible from within the VM.
          •	Increased blast radius in the event of credential theft or VM compromise.
          •	Violations of least privilege and non-compliance with security frameworks such as CIS GCP Foundations Benchmark, NIST 800-53, and ISO 27001.
          •	Obscured audit trails, since full access allows interactions with multiple services without role-based segmentation.

        Risk mitigation:
          •	Assign custom service accounts to instances with only the specific roles required for their function.
          •	Avoid using the “Allow full access to all Cloud APIs” option during instance creation.
          •	Enforce IAM policies and organizational constraints to block the use of overly permissive API scopes.
          •	Continuously review service account permissions and API scopes as part of your identity and access governance strategy.

        Restricting Compute Engine instances to minimal necessary API access helps contain the impact of security incidents, improves visibility and control, and supports a robust and compliant cloud security posture.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            To provision or update a compute instance with Terraform:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ['terraform']

              service_account {
                # Google recommends custom service accounts with cloud-platform scope and permissions granted via IAM Roles.
                email  = google_service_account.default.email
                scopes = ["cloud-platform"]
              }
            }
            ```
        - id: console
          desc: |
            **Google Cloud Console**

            To change the policy using the Google Cloud Console:

            1. Log in to the GCP Console at https://console.cloud.google.com.
            2. Select the Organization and Project where the instance you want to update is running.
            3. Navigate to **Compute Engine**.
            4. Select the compute instance that you want to update.
            5. If the instance is not stopped, select **Stop**. Wait for the instance to stop.
            6. Select **Edit**.
            7. Scroll down to the Service Account section.
            8. Select a different service account or ensure Allow full access to all Cloud APIs is not selected.
            9. Select **Save**.
            10. Select **START**.
        - id: cli
          desc: |
            **gcloud cli**

            To update the service account using the `gcloud` cli:

            1. Stop the instance:

              ```bash
              gcloud compute instances stop INSTANCE_NAME
              ```

            2. Update the instance:

              ```bash
              gcloud compute instances set-service-account INSTANCE_NAME --service-account=SERVICE_ACCOUNT --scopes [SCOPE1,SCOPE2...]
              ```

            3. Restart the instance:

              ```bash
              gcloud compute instances start INSTANCE_NAME
              ```
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
      gcp.compute.instance.serviceAccounts.none(
        scopes == 'https://www.googleapis.com/auth/cloud-platform'
      )
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance') {
        blocks.where(type == 'service_account') {
          arguments.scopes.none(_ == 'https://www.googleapis.com/auth/cloud-platform')
        }
      }
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance') {
        change.after.service_account { 
          _['scopes'].none(_ == 'https://www.googleapis.com/auth/cloud-platform') 
        }
      }
  - uid: mondoo-gcp-security-instances-not-configured-with-default-service-account-full-access-cloud-api-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance') { 
        values.service_account {
          _['scopes'].none(_ == 'https://www.googleapis.com/auth/cloud-platform') 
        }
      }



  - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances
    title: Ensure "Block Project-wide SSH keys" is enabled for VM instances
    impact: 70
    variants:
      - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-single
      - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-terraform-hcl
      - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-terraform-plan
      - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Platform (GCP) projects are configured to use instance-specific SSH keys rather than project-wide SSH keys. This approach limits the impact of credential compromise and supports strong access control at the individual virtual machine level.

        Rationale:

        GCP allows SSH keys to be defined at the project level, enabling access to all Compute Engine instances within the project. While this simplifies SSH key management, it introduces significant security risks:
          •	If a project-wide SSH key is compromised, an attacker may gain access to every VM in the project.
          •	Project-wide keys promote shared access, making it harder to enforce least privilege and track user-specific activity.
          •	Revoking access for a user with a project-wide key affects all instances, which can lead to operational disruption or security gaps.

        In contrast, instance-specific SSH keys offer finer-grained access control:
          •	Keys are scoped only to the VM they are intended for.
          •	It is easier to manage user access on a per-instance basis.
          •	Auditability is improved, as access can be tracked and revoked at the individual instance level.

        If project-wide SSH keys are used, it may result in:
          •	Expanded attack surface, where one key exposes multiple critical systems.
          •	Difficulty in access governance, particularly in large or multi-team environments.
          •	Non-compliance with cloud security benchmarks like the CIS GCP Foundations Benchmark and access control requirements in frameworks such as NIST 800-53 and ISO 27001.

        Risk mitigation:
          •	Disable project-wide SSH key usage by setting the enable-oslogin metadata to TRUE at the project level.
          •	Configure instance-level SSH keys via instance metadata or use OS Login for centralized and auditable access management.
          •	Regularly audit and rotate SSH keys, ensuring access is granted only where needed.
          •	Enforce organizational policies to prohibit the use of project-wide SSH keys across GCP environments.

        Using instance-specific SSH keys improves access control, reduces the blast radius of credential compromise, and aligns with cloud security best practices that emphasize isolation, auditability, and least privilege.
      remediation: 
        - id: terraform
          desc: |
            **Terraform**

            To provision or update a compute instance with Terraform:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ['terraform']

              metadata = {
                block-project-ssh-keys = true
              }
            }
            ```
        - id: console
          desc: |
            **Google Cloud Console**

            To change the policy using the GCP Console:

            1. Log in to the GCP Console at https://console.cloud.google.com.
            2. Select the organization/project where the instance(s) you want to update are running.
            3. Navigate to **Compute Engine**.
            4. Select the instance you want to update.
            5. Select **EDIT** in the toolbar.
            6. Under the **Security and access** section, select the **Block project-wide SSH keys** option.
            7. Select **SAVE**.

            Repeat these steps for each impacted Instance.
        - id: cli
          desc: |
            **Using CLI** `gcloud cli`

            To update an instance using the `gcloud` cli:

            1. Update the instance:

            ```bash
            gcloud compute instances add-metadata INSTANCE_NAME --metadata block-projectssh-keys=true
            ```
  - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-single
    filters: asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance.metadata['block-project-ssh-keys'] == true
  - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-terraform-hcl
    filters: asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance').all(arguments.metadata['block-project-ssh-keys'] == true)
  - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-terraform-plan
    filters: asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance').all(
        change.after['metadata']['block-project-ssh-keys'] == true
      )
  - uid: mondoo-gcp-security-block-project-wide-ssh-keys-enabled-vm-instances-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance') {
        values.metadata['block-project-ssh-keys'] == true
      }



  - uid: mondoo-gcp-security-oslogin-enabled-project
    title: Ensure oslogin is enabled for compute instances
    impact: 70
    variants:
      - uid: mondoo-gcp-security-oslogin-enabled-project-single
      - uid: mondoo-gcp-security-oslogin-enabled-project-terraform-hcl
      - uid: mondoo-gcp-security-oslogin-enabled-project-terraform-plan
      - uid: mondoo-gcp-security-oslogin-enabled-project-terraform-state
    docs:
      desc: |
        This check ensures that OS Login is enabled on Google Cloud Platform (GCP) Compute Engine instances to manage SSH access through IAM roles rather than relying on SSH keys stored in project or instance metadata. OS Login improves access control, auditability, and security by centralizing identity-based SSH authentication.

        Rationale:

        By default, SSH access to GCP Compute Engine instances is managed using manually added SSH keys in project or instance metadata. This method has several limitations:
          •	SSH keys are difficult to track, audit, and revoke, especially in large or dynamic environments.
          •	Key-based access lacks integration with IAM policies, which makes it harder to enforce centralized identity governance.
          •	Users can retain access indefinitely if SSH keys are not manually removed, creating lingering access risks.

        OS Login solves these issues by integrating SSH access with IAM:
          •	Access is granted or revoked based on IAM roles (roles/compute.osLogin, roles/compute.osAdminLogin).
          •	User access is managed centrally and consistently across all instances.
          •	Login activity is auditable through Cloud Audit Logs and linked to the user's Google identity.

        If OS Login is not enabled, it can lead to:
          •	Stale or orphaned SSH keys, increasing the risk of unauthorized access.
          •	Limited visibility and control over who has access to which instances.
          •	Non-compliance with security best practices and frameworks like CIS GCP Foundations Benchmark, NIST 800-53, and ISO 27001.
          •	Operational complexity, as access changes require manual updates to metadata.

        Risk mitigation:
          •	Enable OS Login by setting the enable-oslogin metadata key to TRUE at the project or instance level.
          •	Use IAM roles to define which users can access which instances, and whether they have standard or administrative privileges.
          •	Leverage OS Login with 2-Step Verification (OS Login 2SV) for enhanced access protection.
          •	Regularly review IAM policies and login activity to ensure appropriate access and detect anomalies.

        Enabling OS Login provides a secure, scalable, and manageable way to control SSH access to Compute Engine instances, aligning with best practices for identity-based access control and centralized policy enforcement in GCP environments.
      remediation: 
        - id: terraform
          desc: |
            **Terraform**

            To configure OS Login for a project:

            ```hcl
            resource "google_compute_project_metadata" "default" {
              metadata = {
                enable-oslogin = "TRUE"
              }
            }
            ```

            To provision or update a compute instance with Terraform:

            ```hcl
            resource "google_compute_instance" "default" {
              name         = "secure-instance"
              machine_type = var.machine_type
              zone         = var.zone
              tags = ['terraform']

              metadata = {
                "enable-oslogin" = "true"
              }
            }
            ```
        - id: console
          desc: |
            **Google Cloud Console**

            To configure OS Login for a project via Google Cloud Console:

            1. In the Google Cloud console, go to the **Metadata** page.
            2. Select **EDIT**.
            3. Add a metadata entry, setting the key to `enable-oslogin` and the value to `TRUE`.
            4. Select **SAVE** to apply the changes.

            To configure OS Login for an existing instance:

            1. In the Google Cloud console, go to the **Compute Engine**.
            2. Select the name of the instance that you want to enable OS Login on.
            3. On the instance details page, select **EDIT**.
            4. Under **Custom metadata**, add a metadata entry, setting the key to `enable-oslogin` and the value to `TRUE`.
            5. Select **SAVE**.
        - id: console
          desc: |
            **gcloud cli**

            To update OS Login for a project using the `gcloud` cli:

            ```bash
            gcloud compute project-info add-metadata --metadata enable-oslogin=TRUE
            ```

            To update OS Login for an existing instance using the `gcloud` cli:

            ```bash
            gcloud compute instances add-metadata INSTANCE_NAME --metadata enable-oslogin=TRUE
            ```
  - uid: mondoo-gcp-security-oslogin-enabled-project-single
    filters: asset.platform == 'gcp-compute-instance'
    mql: gcp.compute.instance.metadata['enable-oslogin'] == true
  - uid: mondoo-gcp-security-oslogin-enabled-project-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance' || nameLabel == 'google_compute_project_metadata')
    mql: |
      # Check instance metadata
      terraform.resources.where(nameLabel == 'google_compute_instance').all(
        arguments.metadata['enable-oslogin'] == true
      )

      # Check project metadata
      terraform.resources.where(nameLabel == 'google_compute_project_metadata').all(
        arguments.metadata['enable-oslogin'] == 'TRUE'
      )
  - uid: mondoo-gcp-security-oslogin-enabled-project-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance' || type == 'google_compute_project_metadata')
    mql: |
      # Check instance metadata
      terraform.plan.resourceChanges.where(type == 'google_compute_instance').all(
        change.after.metadata['enable-oslogin'] == true
      )

      # Check project metadata
      terraform.plan.resourceChanges.where(type == 'google_compute_project_metadata').all(
        change.after.metadata['enable-oslogin'] == 'TRUE'
      )
  - uid: mondoo-gcp-security-oslogin-enabled-project-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance' || type == 'google_compute_project_metadata')
    mql: |
      # Check instance metadata
      terraform.state.resources.where(type == 'google_compute_instance').all(
        values.metadata['enable-oslogin'] == true
      )

      # Check project metadata
      terraform.state.resources.where(type == 'google_compute_project_metadata').all(
        values.metadata['enable-oslogin'] == "TRUE"
      )



  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible
    title: Ensure that Cloud Storage buckets are not anonymously or publicly accessible
    impact: 90
    variants:
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-single
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-hcl
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-plan
      - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-state
    docs:
      desc: |
        This check ensures that Google Cloud Storage buckets do not have IAM bindings or ACLs that grant access to the allUsers or allAuthenticatedUsers principals. These principals represent unauthenticated and broadly authenticated public access, which significantly increases the risk of unintentional data exposure.

        Rationale:

        In Google Cloud, the allUsers principal allows anyone on the internet to access a resource without authentication, while allAuthenticatedUsers allows access to any user with a Google account. Assigning these principals to a Cloud Storage bucket—either directly via IAM roles or indirectly through legacy ACLs—exposes data to a much broader audience than intended.

        This type of access is often misconfigured and can lead to:
          •	Public exposure of sensitive data, including personally identifiable information (PII), internal documents, or application configuration files.
          •	Data misuse or leakage, especially if access is granted with roles beyond read-only permissions.
          •	Non-compliance with regulatory frameworks like GDPR, HIPAA, PCI DSS, ISO 27001, and the CIS GCP Foundations Benchmark.
          •	Audit and incident response challenges, since access by allUsers or allAuthenticatedUsers is not attributable to a specific identity.

        Risk mitigation:
          •	Audit IAM policies and bucket ACLs to detect any bindings involving allUsers or allAuthenticatedUsers.
          •	Remove these principals from bucket policies and replace them with specific identities (e.g., service accounts, groups, or individual users) that require access.
          •	Enable Public Access Prevention to proactively block public access configuration.
          •	Enforce organization policies that restrict or deny the use of these principals across your projects.

        Eliminating access for allUsers and allAuthenticatedUsers on Cloud Storage buckets is a critical step in protecting cloud-resident data, enforcing least privilege access, and ensuring compliance with modern cloud security and privacy standards.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            To update public access configuration using Terraform, ensure `allUsers` and `allAuthenticatedUsers` are not set:

            ```hcl
            resource "google_storage_bucket_iam_binding" "binding" {
              bucket = google_storage_bucket.default.name
              role   = "roles/storage.admin"
              members = [
                "user:jane@example.com",
              ]
            }
            ```

            ```hcl
            resource "google_storage_bucket_iam_member" "member" {
              bucket = google_storage_bucket.default.name
              role   = "roles/storage.admin"
              member = "user:jane@example.com"
            }
            ```
        - id: console
          desc: |
            **Google Cloud Console**

            1. In the Google Cloud console, go to the **Cloud Storage Bucket** page.
            2. For the bucket you want to enforce public access prevention on, select the more actions menu.
            3. Select **Edit access** from the drop-down menu.
            4. In the Public access card, select **Prevent public access** to enforce public access prevention.
            5. Select **Confirm**.
        - id: cli
          desc: |
            **gcloud cli**

            To update public access configuration using the `gcloud` cli, ensure `allUsers` and `allAuthenticatedUsers` are not set by removing them:

            ```bash
            # Example: Remove allUsers binding for objectViewer role
            gcloud storage buckets remove-iam-policy-binding gs://BUCKET_NAME --member=allUsers --role=roles/storage.objectViewer

            # Example: Remove allAuthenticatedUsers binding for objectViewer role
            gcloud storage buckets remove-iam-policy-binding gs://BUCKET_NAME --member=allAuthenticatedUsers --role=roles/storage.objectViewer
            ```
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-single
    filters: asset.platform == 'gcp-storage-bucket'
    mql: |
      gcp.storage.bucket.iamPolicy.all(members.none(_ == 'allUsers'))
      gcp.storage.bucket.iamPolicy.all(members.none(_ == 'allAuthenticatedUsers'))
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_storage_bucket_iam_binding' || nameLabel == 'google_storage_bucket_iam_member')
    mql: |
      terraform.resources.where(nameLabel == 'google_storage_bucket_iam_binding').all(
        arguments.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
      terraform.resources.where(nameLabel == 'google_storage_bucket_iam_member').all(
        arguments.member != 'allUsers' && arguments.member != 'allAuthenticatedUsers'
      )
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_storage_bucket_iam_binding' || type == 'google_storage_bucket_iam_member')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_storage_bucket_iam_binding').all(
        change.after.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
      terraform.plan.resourceChanges.where(type == 'google_storage_bucket_iam_member').all(
        change.after.member != 'allUsers' && change.after.member != 'allAuthenticatedUsers'
      )
  - uid: mondoo-gcp-security-cloud-storage-bucket-not-anonymously-publicly-accessible-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_storage_bucket_iam_binding' || type == 'google_storage_bucket_iam_member')
    mql: |
      terraform.state.resources.where(type == 'google_storage_bucket_iam_binding').all(
        values.members.none(_ == 'allUsers' || _ == 'allAuthenticatedUsers')
      )
      terraform.state.resources.where(type == 'google_storage_bucket_iam_member').all(
        values.member != 'allUsers' && values.member != 'allAuthenticatedUsers'
      )


  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled
    title: Ensure that Cloud Storage buckets have uniform bucket-level access enabled
    impact: 60
    variants:
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-single
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-state
    docs:
      desc: |
        Cloud Storage offers two systems for granting users permission to access your buckets and objects: IAM and Access Control Lists (ACLs). These systems act in parallel - in order for a user to access a Cloud Storage resource, only one of the systems needs to grant the user permission. IAM is used throughout Google Cloud and allows you to grant a variety of permissions at the bucket and project levels. ACLs are used only by Cloud Storage and have limited permission options, but they allow you to grant permissions on a per-object basis.

        It is recommended to enable uniform bucket-level access on Cloud Storage buckets. Uniform bucket-level access is used to unify and simplify how you grant access to your Cloud Storage resources. Cloud Storage offers two systems that act in parallel to grant users permission to access buckets and objects:
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_storage_bucket" "example" {
              name                        = "test-bucket"
              # Enable uniform bucket-level access
              uniform_bucket_level_access = true
            }
            ```
        - id: console
          desc: |
            **Google Cloud Console**

            1. In the Google Cloud console, go to the **Cloud Storage Buckets** page.
            2. In the list of buckets, select the name of the desired bucket.
            3. Select the **Permissions** tab near the top of the page.
            4. In the **Access control** model section, select **Uniform**.
            5. In the pop-up menu that appears, select **Save**.
        - id: cli
          desc: |
            **gcloud cli**

            ```bash
            # Enable uniform bucket-level access
            gcloud storage buckets update gs://BUCKET_NAME --uniform-bucket-level-access

            # Alternatively using gsutil
            gsutil uniformbucketlevelaccess set on gs://BUCKET_NAME
            ```
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-single
    filters: asset.platform == 'gcp-storage-bucket'
    mql: gcp.storage.bucket.iamConfiguration.UniformBucketLevelAccess.enabled == true
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_storage_bucket')
    mql: |
      terraform.resources.where(nameLabel == 'google_storage_bucket').all(
        arguments.uniform_bucket_level_access == true
      )
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_storage_bucket')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_storage_bucket').all(
        change.after.uniform_bucket_level_access == true
      )
  - uid: mondoo-gcp-security-cloud-storage-buckets-have-uniform-bucket-level-access-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_storage_bucket')
    mql: |
      terraform.state.resources.where(type == 'google_storage_bucket').all(
        values.uniform_bucket_level_access == true
      )


  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed
    title: Ensure Cloud SQL MySQL instances are not publicly exposed
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-state
    docs:
      desc: |
        Assigning public IP addresses to Cloud SQL MySQL instances expands the potential attack surface, making databases accessible from the public internet and increasing security risks.

        The recommended practice is to configure instances exclusively with private IP addresses. This enhances security by isolating the database within your VPC network and can reduce latency for internal applications. Be aware that removing a public IP will disrupt existing connections that depend on it; establish and test private connectivity paths before making the change.
      audit: |
        **Using the Google Cloud Console**

          1. Navigate to the Cloud SQL Instances page within the Google Cloud Console: https://console.cloud.google.com/sql/instances
          2. Review each MySQL instance listed. For every primary (non-replica) Second Generation instance, examine its networking details to confirm that a Private IP address is assigned and that no Public IP address is present.

        ** Using the Google Cloud CLI **

          1. Obtain a list of all your Cloud SQL instances:

            ```bash
            gcloud sql instances list
            ```

          2. For each instance identified as `backendType: SECOND_GEN` and `instanceType: CLOUD_SQL_INSTANCE` (primary instance), retrieve its full configuration details. Read replicas (`instanceType: READ_REPLICA_INSTANCE`) inherit network settings, and First Generation instances do not support private IPs, so they can be skipped for this check.

            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```

          3. Inspect the `ipAddresses` section in the output for the instance. Verify that an entry exists with `type: PRIVATE`. Crucially, ensure there is no entry with `type: PRIMARY`, as this indicates a public IP address. While an instance can technically possess both during transitions, the secure state is having only the `PRIVATE` type assigned.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_sql_database_instance" "example" {
              name             = "example-instance"
              database_version = "MYSQL_8_0"  # Or your preferred version
              region           = "us-central1"  # Replace with your region

              settings {
                tier = "db-f1-micro"

                # Remove public IP by setting ip_configuration.ipv4_enabled to false
                ip_configuration {
                  ipv4_enabled    = false
                  private_network = "projects/PROJECT_ID/global/networks/VPC_NETWORK_NAME"
                }
              }
            }
            ```
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page in the Google Cloud Console: https://console.cloud.google.com/sql/instances
            2.  Click on the name of the target instance to view its configuration details.
            3.  Navigate to the **Connections** settings tab.
            4.  Under the **Networking** section, locate and uncheck the box labeled **Public IP**.
            5.  Confirm the modification by clicking the **Save** button.

            **Prevention:**

            To proactively enforce that new Cloud SQL instances are not created with public IP addresses, implement the `Restrict Public IP access on Cloud SQL instances` Organization Policy. You can configure this policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            1.  Modify the target instance to remove its public IP address and ensure it's associated with a VPC network for private IP access. Replace `INSTANCE_NAME` with the actual instance name and `VPC_NETWORK_NAME` with the desired VPC network name:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --network=VPC_NETWORK_NAME --no-assign-ip
                ```
                *Note: If the instance is already associated with the correct VPC network for private IP, you might only need the `--no-assign-ip` flag.*
            2.  Verify that the public IP address has been removed by inspecting the instance's configuration:
                ```bash
                gcloud sql instances describe INSTANCE_NAME
                ```
                Check the `ipAddresses` section in the output to confirm the absence of an entry with `type: PRIMARY`.
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(maintenanceVersion.contains('MYSQL')) {
        ipAddresses.all(
          _.type != "PRIMARY"
        )
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance') {
        blocks {
          blocks.where(attributes['ipv4_enabled'] != null) {
            _.attributes['ipv4_enabled'].value == true
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance').all(
        change.after['settings'] {
          _['ip_configuration'].any(_['ipv4_enabled'] == true)
        }
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-instances-not-publicly-exposed-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance') {
        values['ip_address'].none(type == 'PRIMARY')
      }



  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls
    title: Ensure Cloud SQL MySQL connections require SSL/TLS
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-state
    docs:
      desc: |
        Requiring SSL/TLS for connections to Cloud SQL MySQL instances encrypts data in transit between the client and the database server. This prevents potential eavesdropping and man-in-the-middle attacks, protecting sensitive data from unauthorized access during transmission.

        It is strongly recommended to configure Cloud SQL instances to enforce SSL/TLS for all incoming connections to maintain data confidentiality and integrity. Note that enabling this setting requires clients to be configured correctly to use SSL/TLS, which might necessitate application updates.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: https://console.cloud.google.com/sql/instances
        2.  Click on the name of the MySQL instance you want to audit.
        3.  Select the **Connections** tab.
        4.  Go to the **Security** sub-tab.
        5.  Verify that the checkbox for **Allow only SSL connections** is checked.

        **Using the Google Cloud CLI**

        1.  Retrieve the configuration details for the instance:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```
        2.  Inspect the output and locate the `settings.ipConfiguration` section.
        3.  Ensure the value for `sslMode` is set to `ENCRYPTED_ONLY` and the value for `requireSsl` is set to `true`.

            Example relevant output snippet:
            ```yaml
            settings:
              ipConfiguration:
                sslMode: ENCRYPTED_ONLY
                requireSsl: true
                # ... other ipConfiguration settings
            ```
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page: https://console.cloud.google.com/sql/instances
            2.  Click the name of the target MySQL instance.
            3.  Navigate to the **Connections** tab, then the **Security** sub-tab.
            4.  Check the box labeled **Allow only SSL connections**.
            5.  Click **Save** to apply the change. *Note: This may trigger an instance restart.*

            **Prevention:**

            Always configure new Cloud SQL MySQL instances with the "Allow only SSL connections" option enabled during creation via the Console. Regularly audit instances to ensure compliance.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            1.  Enable the "Require SSL" setting for the instance:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --require-ssl
                ```
                *Note: This command may cause the instance to restart.*
            2.  Confirm the change:
                ```bash
                gcloud sql instances describe INSTANCE_NAME --format='value(settings.ipConfiguration.requireSsl)'
                ```
                The output should be `True`.

            **Prevention:**

            Always configure new Cloud SQL MySQL instances with the `--require-ssl` flag during creation via the CLI. Regularly audit instances to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `require_ssl` attribute within the `ip_configuration` block is set to `true`:

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-mysql-instance"
              database_version = "MYSQL_8_0"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  ipv4_enabled = true
                  # Set require_ssl to true
                  require_ssl  = true
                  # Optional: Set ssl_mode if needed, e.g., ENCRYPTED_ONLY
                  # ssl_mode     = "ENCRYPTED_ONLY"
                }
              }
            }
            ```

            **Prevention:**

            Always configure new Cloud SQL MySQL instances with `require_ssl = true` during creation via Terraform. Regularly audit instances to ensure compliance.
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(maintenanceVersion.contains('MYSQL')) {
        settings.ipConfiguration {
          sslMode == 'ENCRYPTED_ONLY'
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance') {
        blocks {
          blocks.where(attributes['ssl_mode'] != null) {
            _.attributes['ssl_mode'].value == 'ENCRYPTED_ONLY'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance') {
        change.after['settings'] {
          _['ip_configuration'] {
            _['ssl_mode'] == 'ENCRYPTED_ONLY'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-connections-require-ssl-tls-terraform-state
    filters: |
      asset.platform == 'terraform-state' &&  terraform.state.resources.where(type == 'google_sql_database_instance')
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance') {
        values['settings'] { 
          _['ip_configuration'] { 
            _['ssl_mode'] == 'ENCRYPTED_ONLY' 
          }
        } 
      }



  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled
    title: Ensure 'skip_show_database' Database Flag for Cloud SQL MySQL Instances is enabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-state
    docs:
      desc: |
        **Rationale:**

        The 'skip_show_database' flag enhances security by restricting the use of the `SHOW DATABASES` command. When enabled ('on'), only users explicitly granted the `SHOW DATABASES` privilege can execute the command, and they will see all databases. If disabled ('off'), any user can run `SHOW DATABASES`, but they will only see databases for which they possess the `SHOW DATABASES` privilege or other specific privileges. Enabling this flag helps prevent users from discovering the existence of databases they shouldn't access. This setting applies specifically to Cloud SQL for MySQL instances.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a MySQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `skip_show_database` flag is listed and its value is set to `on`.

        **Using the Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each MySQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="skip_show_database")|.value'
            ```
            Ensure the output for each MySQL instance is `"on"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(settings.databaseFlags['skip_show_database'] == 'on')"
           ```
           Verify the flag value is `on` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Go to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target MySQL instance.
            3.  Click **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, click **Add item**.
            6.  Choose `skip_show_database` from the dropdown and set its value to `on`. If the flag exists but is `off`, change its value to `on`.
            7.  Click **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            Update the flag for a specific MySQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags skip_show_database=on
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags skip_show_database=on,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "mysql_instance" {
              name             = "my-mysql-instance"
              database_version = "MYSQL_8_0"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "skip_show_database"
                  value = "on"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-all
    filters: |
      asset.platform == 'gcp-project'
      gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/)
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(
        settings.databaseFlags['skip_show_database'] == 'on'
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'skip_show_database') {
            arguments['value'] == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL')) {
        change.after['settings'] {
          _['database_flags'].where(name == 'skip_show_database') {
            _['value'] == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-skip-show-database-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL')) {
        values['settings'] {
          _['database_flags'].where(name == 'skip_show_database') {
            value == 'on'
          }
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled
    title: Ensure the 'local_infile' Database Flag for Cloud SQL MySQL Instance is disabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-all
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-state
    docs:
      desc: |
        **Rationale:**

        The `local_infile` database flag dictates whether the server permits clients to load data using the `LOAD DATA LOCAL INFILE` statement. Enabling this feature (setting it to `on`) can introduce security vulnerabilities, as a compromised client or a malicious server could potentially access local files on the machine running the client or server, respectively. To mitigate this risk, it is strongly recommended to disable this flag by setting it to `off`. This recommendation applies specifically to Cloud SQL for MySQL instances.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a MySQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `local_infile` flag is listed and its value is set to `off`.

        **Using the Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each MySQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="local_infile")|.value'
            ```
            Ensure the output for each MySQL instance is `"off"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(settings.databaseFlags['local_infile'] == 'off')"
           ```
           Verify the flag value is `off` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Go to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target MySQL instance.
            3.  Click **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, click **Add item**.
            6.  Choose `local_infile` from the dropdown and set its value to `off`. If the flag exists but is `on`, change its value to `off`.
            7.  Click **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            Update the flag for a specific MySQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags local_infile=off
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags local_infile=off,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "mysql_instance" {
              name             = "my-mysql-instance"
              database_version = "MYSQL_8_0"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "local_infile"
                  value = "off"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^MYSQL_/).all(
        settings.databaseFlags['local_infile'] == 'off'
      )
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('MYSQL')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'local_infile') {
            arguments['value'] == 'off'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('MYSQL')) {
        change.after['settings'] {
          _['database_flags'].where(name == 'local_infile') { 
            value == 'off'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-mysql-local-infile-disabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('MYSQL')) {
        values['settings'] {
          _['database_flags'].where(name == 'local_infile') { 
            value == 'off' 
          }
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose
    title: Ensure the 'log_error_verbosity' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'DEFAULT' or 'verbose'
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-state
    docs:
      desc: |
        **Rationale:**

        The `log_error_verbosity` flag in PostgreSQL controls the level of detail included in server log messages for errors. Possible settings include `TERSE` (minimal details), `DEFAULT` (standard details), and `VERBOSE` (includes SQL state codes, source file, function name, and line number). Logging provides essential information for troubleshooting and security analysis. Setting this flag to `DEFAULT` or `VERBOSE` ensures sufficient detail is captured without being overly sparse. Setting it to `TERSE` might omit crucial context needed for effective analysis. This recommendation applies specifically to Cloud SQL for PostgreSQL instances.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a PostgreSQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `log_error_verbosity` flag is listed and its value is set to `DEFAULT` or `VERBOSE`.

        **Using the Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each PostgreSQL instance, check the flag's value:
            ```bash
            # This command shows the value, verify it's "DEFAULT" or "VERBOSE"
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="log_error_verbosity")|.value'
            ```
            Ensure the output for each PostgreSQL instance is `"DEFAULT"` or `"VERBOSE"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(settings { databaseFlags['log_error_verbosity'] == 'verbose' })"
           ```
           Verify the flag value is `DEFAULT` or `VERBOSE` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Go to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target PostgreSQL instance.
            3.  Click **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, click **Add item**.
            6.  Choose `log_error_verbosity` from the dropdown and set its value to `DEFAULT` or `VERBOSE`. If the flag exists but is set to `TERSE`, change its value.
            7.  Click **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            Update the flag for a specific PostgreSQL instance (choose `DEFAULT` or `VERBOSE`):
            ```bash
            # Example using DEFAULT
            gcloud sql instances patch INSTANCE_NAME --database-flags log_error_verbosity=DEFAULT

            # Example using VERBOSE
            gcloud sql instances patch INSTANCE_NAME --database-flags log_error_verbosity=VERBOSE
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags log_error_verbosity=DEFAULT,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting (choose `DEFAULT` or `VERBOSE`):
            ```hcl
            resource "google_sql_database_instance" "postgres_instance" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "log_error_verbosity"
                  # Choose either "DEFAULT" or "VERBOSE"
                  value = "DEFAULT"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings {
          databaseFlags['log_error_verbosity'] == 'verbose'
        }
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_error_verbosity') {
            arguments['value'] == 'verbose'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-plan
    filters: |
      asset.platform == 'terraform-plan'
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')) {
        change.after['settings'] {
          _['database_flags'].where(name == 'log_error_verbosity') {
            value.upcase == 'verbose'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-error-verbosity-default-verbose-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')) {
        values['settings'] {
          _['database_flags'].where(name == 'log_error_verbosity') {
            value == 'verbose'
          }
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled
    title: Ensure 'log_connections' Database Flag for Cloud SQL PostgreSQL Instances is enabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-state
    docs:
      desc: |
        **Rationale:**

        By default, PostgreSQL does not log connection attempts. Enabling the `log_connections` flag (setting it to `on`) configures the server to record each attempted connection and successful client authentication. This logging is valuable for security monitoring, allowing administrators to identify unusual connection patterns or potential unauthorized access attempts, and for troubleshooting connectivity issues. This recommendation applies specifically to Cloud SQL for PostgreSQL instances.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a PostgreSQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `log_connections` flag is listed and its value is set to `on`.

        **Using the Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each PostgreSQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="log_connections")|.value'
            ```
            Ensure the output for each PostgreSQL instance is `"on"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(settings.databaseFlags['log_connections'] == 'on')"
           ```
           Verify the flag value is `on` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Go to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target PostgreSQL instance.
            3.  Click **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, click **Add item**.
            6.  Choose `log_connections` from the dropdown and set its value to `on`. If the flag exists but is `off`, change its value to `on`.
            7.  Click **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            Update the flag for a specific PostgreSQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags log_connections=on
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags log_connections=on,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "postgres_instance" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "log_connections"
                  value = "on"
                }
                # Include other settings and flags as needed
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings.databaseFlags['log_connections'] == 'on'
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_connections') {
            arguments['value'] == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')) {
        change.after['settings'] {
          _['database_flags'].where(name == 'log_connections') {
            value == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-connections-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')) {
        values['settings'] {
          _['database_flags'].where(name == 'log_connections') {
            value == 'on'
          }
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled
    title: Ensure 'log_disconnections' Database Flag for Cloud SQL PostgreSQL Instances is enabled
    impact: 70
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-state
    docs:
      desc: |
        **Rationale:**

        PostgreSQL, by default, does not log the end of user sessions or their duration. Enabling the `log_disconnections` flag (setting it to `on`) causes the server to log this information. This data complements the information provided by `log_connections` and is crucial for auditing user activity, identifying long-running or unusual sessions, and troubleshooting connection-related issues. It provides a complete picture of the connection lifecycle. This recommendation applies specifically to Cloud SQL for PostgreSQL instances.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
        2.  Select a PostgreSQL instance to view its details.
        3.  In the **Configuration** section, find the **Database flags** area.
        4.  Verify that the `log_disconnections` flag is listed and its value is set to `on`.

        **Using the Google Cloud CLI**

        1.  List your Cloud SQL instances:
            ```bash
            gcloud sql instances list
            ```
        2.  For each PostgreSQL instance, check the flag's value:
            ```bash
            gcloud sql instances describe INSTANCE_NAME --format=json | jq '.settings.databaseFlags[] | select(.name=="log_disconnections")|.value'
            ```
            Ensure the output for each PostgreSQL instance is `"on"`.

        **Using cnquery**

        1. Ensure the `gcloud` CLI is configured for your project:
           ```bash
           gcloud config set project <project_id>
           ```
        2. Run the query:
           ```mql
           cnquery run gcp project <project-id> -c "gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(settings.databaseFlags['log_disconnections'] == 'on')"
           ```
           Verify the flag value is `on` for all relevant instances.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Go to the Cloud SQL Instances page: [https://console.cloud.google.com/sql/instances](https://console.cloud.google.com/sql/instances).
            2.  Select the target PostgreSQL instance.
            3.  Click **Edit**.
            4.  Scroll down to the **Flags** section.
            5.  If the flag isn't present, click **Add item**.
            6.  Choose `log_disconnections` from the dropdown and set its value to `on`. If the flag exists but is `off`, change its value to `on`.
            7.  Click **Save**. Review the **Flags** section on the instance overview page to confirm.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            Update the flag for a specific PostgreSQL instance:
            ```bash
            gcloud sql instances patch INSTANCE_NAME --database-flags log_disconnections=on
            ```
            *Note: This command overwrites all existing flags. To preserve other flags, you must include them in the `--database-flags` argument (e.g., `--database-flags log_disconnections=on,other_flag=value`).*
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `database_flags` block within your `google_sql_database_instance` resource includes the setting:
            ```hcl
            resource "google_sql_database_instance" "postgres_instance" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"
              settings {
                tier = "db-f1-micro"
                database_flags {
                  name  = "log_disconnections"
                  value = "on"
                }
                # Include other settings and flags as needed, e.g., log_connections
                database_flags {
                  name  = "log_connections"
                  value = "on"
                }
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(databaseInstalledVersion == /^POSTGRES_/).all(
        settings.databaseFlags['log_disconnections'] == 'on'
      )
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'database_flags').where(attributes['name'].value == 'log_disconnections') {
            arguments['value'] == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')) {
        change.after['settings'] {
          _['database_flags'].where(name == 'log_disconnections') {
            value == 'on'
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-log-disconnections-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')) {
        values['settings'] {
          _['database_flags'].where(name == 'log_disconnections') {
            value == 'on'
          }
        }
      }



  - uid: mondoo-gcp-security-compute-instances-no-public-ip
    title: Ensure public IP addresses are not assigned to VM instances
    impact: 75
    variants:
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-single
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-state
    docs:
      desc: |
        Virtual machine (VM) instances within Google Cloud Compute Engine should not be configured with public, external IP addresses.

        **Rationale:**

        Assigning public IP addresses directly to VM instances increases their exposure to potential attacks from the internet. To minimize this attack surface, instances should ideally be placed behind services like Google Cloud Load Balancing, which manage external access securely and efficiently, reducing direct exposure of the VM.

        **Impact:**

        Disabling the external IP address on a Compute instance might disrupt applications or services hosted on that instance if they rely on direct public internet connectivity. Careful planning is required before making this change.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Review the list of VM instances. For each instance, verify that the `External IP` column shows `None`.

        **From Google Cloud CLI**

        Execute the following command to list instances and their network configurations:
        ```
        gcloud compute instances list --format=json
        ```

        1. Examine the JSON output for each instance. Ensure that the `networkInterfaces` array does not contain an `accessConfigs` section. The presence of `accessConfigs` indicates an external IP configuration. Note that the `natIP` field within `accessConfigs` might only appear for running instances or stopped instances with a static external IP. Stopped instances configured for ephemeral IPs might not show `natIP`.

        Example indicating an external IP:
        ```json
        "networkInterfaces": [
         {
          "accessConfigs": [
           {
            "kind": "compute#accessConfig",
            "name": "External NAT",
            "networkTier": "PREMIUM",
            "type": "ONE_TO_ONE_NAT"
           }
          ],
          ...
         }
        ]
        ```

        **Exception:**
        Instances managed by Google Kubernetes Engine (GKE) often require external IPs for node pools or specific services. These instances typically have names starting with `gke-` and possess the label `goog-gke-node`. They should be excluded from this check as their network configuration is managed by GKE.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_compute_instance" "example" {
              name         = "example-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              // Configure the network interface without an access_config block
              // This ensures no external IP is assigned
              network_interface {
                network = "default"
                // No access_config block means no external IP
              }
            }
            ```
        - id: console
          desc: |
            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click the name of the target instance to open its details page.
            3. Click the `Edit` button at the top.
            4. Scroll down to the `Network interfaces` section.
            5. For the relevant network interface, click the pencil icon to edit it.
            6. Set the `External IP` dropdown menu to `None`.
            7. Click `Done` to close the network interface settings.
            8. Click `Save` at the bottom of the page to apply the changes.

            **Prevention:**
            Utilize the Organization Policy `constraints/compute.vmExternalIpAccess` to restrict or deny the assignment of external IP addresses to VMs across your organization or specific folders/projects. Configure this policy at: [https://console.cloud.google.com/orgpolicies/compute-vmExternalIpAccess](https://console.cloud.google.com/orgpolicies/compute-vmExternalIpAccess)
        - id: cli
          desc: |
            **From Google Cloud CLI**

            1. First, identify the name of the access configuration associated with the external IP. Describe the instance:
            ```bash
            gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(networkInterfaces[].accessConfigs)'
            ```
            Look for the `name` field within the `accessConfigs` array (e.g., `External NAT`).

            2. Delete the identified access configuration using its name:
            ```bash
            gcloud compute instances delete-access-config INSTANCE_NAME --zone=ZONE --access-config-name="ACCESS_CONFIG_NAME"
            ```
            Replace `INSTANCE_NAME`, `ZONE`, and `ACCESS_CONFIG_NAME` with the appropriate values.
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
      gcp.compute.instance.machineType.name == /n2d-/
    mql: |
      gcp.compute.instance.networkInterfaces { accessConfigs == [] }
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-hcl
    filters: |
      asset.platform == "terraform-hcl" && terraform.resources.where(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance') {
        blocks.where(type == 'network_interface') {
          blocks.where(type == 'access_config') == empty
        }
      }
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-plan
    filters: |
      asset.platform == "terraform-plan" && terraform.plan.resourceChanges.where(type == "google_compute_instance")
    mql: |
      terraform.plan.resourceChanges.where(type == "google_compute_instance") {
        change.after['network_interface'] {
          _['access_config'] == empty
        }
      }
  - uid: mondoo-gcp-security-compute-instances-no-public-ip-terraform-state
    filters: |
      asset.platform == "terraform-state" && terraform.state.resources.where(type == "google_compute_instance")
    mql: |
      terraform.state.resources.where(type == "google_compute_instance") {
        values['network_interface'] {
          _['access_config'] == empty
        }
      }



  - uid: mondoo-gcp-security-compute-instances-no-default-service-account
    title: Ensure the default service account is not used on VM instances
    impact: 80
    variants:
      - uid: mondoo-gcp-security-compute-instances-no-default-service-account-single
      - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-state
    docs:
      desc: |
        VM instances should be configured to use dedicated service accounts instead of the default Compute Engine service account.

        **Rationale:**

        The default Compute Engine service account (`[PROJECT_NUMBER]-compute@developer.gserviceaccount.com`) is automatically granted the highly permissive `Editor` role at the project level. If a VM using this default account is compromised, an attacker could potentially gain broad access to modify resources across the project. To adhere to the principle of least privilege and limit the potential impact of a compromised instance, create and assign custom service accounts with only the necessary permissions required by the VM.

        **Impact:**

        Changing the service account associated with a VM requires stopping and starting the instance. Ensure applications running on the VM can tolerate this brief downtime. Using a custom service account with insufficient permissions might cause applications on the VM to fail if they rely on APIs they can no longer access.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Click on the name of an instance to view its details.
        3. Locate the `API and identity management` section.
        4. Verify that the `Service account` listed is **not** the default Compute Engine service account (which follows the pattern `[PROJECT_NUMBER]-compute@developer.gserviceaccount.com`). Repeat for all relevant instances.

        **From Google Cloud CLI**

        1. List instances along with their associated service account emails:
        ```
        gcloud compute instances list --format='value(name,serviceAccounts[0].email)'
        ```
        Alternatively, for more detailed JSON output:
        ```
        gcloud compute instances list --format=json
        ```
        Then inspect the `serviceAccounts` array for each instance.

        2. For each instance, ensure the listed service account email does not match the default pattern `[PROJECT_NUMBER]-compute@developer.gserviceaccount.com`. You can find your project number using `gcloud projects describe $(gcloud config get-value project) --format='value(projectNumber)'`.

        **Exception:**
        VMs managed by GKE (names starting with `gke-`, labeled `goog-gke-node`) often use specific service accounts managed by GKE itself, which might include the default service account in some configurations. These should typically be excluded from this check unless specific organizational policies dictate otherwise.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            # Create a custom service account with appropriate permissions
            resource "google_service_account" "custom_sa" {
              account_id   = "custom-service-account"
              display_name = "Custom Service Account"
            }

            # Grant necessary roles to the service account
            resource "google_project_iam_member" "service_account_roles" {
              project = "your-project-id"
              role    = "roles/compute.instanceAdmin.v1"
              member  = "serviceAccount:${google_service_account.custom_sa.email}"
              # Add additional role bindings as needed
            }

            # Configure the VM instance to use the custom service account
            resource "google_compute_instance" "example" {
              name         = "example-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              network_interface {
                network = "default"
              }

              # Assign the custom service account to the instance
              service_account {
                email  = google_service_account.custom_sa.email
                scopes = [
                  "https://www.googleapis.com/auth/compute"
                  # Alternatively, you can use more restrictive scopes:
                  # "https://www.googleapis.com/auth/devstorage.read_only",
                  # etc.
                ]
              }
            }
        - id: console
          desc: |
            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click the name of the instance you want to modify.
            3. Click the `STOP` button at the top and confirm. Wait for the instance to stop completely.
            4. Once stopped, click the `EDIT` button.
            5. Scroll down to the `API and identity management` section.
            6. In the `Service account` dropdown, select a suitable custom service account. If needed, create a new service account with appropriate permissions first via the `IAM & Admin` -> `Service Accounts` page.
            7. Click `Save` at the bottom.
            8. Click the `START / RESUME` button at the top to restart the instance.
        - id: cli
          desc: |
            **From Google Cloud CLI**

            1. Stop the target instance:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Assign the desired custom service account:
            ```bash
            gcloud compute instances set-service-account INSTANCE_NAME --zone=ZONE --service-account=CUSTOM_SERVICE_ACCOUNT_EMAIL
            ```
            Replace `INSTANCE_NAME`, `ZONE`, and `CUSTOM_SERVICE_ACCOUNT_EMAIL` with the correct values.
            3. Start the instance again:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
      compute_engine_default_service_account_email = gcp.project.number + '-compute@developer.gserviceaccount.com'
      gcp.compute.instance {
        serviceAccounts.none(
          email == compute_engine_default_service_account_email
        )
      }
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-plan
    filters: |
      asset.platform == "terraform-plan" && terraform.plan.resourceChanges.where(type == "google_compute_instance")
    mql: |
      terraform.plan.resourceChanges.where(type == "google_compute_instance") {
        change.after['service_account'] {
          email == /$-compute@developer.gserviceaccount.com/
        }
      }
  - uid: mondoo-gcp-security-compute-instances-no-default-service-account-terraform-state
    filters: |
      asset.platform == "terraform-state" && terraform.state.resources.where(type == "google_compute_instance")
    mql: |
      terraform.state.resources.where(type == "google_compute_instance") {
        values['service_account'] {
          _['email'] == /$-compute@developer.gserviceaccount.com/
        }
      }



  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys
    title: Ensure “Block Project-Wide SSH Keys” Is Enabled for VM Instances
    impact: 80
    variants:
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-single
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-state
    docs:
      desc: |
        Configure VM instances to block project-wide SSH keys, favoring instance-specific keys for access.

        **Rationale:**

        Project-wide SSH keys, managed in the project's metadata, allow users associated with those keys to access *all* VM instances within that project by default. While convenient, this creates a significant security risk: if a project-wide key is compromised, all instances become vulnerable. Enabling the "Block Project-Wide SSH Keys" setting on an instance forces the use of instance-level SSH keys (stored in instance metadata), thereby limiting the scope of access and reducing the blast radius if a key is compromised.

        **Impact:**

        Enabling this setting will prevent users from connecting to the instance using project-wide SSH keys via tools like standard SSH clients. Access using the `gcloud compute ssh` command or the SSH-in-browser feature usually remains unaffected, as these tools often manage temporary or instance-specific keys. Users needing direct SSH access with third-party clients will require instance-specific SSH keys to be added to the VM's metadata.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Click on the name of the instance you want to check.
        3. Scroll down to the `SSH Keys` section.
        4. Verify that the checkbox labeled `Block project-wide SSH keys` is checked. Repeat for all relevant instances.

        **From Google Cloud CLI**

        1. Retrieve the metadata for the instance, specifically looking for the `block-project-ssh-keys` key:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(metadata.items)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Examine the output. Ensure there is an item where `key` is `block-project-ssh-keys` and its corresponding `value` is `true`. If the key is missing or set to `false`, project-wide keys are not blocked.

        Alternatively, list all instances and filter for the metadata key:
        ```
        gcloud compute instances list --format='table(name,zone,metadata.items.filter(key:block-project-ssh-keys).extract(value))'
        ```
        Instances showing `True` in the last column have the setting enabled.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_compute_instance" "example" {
              name         = "example-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              network_interface {
                network = "default"
              }

              # Block project-wide SSH keys
              metadata = {
                block-project-ssh-keys = "true"
              }

              # Other configuration parameters...
            }
            ```
        - id: console
          desc: |
            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click the name of the instance to modify.
            3. Click the `Edit` button at the top.
            4. Scroll down to the `SSH Keys` section (it might be under `Security and access` or a similar heading).
            5. Check the box for `Block project-wide SSH keys`.
            6. Click `Save` at the bottom of the page.
            7. Repeat these steps for all instances where project-wide keys should be blocked.
        - id: cli
          desc: |
            **From Google Cloud CLI**

            Enable the setting by adding or updating the instance metadata:
            ```bash
            gcloud compute instances add-metadata INSTANCE_NAME --zone=ZONE --metadata block-project-ssh-keys=true
            ```
            Replace `INSTANCE_NAME` and `ZONE` with the appropriate values. This command will either add the key if it doesn't exist or update its value to `true` if it does.
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
    mql: |
      gcp.compute.instance {
        metadata['block-project-ssh-keys'] == true
      }
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance' && attributes['metadata'] != null)
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance' && attributes['metadata'] != null) {
        attributes['metadata'].value['block-project-ssh-keys'] == true
      }
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == "google_compute_instance")
    mql: |
      terraform.plan.resourceChanges.where(type == "google_compute_instance") {
        change.after['metadata']['block-project-ssh-keys'] == true
      }
  - uid: mondoo-gcp-security-compute-instances-block-project-wide-ssh-keys-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == "google_compute_instance")
    mql: |
      terraform.state.resources.where(type == "google_compute_instance") {
        values['metadata'] {
          _['block-project-ssh-keys'] == true
        }
      }



  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled
    title: Ensure Confidential VM Service is enabled for all VM instances
    impact: 75
    variants:
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-single
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-state
    docs:
      desc: |
        Enable the Confidential VM service for applicable Compute Engine VM instances to enhance data security during processing.

        **Rationale:**

        While Google Cloud encrypts data at rest and in transit, Confidential Computing adds a layer of protection by encrypting data while it's actively being processed in memory (data-in-use). Confidential VMs utilize hardware-based security features (like AMD) to create an isolated environment where data remains encrypted even during computation. This helps protect sensitive data from potential access by the cloud provider or vulnerabilities in the host system, using hardware-generated, instance-specific keys that are not exportable.

        **Impact:**

        - Confidential VMs currently support specific machine types (primarily N2D series) and may have limitations, such as the lack of support for live migration, meaning instances will be terminated during host maintenance events.
        - Enabling this feature might incur additional costs compared to standard VMs. Refer to the official GCP pricing documentation for details: [https://cloud.google.com/compute/confidential-vm/pricing](https://cloud.google.com/compute/confidential-vm/pricing).
      audit: |
        Note: Confidential Computing is primarily available on N2D machine types. Check current documentation for supported types: [https://cloud.google.com/compute/docs/machine-types#n2d_machine_types](https://cloud.google.com/compute/docs/machine-types#n2d_machine_types)

        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Click on the name of an N2D instance (or other supported type) to view its details.
        3. Look for the `Confidential VM service` status indicator within the instance properties.
        4. Ensure the status shows as `Enabled` or `On`.

        **From Google Cloud CLI**

        1. List instances and check their confidential computing configuration:
        ```
        gcloud compute instances list --format='json(name,machineType,confidentialInstanceConfig)'
        ```
        2. For instances using a supported machine type (e.g., containing "n2d-"), verify that the `confidentialInstanceConfig` section exists and the `enableConfidentialCompute` field is set to `true`.

        Example output for a configured instance:
        ```json
        {
         "confidentialInstanceConfig": {
          "enableConfidentialCompute": true
         },
         "machineType": "...",
         "name": "..."
        }
        ```
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_compute_instance" "confidential_vm" {
              name         = "confidential-vm-instance"
              machine_type = "n2d-standard-2"  # Must use an N2D series or other supported machine type
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  image = "debian-cloud/debian-11"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable Confidential Computing
              confidential_instance_config {
                enable_confidential_compute = true
              }

              # Required setting for Confidential VMs
              scheduling {
                on_host_maintenance = "TERMINATE"
              }

              # Other configuration parameters as needed...
            }
            ```
        - id: console
          desc: |
            The Confidential VM service can only be activated when creating a new VM instance. It cannot be enabled on an existing instance.

            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click `CREATE INSTANCE`.
            3. Configure the instance settings (name, region, zone).
            4. Select a supported machine type from the N2D series (or other applicable types) under `Machine configuration`.
            5. Scroll down to the `Confidential VM service` section.
            6. Check the box labeled `Enable the Confidential Computing service on this VM instance`. Note that this usually requires setting the `On host maintenance` policy to `Terminate VM instance`.
            7. Configure other settings as needed (boot disk, networking, etc.).
            8. Click `Create`.
        - id: cli
          desc: |
            The Confidential VM service can only be activated when creating a new VM instance. It cannot be enabled on an existing instance.

            **From Google Cloud CLI**

            Use the `--confidential-compute` flag during instance creation. You must also set the maintenance policy to `TERMINATE`.
            ```bash
            gcloud compute instances create INSTANCE_NAME \
             --zone=ZONE \
             --machine-type=N2D_MACHINE_TYPE \
             --confidential-compute \
             --maintenance-policy=TERMINATE \
             # Add other necessary flags like --image-project, --image, --network, etc.
            ```
            Replace placeholders like `INSTANCE_NAME`, `ZONE`, and `N2D_MACHINE_TYPE` with appropriate values.
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
      gcp.compute.instance.name != /^gke-/
      gcp.compute.instance.machineType.name == /n2d-/
    mql: |
      gcp.compute.instance {
        confidentialInstanceConfig['serviceEnabled'] == true
      }
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance') {
        blocks.where(type == 'confidential_instance_config') {
          attributes['enable_confidential_compute'].value == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance') {
        change.after['boot_disk'] {
          _['initialize_params'].all(
            _['enable_confidential_compute'] == true
          )
        }
      }
  - uid: mondoo-gcp-security-compute-instances-confidential-vm-service-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == "google_compute_instance") {
        values['confidential_instance_config'] {
          _['enable_confidential_compute'] == true
        }
      }



  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled
    title: Ensure Secure Boot is enabled for all VM instances
    impact: 90
    variants:
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-single
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-state
    docs:
      desc: |
        Enable Secure Boot, a feature of Shielded VMs, on Compute Engine instances to enhance platform security and integrity.

        **Rationale:**

        Shielded VMs provide verifiable integrity for Compute Engine instances, offering protection against boot-level and kernel-level malware and rootkits. Secure Boot is a critical component of this protection. It ensures that the instance boots only with software (like the bootloader and OS kernel) that is digitally signed and trusted. By verifying these signatures against trusted certificates stored in the UEFI firmware, Secure Boot prevents malicious software from taking control during the boot process. Google manages the signing and verification of the firmware itself, establishing a strong root of trust.

        **Impact:**

        Secure Boot requires using a Shielded VM-compatible OS image. Enabling Secure Boot might prevent systems with custom, unsigned kernel drivers or boot components from booting successfully. Ensure all necessary components are properly signed before enabling this feature.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Click on the name of the instance you want to check.
        3. In the `VM instance details` page, locate the `Shielded VM` section.
        4. Verify that the `Secure Boot` toggle or status indicator shows `Enabled` or `On`.

        **From Google Cloud CLI**

        1. Describe the instance and check its Shielded VM configuration:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(shieldedInstanceConfig)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Examine the output. Ensure the `shieldedInstanceConfig` object exists and the `enableSecureBoot` field is set to `true`. If `shieldedInstanceConfig` is absent or `enableSecureBoot` is `false`, the feature is not enabled.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_compute_instance" "shielded_vm" {
              name         = "shielded-vm-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  # Use a compatible Shielded VM image
                  image = "gce-uefi-images/ubuntu-2004-focal-v20220419"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable Shielded VM features including Secure Boot
              shielded_instance_config {
                enable_secure_boot          = true
                enable_vtpm                 = true        # Required for Secure Boot
                enable_integrity_monitoring = true        # Recommended with Secure Boot
              }

              # Other configuration parameters as needed...
            }

            # Optional: Enforce Shielded VM at organization level using organization policy
            resource "google_organization_policy" "require_shielded_vm" {
              org_id     = "YOUR_ORGANIZATION_ID"          # Replace with your organization ID
              constraint = "constraints/compute.requireShieldedVm"

              boolean_policy {
                enforced = true
              }
            }
            ```
        - id: console
          desc: |
            Secure Boot can only be enabled on instances using an OS image that supports Shielded VM features.

            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click the name of the instance to modify.
            3. If the instance is running, click `STOP` and confirm. Wait for it to stop.
            4. Click `EDIT`.
            5. Scroll to the `Shielded VM` section.
            6. Check the box or toggle the switch to enable `Secure Boot`. Enabling Secure Boot typically requires vTPM and Integrity Monitoring to also be enabled or automatically enabled alongside it.
            7. Click `Save`.
            8. Click `START / RESUME` to restart the instance.

            **Prevention:**
            Enforce the use of Shielded VMs for all new instances by configuring the `constraints/compute.requireShieldedVm` Organization Policy. Manage this policy at: [https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm](https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm). See documentation for details: [https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint](https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint).
        - id: cli
          desc: |
            Secure Boot can only be enabled on instances using an OS image that supports Shielded VM features.

            **From Google Cloud CLI**

            Ensure the instance uses a compatible image. You can list public Shielded VM images:
            ```bash
            gcloud compute images list --project gce-UEFI-images --no-standard-images --filter="shieldedVmFeatures:(SECURE_BOOT)"
            ```

            1. Stop the instance if it is running:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Update the instance to enable Secure Boot (this command implicitly enables vTPM and Integrity Monitoring as well):
            ```bash
            gcloud compute instances update INSTANCE_NAME --zone=ZONE --shielded-vm-secure-boot
            ```
            3. Start the instance:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance {
        enableSecureBoot == true
      }
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance') {
        blocks.where(type == 'shielded_instance_config') {
          attributes['enable_secure_boot'].value == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance') {
        change.after['shielded_instance_config'] {
          _['enable_secure_boot'] == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-secure-boot-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance') {
        values['shielded_instance_config'] {
          _['enable_secure_boot'] == true
        }
      }



  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled
    title: Ensure vTPM is enabled for all VM instances
    impact: 90
    variants:
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-single
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-state
    docs:
      desc: |
        Enable the virtual Trusted Platform Module (vTPM), a feature of Shielded VMs, on Compute Engine instances to support Measured Boot and enhance integrity verification.

        **Rationale:**

        Shielded VMs leverage several security controls to harden instances against threats. The vTPM is a virtualized version of a hardware TPM, providing secure cryptographic functions and secure storage. Its primary role within Shielded VM is to enable Measured Boot. During Measured Boot, the vTPM securely records cryptographic measurements (hashes) of boot components (firmware, bootloader, kernel). This creates a verifiable record of the boot process, forming an integrity policy baseline essential for Integrity Monitoring.

        **Impact:**

        Enabling vTPM is necessary for using Shielded VM's Measured Boot and Integrity Monitoring capabilities. It generally has negligible impact on instance performance and compatibility, but it requires using a Shielded VM-compatible OS image.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Click on the name of the instance you want to check.
        3. In the `VM instance details` page, find the `Shielded VM` section.
        4. Verify that the `vTPM` toggle or status indicator shows `Enabled` or `On`.

        **From Google Cloud CLI**

        1. Describe the instance and check its Shielded VM configuration:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(shieldedInstanceConfig)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Look at the output. Ensure the `shieldedInstanceConfig` object is present and the `enableVtpm` field is set to `true`. If `shieldedInstanceConfig` is missing or `enableVtpm` is `false`, the feature is disabled.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_compute_instance" "vtpm_enabled_vm" {
              name         = "vtpm-enabled-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  # Use a compatible Shielded VM image that supports vTPM
                  image = "gce-uefi-images/ubuntu-2004-focal-v20220419"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable vTPM as part of Shielded VM features
              shielded_instance_config {
                enable_vtpm                 = true
                enable_integrity_monitoring = true  # Optional but recommended
                enable_secure_boot          = false # Optional, set to true if needed
              }

              # Other configuration parameters as needed...
            }

            # Optional: Enforce Shielded VM at organization level using organization policy
            resource "google_organization_policy" "require_shielded_vm" {
              org_id     = "YOUR_ORGANIZATION_ID"  # Replace with your organization ID
              constraint = "constraints/compute.requireShieldedVm"

              boolean_policy {
                enforced = true
              }
            }
            ```
        - id: console
          desc: |
            vTPM can only be enabled on instances using an OS image that supports Shielded VM features.

            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click the name of the instance to modify.
            3. If the instance is running, click `STOP` and confirm. Wait for it to stop completely.
            4. Click `EDIT`.
            5. Scroll down to the `Shielded VM` section.
            6. Check the box or toggle the switch to enable `vTPM`.
            7. Click `Save`.
            8. Click `START / RESUME` to restart the instance.

            **Prevention:**
            Mandate the use of Shielded VMs (which includes vTPM) for new instances via the `constraints/compute.requireShieldedVm` Organization Policy. Configure it at: [https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm](https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm). Refer to documentation: [https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint](https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint).
        - id: cli
          desc: |
            vTPM can only be enabled on instances using an OS image that supports Shielded VM features.

            **From Google Cloud CLI**

            Ensure the instance uses a compatible image. You can list public Shielded VM images:
            ```bash
            gcloud compute images list --project gce-uefi-images --no-standard-images --filter="shieldedVmFeatures:(VTPM)"
            ```

            1. Stop the instance if it is running:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Update the instance to enable vTPM:
            ```bash
            gcloud compute instances update INSTANCE_NAME --zone=ZONE --shielded-vtpm
            ```
            Note: This command specifically targets vTPM. If Secure Boot or Integrity Monitoring are desired, they might need separate flags (`--shielded-vm-secure-boot`, `--shielded-vm-integrity-monitoring`) or enabling them might implicitly enable vTPM.
            3. Start the instance:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance {
        enableVtpm == true
      }
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance') {
        blocks.where(type == 'shielded_instance_config') {
          attributes['enable_vtpm'].value == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance') {
        change.after['shielded_instance_config'] {
          _['enable_vtpm'] == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-vtpm-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance') {
        values['shielded_instance_config'] {
          _['enable_vtpm'] == true
        }
      }



  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled
    title: Ensure Integrity Monitoring is enabled for all VM instances
    impact: 90
    variants:
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-single
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-hcl
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-plan
      - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-state
    docs:
      desc: |
        Enable Integrity Monitoring, a feature of Shielded VMs, on Compute Engine instances to detect potentially malicious modifications to the boot sequence.

        **Rationale:**

        Shielded VMs provide enhanced security for instances. Integrity Monitoring, a key component, leverages the measurements taken by the vTPM during Measured Boot. It compares the boot measurements of the current boot process against a known good baseline established during a previous boot. If discrepancies are detected, it indicates that the bootloader, kernel, or other critical boot components may have been tampered with, potentially by rootkits or boot-level malware. This allows administrators to identify compromised instances and take appropriate action.

        **Impact:**

        Integrity Monitoring requires both a Shielded VM-compatible OS image and vTPM to be enabled. It provides valuable security insights by logging integrity check results to Cloud Logging, with minimal overhead on instance performance.
      audit: |
        **From Google Cloud Console**

        1. Navigate to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
        2. Click on the name of the instance you want to check.
        3. In the `VM instance details` page, locate the `Shielded VM` section.
        4. Verify that the `Integrity Monitoring` toggle or status indicator shows `Enabled` or `On`.

        **From Google Cloud CLI**

        1. Describe the instance and check its Shielded VM configuration:
        ```
        gcloud compute instances describe INSTANCE_NAME --zone=ZONE --format='json(shieldedInstanceConfig)'
        ```
        Replace `INSTANCE_NAME` and `ZONE` accordingly.

        2. Examine the output. Ensure the `shieldedInstanceConfig` object exists and the `enableIntegrityMonitoring` field is set to `true`. If `shieldedInstanceConfig` is absent or `enableIntegrityMonitoring` is `false`, the feature is not enabled.
      remediation:
        - id: terraform
          desc: |
            **Terraform**

            ```hcl
            resource "google_compute_instance" "integrity_monitoring_vm" {
              name         = "integrity-monitoring-instance"
              machine_type = "e2-medium"
              zone         = "us-central1-a"

              boot_disk {
                initialize_params {
                  # Use a compatible Shielded VM image that supports Integrity Monitoring
                  image = "gce-uefi-images/ubuntu-2004-focal-v20220419"
                }
              }

              network_interface {
                network = "default"
              }

              # Enable Integrity Monitoring and vTPM (required) as part of Shielded VM features
              shielded_instance_config {
                enable_integrity_monitoring = true
                enable_vtpm                 = true  # Required for Integrity Monitoring
                enable_secure_boot          = false # Optional, set to true if needed
              }

              # Other configuration parameters as needed...
            }

            # Optional: Enforce Shielded VM at organization level using organization policy
            resource "google_organization_policy" "require_shielded_vm" {
              org_id     = "YOUR_ORGANIZATION_ID"  # Replace with your organization ID
              constraint = "constraints/compute.requireShieldedVm"

              boolean_policy {
                enforced = true
              }
            }
            ```
        - id: console
          desc: |
            Integrity Monitoring requires an instance using an OS image that supports Shielded VM features, and vTPM must also be enabled.

            **From Google Cloud Console**

            1. Go to the `VM instances` page: [https://console.cloud.google.com/compute/instances](https://console.cloud.google.com/compute/instances).
            2. Click the name of the instance to modify.
            3. If the instance is running, click `STOP` and confirm. Wait for it to stop completely.
            4. Click `EDIT`.
            5. Scroll down to the `Shielded VM` section.
            6. Ensure `vTPM` is enabled.
            7. Check the box or toggle the switch to enable `Integrity Monitoring`.
            8. Click `Save`.
            9. Click `START / RESUME` to restart the instance.

            **Prevention:**
            Enforce the use of Shielded VMs (which includes Integrity Monitoring when enabled) for new instances using the `constraints/compute.requireShieldedVm` Organization Policy. Configure this at: [https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm](https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm). See documentation: [https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint](https://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint).
        - id: cli
          desc: |
            Integrity Monitoring requires an instance using an OS image that supports Shielded VM features, and vTPM must also be enabled.

            **From Google Cloud CLI**

            Ensure the instance uses a compatible image and has vTPM enabled. You can list public Shielded VM images:
            ```bash
            gcloud compute images list --project gce-uefi-images --no-standard-images --filter="shieldedVmFeatures:(INTEGRITY_MONITORING)"
            ```

            1. Stop the instance if it is running:
            ```bash
            gcloud compute instances stop INSTANCE_NAME --zone=ZONE
            ```
            2. Update the instance to enable Integrity Monitoring (this command implicitly enables vTPM as well):
            ```bash
            gcloud compute instances update INSTANCE_NAME --zone=ZONE --shielded-vm-integrity-monitoring
            ```
            3. Start the instance:
            ```bash
            gcloud compute instances start INSTANCE_NAME --zone=ZONE
            ```
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-single
    filters: |
      asset.platform == 'gcp-compute-instance'
    mql: |
      gcp.compute.instance {
        enableIntegrityMonitoring == true
      }
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_compute_instance')
    mql: |
      terraform.resources.where(nameLabel == 'google_compute_instance') {
        blocks.where(type == 'shielded_instance_config') {
          attributes['enable_integrity_monitoring'].value == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_compute_instance')
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_compute_instance') {
        change.after['shielded_instance_config'] {
          _['enable_integrity_monitoring'] == true
        }
      }
  - uid: mondoo-gcp-security-compute-instances-integrity-monitoring-enabled-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_compute_instance')
    mql: |
      terraform.state.resources.where(type == 'google_compute_instance') {
        values['shielded_instance_config'] {
          _['enable_integrity_monitoring'] == true
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed
    title: Ensure Cloud SQL PostgreSQL instances are not publicly exposed
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-state
    docs:
      desc: |
        Assigning public IP addresses to Cloud SQL PostgreSQL instances expands the potential attack surface, making databases accessible from the public internet and increasing security risks.

        The recommended practice is to configure instances exclusively with private IP addresses. This enhances security by isolating the database within your VPC network and can reduce latency for internal applications. Be aware that removing a public IP will disrupt existing connections that depend on it; establish and test private connectivity paths before making the change. This applies to Second Generation instances.
      audit: |
        **Using the Google Cloud Console**

          1. Navigate to the Cloud SQL Instances page within the Google Cloud Console: https://console.cloud.google.com/sql/instances
          2. Review each PostgreSQL instance listed. For every primary (non-replica) Second Generation instance, examine its networking details to confirm that a Private IP address is assigned and that no Public IP address (type: PRIMARY) is present.

        ** Using the Google Cloud CLI **

          1. Obtain a list of all your Cloud SQL instances:

            ```bash
            gcloud sql instances list
            ```

          2. For each PostgreSQL instance identified as `backendType: SECOND_GEN` and `instanceType: CLOUD_SQL_INSTANCE` (primary instance), retrieve its full configuration details. Read replicas (`instanceType: READ_REPLICA_INSTANCE`) inherit network settings, and First Generation instances do not support private IPs, so they can be skipped for this check.

            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```

          3. Inspect the `ipAddresses` section in the output for the instance. Verify that an entry exists with `type: PRIVATE`. Crucially, ensure there is no entry with `type: PRIMARY`, as this indicates a public IP address. While an instance can technically possess both during transitions, the secure state is having only the `PRIVATE` type assigned.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page in the Google Cloud Console: https://console.cloud.google.com/sql/instances
            2.  Click on the name of the target PostgreSQL instance to view its configuration details.
            3.  Navigate to the **Connections** settings tab.
            4.  Under the **Networking** section, locate and uncheck the box labeled **Public IP**.
            5.  Confirm the modification by clicking the **Save** button.

            **Prevention:**

            To proactively enforce that new Cloud SQL instances are not created with public IP addresses, implement the `Restrict Public IP access on Cloud SQL instances` Organization Policy. You can configure this policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            1.  Modify the target instance to remove its public IP address and ensure it's associated with a VPC network for private IP access. Replace `INSTANCE_NAME` with the actual instance name and `VPC_NETWORK_NAME` with the desired VPC network name:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --network=VPC_NETWORK_NAME --no-assign-ip
                ```
                *Note: If the instance is already associated with the correct VPC network for private IP, you might only need the `--no-assign-ip` flag.*
            2.  Verify that the public IP address has been removed by inspecting the instance's configuration:
                ```bash
                gcloud sql instances describe INSTANCE_NAME
                ```
                Check the `ipAddresses` section in the output to confirm the absence of an entry with `type: PRIMARY`.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `ipv4_enabled` attribute within the `ip_configuration` block is set to `false` or omitted (defaults to false if private network is configured):

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  # Ensure private network is configured
                  private_network = "projects/my-project/global/networks/my-vpc"
                  # Set ipv4_enabled to false or omit it
                  ipv4_enabled    = false
                }
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(maintenanceVersion.contains('POSTGRES')) {
        ipAddresses.all(
          _.type != "PRIMARY"
        )
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'ip_configuration') {
            attributes['ipv4_enabled'] == null || attributes['ipv4_enabled'].value == false
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')) {
        change.after['settings'] {
          _['ip_configuration'] {
            _['ipv4_enabled'] == false
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-instances-not-publicly-exposed-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')) {
        values['settings'] {
          _['ip_configuration'] {
            _['ipv4_enabled'] == false
          }
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed
    title: Ensure Cloud SQL for SQL Server instances are not publicly exposed
    impact: 100
    variants:
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-all
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-state
    docs:
      desc: |
        Assigning public IP addresses to Cloud SQL for SQL Server instances expands the potential attack surface, making databases accessible from the public internet and increasing security risks.

        The recommended practice is to configure instances exclusively with private IP addresses. This enhances security by isolating the database within your VPC network and can reduce latency for internal applications. Be aware that removing a public IP will disrupt existing connections that depend on it; establish and test private connectivity paths before making the change. This applies to Second Generation instances.
      audit: |
        **Using the Google Cloud Console**

          1. Navigate to the Cloud SQL Instances page within the Google Cloud Console: https://console.cloud.google.com/sql/instances
          2. Review each SQL Server instance listed. For every primary (non-replica) Second Generation instance, examine its networking details to confirm that a Private IP address is assigned and that no Public IP address (type: PRIMARY) is present.

        ** Using the Google Cloud CLI **

          1. Obtain a list of all your Cloud SQL instances:

            ```bash
            gcloud sql instances list
            ```

          2. For each SQL Server instance identified as `backendType: SECOND_GEN` and `instanceType: CLOUD_SQL_INSTANCE` (primary instance), retrieve its full configuration details. Read replicas (`instanceType: READ_REPLICA_INSTANCE`) inherit network settings.

            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```

          3. Inspect the `ipAddresses` section in the output for the instance. Verify that an entry exists with `type: PRIVATE`. Crucially, ensure there is no entry with `type: PRIMARY`, as this indicates a public IP address. While an instance can technically possess both during transitions, the secure state is having only the `PRIVATE` type assigned.
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page in the Google Cloud Console: https://console.cloud.google.com/sql/instances
            2.  Click on the name of the target SQL Server instance to view its configuration details.
            3.  Navigate to the **Connections** settings tab.
            4.  Under the **Networking** section, locate and uncheck the box labeled **Public IP**.
            5.  Confirm the modification by clicking the **Save** button.

            **Prevention:**

            To proactively enforce that new Cloud SQL instances are not created with public IP addresses, implement the `Restrict Public IP access on Cloud SQL instances` Organization Policy. You can configure this policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            1.  Modify the target instance to remove its public IP address and ensure it's associated with a VPC network for private IP access. Replace `INSTANCE_NAME` with the actual instance name and `VPC_NETWORK_NAME` with the desired VPC network name:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --network=VPC_NETWORK_NAME --no-assign-ip
                ```
                *Note: If the instance is already associated with the correct VPC network for private IP, you might only need the `--no-assign-ip` flag.*
            2.  Verify that the public IP address has been removed by inspecting the instance's configuration:
                ```bash
                gcloud sql instances describe INSTANCE_NAME
                ```
                Check the `ipAddresses` section in the output to confirm the absence of an entry with `type: PRIMARY`.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `ipv4_enabled` attribute within the `ip_configuration` block is set to `false` or omitted (defaults to false if private network is configured):

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-sql-server-instance"
              database_version = "SQLSERVER_2019_STANDARD"
              region           = "us-central1"

              settings {
                tier = "db-custom-2-7680" # Example tier
                ip_configuration {
                  # Ensure private network is configured
                  private_network = "projects/my-project/global/networks/my-vpc"
                  # Set ipv4_enabled to false or omit it
                  ipv4_enabled    = false
                }
              }
            }
            ```
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(maintenanceVersion.contains('SQLSERVER')) {
        ipAddresses.all(
          _.type != "PRIMARY"
        )
      }
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'ip_configuration') {
            attributes['ipv4_enabled'] == null || attributes['ipv4_enabled'].value == false
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER')) {
        change.after['settings'] {
          _['ip_configuration'] {
            _['ipv4_enabled'] == false
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-sql-server-instances-not-publicly-exposed-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER')) {
        values['settings'] {
          _['ip_configuration'] {
            _['ipv4_enabled'] == false
          }
        }
      }



  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls
    title: Ensure Cloud SQL PostgreSQL connections require SSL/TLS
    impact: 90
    variants:
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-all
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-state
    docs:
      desc: |
        Requiring SSL/TLS for connections to Cloud SQL PostgreSQL instances encrypts data in transit between the client and the database server. This prevents potential eavesdropping and man-in-the-middle attacks, protecting sensitive data from unauthorized access during transmission.

        It is strongly recommended to configure Cloud SQL instances to enforce SSL/TLS for all incoming connections to maintain data confidentiality and integrity. Note that enabling this setting requires clients to be configured correctly to use SSL/TLS, which might necessitate application updates.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: https://console.cloud.google.com/sql/instances
        2.  Click on the name of the PostgreSQL instance you want to audit.
        3.  Select the **Connections** tab.
        4.  Go to the **Security** sub-tab.
        5.  Verify that the checkbox for **Allow only SSL connections** is checked.

        **Using the Google Cloud CLI**

        1.  Retrieve the configuration details for the instance:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```
        2.  Inspect the output and locate the `settings.ipConfiguration` section.
        3.  Ensure the value for `requireSsl` is set to `true`.

            Example relevant output snippet:
            ```yaml
            settings:
              ipConfiguration:
                requireSsl: true
                # ... other ipConfiguration settings
            ```
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page: https://console.cloud.google.com/sql/instances
            2.  Click the name of the target PostgreSQL instance.
            3.  Navigate to the **Connections** tab, then the **Security** sub-tab.
            4.  Check the box labeled **Allow only SSL connections**.
            5.  Click **Save** to apply the change. *Note: This may trigger an instance restart.*

            **Prevention:**

            Always configure new Cloud SQL PostgreSQL instances with the "Allow only SSL connections" option enabled during creation via the Console. Regularly audit instances to ensure compliance.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            1.  Enable the "Require SSL" setting for the instance:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --require-ssl
                ```
                *Note: This command may cause the instance to restart.*
            2.  Confirm the change:
                ```bash
                gcloud sql instances describe INSTANCE_NAME --format='value(settings.ipConfiguration.requireSsl)'
                ```
                The output should be `True`.

            **Prevention:**

            Always configure new Cloud SQL PostgreSQL instances with the `--require-ssl` flag during creation via the CLI. Regularly audit instances to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `require_ssl` attribute within the `ip_configuration` block is set to `true`:

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-postgres-instance"
              database_version = "POSTGRES_15"
              region           = "us-central1"

              settings {
                tier = "db-f1-micro"
                ip_configuration {
                  ipv4_enabled = true # Or false if using private IP only
                  # Set require_ssl to true
                  require_ssl  = true
                }
              }
            }
            ```

            **Prevention:**

            Always configure new Cloud SQL PostgreSQL instances with `require_ssl = true` during creation via Terraform. Regularly audit instances to ensure compliance.
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(maintenanceVersion.contains('POSTGRES')) {
        settings.ipConfiguration {
          requireSsl == true
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('POSTGRES')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'ip_configuration') {
            attributes['require_ssl'].value == true
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('POSTGRES')) {
        change.after['settings'] {
          _['ip_configuration'] {
            _['require_ssl'] == true
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-postgres-connections-require-ssl-tls-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('POSTGRES')) {
        values['settings'] { 
          _['ip_configuration'] {
            _['require_ssl'] == true 
          }
        }
      }


  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls
    title: Ensure Cloud SQL for SQL Server connections require SSL/TLS
    impact: 90
    variants:
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-all
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-hcl
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-plan
      - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-state
    docs:
      desc: |
        Requiring SSL/TLS for connections to Cloud SQL for SQL Server instances encrypts data in transit between the client and the database server. This prevents potential eavesdropping and man-in-the-middle attacks, protecting sensitive data from unauthorized access during transmission.

        It is strongly recommended to configure Cloud SQL instances to enforce SSL/TLS for all incoming connections to maintain data confidentiality and integrity. Note that enabling this setting requires clients to be configured correctly to use SSL/TLS, which might necessitate application updates.
      audit: |
        **Using the Google Cloud Console**

        1.  Navigate to the Cloud SQL Instances page: https://console.cloud.google.com/sql/instances
        2.  Click on the name of the SQL Server instance you want to audit.
        3.  Select the **Connections** tab.
        4.  Go to the **Security** sub-tab.
        5.  Verify that the checkbox for **Allow only SSL connections** is checked.

        **Using the Google Cloud CLI**

        1.  Retrieve the configuration details for the instance:
            ```bash
            gcloud sql instances describe INSTANCE_NAME
            ```
        2.  Inspect the output and locate the `settings.ipConfiguration` section.
        3.  Ensure the value for `requireSsl` is set to `true`.

            Example relevant output snippet:
            ```yaml
            settings:
              ipConfiguration:
                requireSsl: true
                # ... other ipConfiguration settings
            ```
      remediation:
        - id: console
          desc: |
            **Using the Google Cloud Console**

            1.  Access the Cloud SQL Instances overview page: https://console.cloud.google.com/sql/instances
            2.  Click the name of the target SQL Server instance.
            3.  Navigate to the **Connections** tab, then the **Security** sub-tab.
            4.  Check the box labeled **Allow only SSL connections**.
            5.  Click **Save** to apply the change. *Note: This may trigger an instance restart.*

            **Prevention:**

            Always configure new Cloud SQL for SQL Server instances with the "Allow only SSL connections" option enabled during creation via the Console. Regularly audit instances to ensure compliance.
        - id: cli
          desc: |
            **Using the Google Cloud CLI**

            1.  Enable the "Require SSL" setting for the instance:
                ```bash
                gcloud sql instances patch INSTANCE_NAME --require-ssl
                ```
                *Note: This command may cause the instance to restart.*
            2.  Confirm the change:
                ```bash
                gcloud sql instances describe INSTANCE_NAME --format='value(settings.ipConfiguration.requireSsl)'
                ```
                The output should be `True`.

            **Prevention:**

            Always configure new Cloud SQL for SQL Server instances with the `--require-ssl` flag during creation via the CLI. Regularly audit instances to ensure compliance.
        - id: terraform
          desc: |
            **Using Terraform**

            Ensure the `require_ssl` attribute within the `ip_configuration` block is set to `true`:

            ```hcl
            resource "google_sql_database_instance" "default" {
              name             = "my-sql-server-instance"
              database_version = "SQLSERVER_2019_STANDARD"
              region           = "us-central1"

              settings {
                tier = "db-custom-2-7680" # Example tier
                ip_configuration {
                  ipv4_enabled = true # Or false if using private IP only
                  # Set require_ssl to true
                  require_ssl  = true
                }
              }
            }
            ```

            **Prevention:**

            Always configure new Cloud SQL for SQL Server instances with `require_ssl = true` during creation via Terraform. Regularly audit instances to ensure compliance.
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-all
    filters: |
      asset.platform == 'gcp-project'
    mql: |
      gcp.project.sql.instances.where(maintenanceVersion.contains('SQLSERVER')) {
        settings.ipConfiguration {
          requireSsl == true
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-hcl
    filters: |
      asset.platform == 'terraform-hcl' && terraform.resources.contains(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER'))
    mql: |
      terraform.resources.where(nameLabel == 'google_sql_database_instance' && arguments['database_version'].contains('SQLSERVER')) {
        blocks.where(type == 'settings') {
          blocks.where(type == 'ip_configuration') {
            attributes['require_ssl'].value == true
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-plan
    filters: |
      asset.platform == 'terraform-plan' && terraform.plan.resourceChanges.contains(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER'))
    mql: |
      terraform.plan.resourceChanges.where(type == 'google_sql_database_instance' && change.after.database_version.contains('SQLSERVER')) {
        change.after['settings'] {
          _['ip_configuration'] {
            _['require_ssl'] == true
          }
        }
      }
  - uid: mondoo-gcp-security-cloud-sql-sql-server-connections-require-ssl-tls-terraform-state
    filters: |
      asset.platform == 'terraform-state' && terraform.state.resources.contains(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER'))
    mql: |
      terraform.state.resources.where(type == 'google_sql_database_instance' && values.database_version.contains('SQLSERVER')) {
        values['settings'] {
          _['ip_configuration'] {
            _['require_ssl'] == true
          }
        }
      }
