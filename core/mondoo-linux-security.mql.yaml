
# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1

policies:
  - uid: mondoo-linux-security
    name: Mondoo Linux Security
    version: 2.5.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: linux
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |-
        The Mondoo Linux Security policy provides guidance for establishing a secure baseline configuration for Linux systems running on x86 and x64 platforms.

        This policy includes queries to help harden Linux systems by:
          - Identifying problematic services that may be running
          - Identifying loose permissions on sensitive system configuration files
          - Ensuring logging and auditing services are properly configured and running
          - Hardening SSH configurations
          - Ensure users and groups are securely configured
          - Identifying misconfigured Kernel networking configurations

        This policy has been developed for Red Hat (RHEL), Debian, Ubuntu, and SUSE (SLES) derivative distributions running on x86 and x64 architectures.
        Some queries may be skipped depending on your particular distribution, installation type, or underlying infrastructure.
        The overall guidance within this policy broadly assumes that operations are being performed as the root user.
        Operations performed using sudo instead of the root user may produce unexpected results or fail to make the intended changes to the system.
        Non-root users may not be able to access certain areas of the system, especially after remediation has been performed. It is advisable to verify
        root users path integrity and the integrity of any programs being run prior to execution of commands and scripts included in this benchmark.

        ## Local scan

        Local scan refer to scans of files and operating systems where cnspec is installed.

        To scan the `localhost` against this policy:

        ```bash
        cnspec scan local
        ```

        ## Remote scan

        Remote scans use cnspec providers to retrieve on-demand scan results without having to install any agents.

        ### Prerequisites

        Remote scans of Linux hosts requires authentication such as SSH keys.

        ### Scan a remote Linux host (SSH authentication)

        ```bash
        cnspec scan ssh <user>@<IP_ADDRESS> -i /path/to/ssh_key
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Core
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-window-system-is-not-installed
          - uid: mondoo-linux-security-address-space-layout-randomization-aslr-is-enabled
          - uid: mondoo-linux-security-aide-is-installed
          - uid: mondoo-linux-security-bogus-icmp-responses-are-ignored
          - uid: mondoo-linux-security-broadcast-icmp-requests-are-ignored
          - uid: mondoo-linux-security-core-dumps-are-restricted
          - uid: mondoo-linux-security-filesystem-integrity-is-regularly-checked
          - uid: mondoo-linux-security-icmp-redirects-are-not-accepted
          - uid: mondoo-linux-security-ip-forwarding-is-disabled
          - uid: mondoo-linux-security-ipv6-router-advertisements-are-not-accepted
          - uid: mondoo-linux-security-mail-transfer-agent-is-configured-for-local-only-mode
          - uid: mondoo-linux-security-packet-redirect-sending-is-disabled
          - uid: mondoo-linux-security-prelink-is-disabled
          - uid: mondoo-linux-security-reverse-path-filtering-is-enabled
          - uid: mondoo-linux-security-secure-icmp-redirects-are-not-accepted
          - uid: mondoo-linux-security-source-routed-packets-are-not-accepted
          - uid: mondoo-linux-security-suspicious-packets-are-logged
          - uid: mondoo-linux-security-tcp-syn-cookies-is-enabled
      - title: Sensitive Files
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-permissions-on-etcgroup--are-configured
          - uid: mondoo-linux-security-permissions-on-etcgroup-are-configured
          - uid: mondoo-linux-security-permissions-on-etcgshadow--are-configured
          - uid: mondoo-linux-security-permissions-on-etcgshadow-are-configured
          - uid: mondoo-linux-security-permissions-on-etcpasswd--are-configured
          - uid: mondoo-linux-security-permissions-on-etcpasswd-are-configured
          - uid: mondoo-linux-security-permissions-on-etcshadow--are-configured
          - uid: mondoo-linux-security-permissions-on-etcshadow-are-configured
      - title: Sensitive Services
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-avahi-server-is-not-enabled
          - uid: mondoo-linux-security-dhcp-server-is-not-enabled
          - uid: mondoo-linux-security-dns-server-is-not-enabled
          - uid: mondoo-linux-security-ftp-server-is-not-enabled
          - uid: mondoo-linux-security-http-proxy-server-is-not-enabled
          - uid: mondoo-linux-security-http-server-is-not-enabled
          - uid: mondoo-linux-security-imap-and-pop3-server-is-not-enabled
          - uid: mondoo-linux-security-ldap-server-is-not-enabled
          - uid: mondoo-linux-security-nfs-and-rpc-are-not-enabled
          - uid: mondoo-linux-security-nis-server-is-not-enabled
          - uid: mondoo-linux-security-rsh-server-is-not-enabled
          - uid: mondoo-linux-security-rsync-service-is-not-enabled
          - uid: mondoo-linux-security-samba-is-not-enabled
          - uid: mondoo-linux-security-snmp-server-is-not-enabled
          - uid: mondoo-linux-security-talk-server-is-not-enabled
          - uid: mondoo-linux-security-telnet-server-is-not-enabled
          - uid: mondoo-linux-security-tftp-server-is-not-enabled
          - uid: mondoo-linux-security-cups-is-not-enabled
      - title: SSH Server Configuration
        filters: |
          asset.family.contains('linux')
          package('openssh-server').installed
        checks:
          - uid: mondoo-linux-security-only-strong-ciphers-are-used
          - uid: mondoo-linux-security-only-strong-kex-algorithms-are-used
          - uid: mondoo-linux-security-only-strong-mac-algorithms-are-used
          - uid: mondoo-linux-security-permissions-on-etcsshsshd-config-are-configured
          - uid: mondoo-linux-security-permissions-on-ssh-private-host-key-files-are-configured
          - uid: mondoo-linux-security-permissions-on-ssh-public-host-key-files-are-configured
          - uid: mondoo-linux-security-ssh-access-is-limited
          - uid: mondoo-linux-security-ssh-hostbasedauthentication-is-disabled
          - uid: mondoo-linux-security-ssh-idle-timeout-interval-is-configured
          - uid: mondoo-linux-security-ssh-ignorerhosts-is-enabled
          - uid: mondoo-linux-security-ssh-logingracetime-is-set-to-one-minute-or-less
          - uid: mondoo-linux-security-ssh-loglevel-is-appropriate
          - uid: mondoo-linux-security-ssh-maxauthtries-is-set-to-4-or-less
          - uid: mondoo-linux-security-ssh-permitemptypasswords-is-disabled
          - uid: mondoo-linux-security-ssh-permituserenvironment-is-disabled
          - uid: mondoo-linux-security-ssh-protocol-is-set-to-2
          - uid: mondoo-linux-security-ssh-root-login-is-disabled
          - uid: mondoo-linux-security-ssh-warning-banner-is-configured
          - uid: mondoo-linux-security-ssh-x11-forwarding-is-disabled
      - title: Logging
        filters: |
          asset.family.contains('linux')
          asset.kind != "container-image"
        checks:
          - uid: mondoo-linux-security-audit-log-storage-size-is-configured
          - uid: mondoo-linux-security-audit-logs-are-not-automatically-deleted
          - uid: mondoo-linux-security-auditd-is-installed-and-running
          - uid: mondoo-linux-security-auditing-for-processes-that-start-prior-to-auditd-is-enabled
          - uid: mondoo-linux-security-changes-to-system-administration-scope-sudoers-is-collected
          - uid: mondoo-linux-security-discretionary-access-control-permission-modification-events-are-collected
          - uid: mondoo-linux-security-events-that-modify-date-and-time-information-are-collected
          - uid: mondoo-linux-security-events-that-modify-the-systems-mandatory-access-controls-are-collected
          - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected
          - uid: mondoo-linux-security-events-that-modify-usergroup-information-are-collected
          - uid: mondoo-linux-security-file-deletion-events-by-users-are-collected
          - uid: mondoo-linux-security-journald-is-configured-to-compress-large-log-files
          - uid: mondoo-linux-security-journald-is-configured-to-send-logs-to-rsyslog
          - uid: mondoo-linux-security-journald-is-configured-to-write-logfiles-to-persistent-disk
          - uid: mondoo-linux-security-kernel-module-loading-and-unloading-is-collected
          - uid: mondoo-linux-security-login-and-logout-events-are-collected
          - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
          - uid: mondoo-linux-security-rsyslog-default-file-permissions-configured
          - uid: mondoo-linux-security-rsyslog-is-installed-and-enabled
          - uid: mondoo-linux-security-session-initiation-information-is-collected
          - uid: mondoo-linux-security-successful-file-system-mounts-are-collected
          - uid: mondoo-linux-security-sudo-logging-is-enabled
          - uid: mondoo-linux-security-system-administrator-actions-sudolog-are-collected
          - uid: mondoo-linux-security-system-is-disabled-when-audit-logs-are-full
          - uid: mondoo-linux-security-the-audit-configuration-is-immutable
          - uid: mondoo-linux-security-unsuccessful-unauthorized-file-access-attempts-are-collected
      - title: Users and groups
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-access-to-the-su-command-is-restricted
          - uid: mondoo-linux-security-default-group-for-the-root-account-is-gid-0
          - uid: mondoo-linux-security-each-user-member-of-a-group
          - uid: mondoo-linux-security-gid-in-passwd-exists-in-group
          - uid: mondoo-linux-security-no-duplicate-gids-exist
          - uid: mondoo-linux-security-no-duplicate-group-names-exist
          - uid: mondoo-linux-security-no-duplicate-uids-exist
          - uid: mondoo-linux-security-no-duplicate-user-names-exist
          - uid: mondoo-linux-security-root-group-is-empty
          - uid: mondoo-linux-security-shadow-group-is-empty
          - uid: mondoo-linux-security-system-accounts-are-non-login
          - uid: mondoo-linux-security-uid-min-is-set-to-1000
    scoring_system: highest impact
queries:
  - uid: mondoo-linux-security-aide-is-installed
    title: Ensure Advanced Intrusion Detection Environment (AIDE) is installed
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      package("aide").installed
    docs:
      desc: |
        This check verifies that the Advanced Intrusion Detection Environment (AIDE) is installed on a Linux system. AIDE functions as a file integrity checker that helps detect unauthorized changes to critical system files and configurations.

        **Why this matters**

        AIDE creates a database of cryptographic checksums for important system files and directories. Once initialized, AIDE can be used to scan the system and compare the current state of files against the known-good baseline. This process helps detect file tampering, rootkit installation, or configuration drift that may indicate a security breach.

        Without a host-based file integrity monitoring (FIM) solution like AIDE, administrators may not be aware of changes to critical files made by malicious actors or unintended actions by privileged users. This lack of visibility undermines incident response, auditability, and system trustworthiness.

        Installing AIDE contributes to the overall integrity assurance of a Linux system and supports compliance with standards such as:
          - PCI-DSS Requirement 11.5
          - NIST 800-53 (SI-7: Software, Firmware, and Information Integrity)

        Ensuring AIDE is installed lays the foundation for host-based file integrity monitoring, which is a critical part of a defense-in-depth strategy for detecting intrusions and preserving system integrity.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            Run this command to install `aide`:

            ### RHEL/Fedora/Amazon Linux and derivatives

            ```bash
            yum install aide
            ```

            ### Debian/Ubuntu and derivatives

            ```bash
            apt-get install aide
            ```

            ### SLES and openSUSE

            ```bash
            zypper install aide
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to install `aide`:

            ```yaml
            ---
            - name: Install AIDE on Linux systems
              hosts: all
              become: true

              tasks:
                - name: Ensure AIDE is installed
                  ansible.builtin.package:
                    name: aide
                    state: present
            ```
  - uid: mondoo-linux-security-filesystem-integrity-is-regularly-checked
    title: Ensure filesystem integrity is regularly checked using AIDE
    impact: 50
    filters: |
      asset.kind != "container-image"
    mql: |
      file("/etc/default/aide").exists && ["/etc/default/aide"].where(file(_).exists).all(parse.ini(_).params["CRON_DAILY_RUN"] == "yes") ||
      command("crontab -u root -l | grep aide").stdout.lines.where(/^[^#]/).any(_.contains("aide --check")) ||
      command("crontab -u root -l | grep aide").stdout.lines.where(/^[^#]/).any(_.contains("aide.conf --check")) ||
      service('aidecheck').enabled
    docs:
      desc: |
        This check verifies that AIDE (Advanced Intrusion Detection Environment) is actively used to perform regular integrity scans of the filesystem. It ensures that an AIDE database has been initialized and that periodic checks are scheduled and executed.

        **Why this matters**

        Installing AIDE alone is not sufficient to protect a system from unauthorized changes. To be effective, AIDE must be routinely run to compare the current system state against its known-good baseline. Regular execution of these checks helps detect file tampering, unauthorized modifications, and early signs of compromise—especially in sensitive directories like /etc, /bin, and /sbin.

        If AIDE is not executed on a regular basis:
          - Integrity violations may go undetected, exposing the system to persistent threats such as rootkits or malware.
          - Audit logs and incident response efforts may be incomplete due to a lack of timely data.
          - Organizations may fail to meet compliance requirements that mandate proactive monitoring of system integrity.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI to setup Cron:***

            1. Run this command to initialize the AIDE database:

            ```bash
            aide --init
            ```


            2. Edit the root crontab:

            ```bash
            crontab -u root -e
            ```

            Add the following line to the crontab:

            ```
            0 5 * * * /usr/sbin/aide --check
            ```

            ***Using the CLI to setup systemd:***

            1. Run this command to initialize the AIDE database:

            ```bash
            aide --init
            ```

            2. Create the systemd service by creating the file `/etc/systemd/system/aidecheck.service` and adding the following lines:

            ```
            [Unit]
            Description=Aide Check

            [Service]
            Type=simple
            ExecStart=/usr/sbin/aide --check

            [Install]
            WantedBy=multi-user.target
            ```

            3. Create the systemd timer by creating or editing the file `/etc/systemd/system/aidecheck.timer` and add the following lines:

            ```
            [Unit]
            Description=Aide check every day at 5AM

            [Timer]
            OnCalendar=*-*-* 05:00:00
            Unit=aidecheck.service

            [Install]
            WantedBy=multi-user.target
            ```

            4. Configure the service and timer to run:

            ```bash
            chown root:root /etc/systemd/system/aidecheck.*
            chmod 0644 /etc/systemd/system/aidecheck.*

            systemctl daemon-reload

            systemctl enable aidecheck.service
            systemctl --now enable aidecheck.timer
            ```
        - id: ansible
          desc: |
            Use this Ansible playbook to run AIDE using a systemd timer:

            ```yaml
              ---
              - name: Configure daily AIDE check using systemd timer
                hosts: all
                become: true
                tasks:

                  - name: Create systemd service unit for AIDE check
                    copy:
                      dest: /etc/systemd/system/aidecheck.service
                      owner: root
                      group: root
                      mode: '0644'
                      content: |
                        [Unit]
                        Description=Aide Check

                        [Service]
                        Type=simple
                        ExecStart=/usr/sbin/aide --check

                        [Install]
                        WantedBy=multi-user.target

                  - name: Create systemd timer unit for daily AIDE check at 5AM
                    copy:
                      dest: /etc/systemd/system/aidecheck.timer
                      owner: root
                      group: root
                      mode: '0644'
                      content: |
                        [Unit]
                        Description=Aide check every day at 5AM

                        [Timer]
                        OnCalendar=*-*-* 05:00:00
                        Unit=aidecheck.service

                        [Install]
                        WantedBy=multi-user.target

                  - name: Reload systemd daemon to recognize new units
                    command: systemctl daemon-reexec

                  - name: Enable aidecheck.service (not started, only enabled)
                    systemd:
                      name: aidecheck.service
                      enabled: true

                  - name: Enable and start aidecheck.timer
                    systemd:
                      name: aidecheck.timer
                      enabled: true
                      state: started
            ```
  - uid: mondoo-linux-security-core-dumps-are-restricted
    title: Ensure core dumps are restricted
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    impact: 75
    mql: |
      file("/etc/security/limits.conf").content.lines.where( _ == /^[^#]/ ).where( _.contains("core") ) {
        _ == /\*\s+hard\s+core\s+0/
      }
      kernel.parameters['fs.suid_dumpable'] == 0
      if(service("coredump").enabled || service("coredump").running) {
        parse.ini("/etc/systemd/coredump.conf").sections['Coredump']['ProcessSizeMax'] == 0
        parse.ini("/etc/systemd/coredump.conf").sections['Coredump']['Storage'] == 'none'
      }
    docs:
      desc: |
        This check verifies that core dumps are restricted on the system by setting appropriate limits in `/etc/security/limits.conf`, configuring the `fs.suid_dumpable` kernel parameter, and ensuring the `coredump` service (if installed) is properly configured. These settings prevent unauthorized or excessive core dump creation, especially for set-user-ID (SUID) programs.

        **Why this matters**

        Core dumps capture the memory contents of a process at the time it crashes. While useful for debugging, core dumps can expose sensitive information such as passwords, cryptographic keys, or proprietary application logic—especially if generated by privileged or network-facing applications.

        By default, systems may allow core dumps for all processes, including those with elevated privileges. If unrestricted:
          - Attackers could exploit this to gain access to in-memory secrets.
          - Users could accidentally or intentionally generate core dumps containing sensitive information.
          - Storage systems could become overwhelmed by large or repeated core files, leading to denial-of-service risks.

        To mitigate this, three key protections should be enforced:
          - A hard limit of 0 core file size in /etc/security/limits.conf to block core dumps for all users by default.
          - Setting the fs.suid_dumpable kernel parameter to 0 to disable core dumps for SUID programs, which typically run with elevated privileges.
          - Properly configuring the coredump service (if installed) with ProcessSizeMax=0 and Storage=none to prevent systemd-based core dump handling from storing crash data.

        Restricting core dumps helps preserve the confidentiality of system memory, prevents unnecessary disk usage, and protects against inadvertent leakage of sensitive data.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            1. Run this command to set the core dump size to 0:

            ```bash
            ulimit -c 0
            ```

            2. To make the change permanent:

            Edit `/etc/security/limits.conf` and add the following line:

            ```
            * hard core 0
            ```

            Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

            ```
            fs.suid_dumpable = 0
            ```

            Run this command to set the active kernel parameter:

            ```bash
            sysctl -w fs.suid_dumpable=0
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to restrict core dumps:

            ```yaml
            ---
            - name: Disable core dumps on Linux
              hosts: all
              become: true
              tasks:

                - name: Set hard core dump limit to 0 in limits.d
                  ansible.builtin.copy:
                    dest: /etc/security/limits.d/99-disable-core.conf
                    owner: root
                    group: root
                    mode: '0644'
                    content: |
                      * hard core 0

                - name: Disable core dumps via sysctl
                  ansible.builtin.sysctl:
                    name: fs.suid_dumpable
                    value: '0'
                    sysctl_file: /etc/sysctl.d/99-disable-coredump.conf
                    state: present
                    reload: yes

                - name: Check if systemd-coredump config exists
                  ansible.builtin.stat:
                    path: /etc/systemd/coredump.conf
                  register: coredump_conf

                - name: Set systemd-coredump options if applicable
                  block:
                    - name: Ensure /etc/systemd/coredump.conf exists with correct settings
                      ansible.builtin.ini_file:
                        path: /etc/systemd/coredump.conf
                        section: Coredump
                        option: "{{ item.option }}"
                        value: "{{ item.value }}"
                      loop:
                        - { option: 'Storage', value: 'none' }
                        - { option: 'ProcessSizeMax', value: '0' }

                    - name: Reload systemd daemon after coredump config change
                      ansible.builtin.command: systemctl daemon-reexec
                  when: coredump_conf.stat.exists
            ```
  - uid: mondoo-linux-security-address-space-layout-randomization-aslr-is-enabled
    title: Ensure address space layout randomization (ASLR) is enabled
    impact: 90
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters["kernel.randomize_va_space"] == 2
    docs:
      desc: |
        This check verifies that Address Space Layout Randomization (ASLR) is enabled by confirming that the kernel parameter kernel.randomize_va_space is set to 2, which enforces full randomization of memory regions.

        **Why this matters**

        ASLR is a memory protection technique that randomizes the location of key data areas in a process's address space, such as the stack, heap, and libraries. This unpredictability makes it significantly harder for attackers to exploit memory corruption vulnerabilities, such as buffer overflows, since they cannot reliably guess the locations of critical functions or data structures in memory.

        When ASLR is disabled or misconfigured:
          - Exploits that rely on fixed memory addresses become easier to execute.
          - Attackers may leverage known memory layouts to bypass protections like stack canaries, non-executable memory (NX), and control flow integrity.
          - Systems become more susceptible to privilege escalation, remote code execution, and other forms of memory-based attacks.

        Setting kernel.randomize_va_space to 2 enables full ASLR, providing the strongest level of memory layout unpredictability and helping to enforce modern exploit mitigation strategies on Linux systems.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            Run this command to set the ASLR value to 2:

            ```bash
            sysctl -w kernel.randomize_va_space=2
            ```

            To make the change permanent:

            Edit `/etc/sysctl.conf` or a file in `/etc/sysctl.d/` and add the following line:

            ```
            kernel.randomize_va_space = 2
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to set ASLR:

            ```yaml
            ---
            - name: Set ASLR to 2 on Linux systems
              hosts: all
              become: true
              tasks:
                - name: Set kernel.randomize_va_space to 2
                  ansible.builtin.sysctl:
                    name: kernel.randomize_va_space
                    value: '2'
                    sysctl_file: /etc/sysctl.d/99-aslr.conf
                    state: present
                    reload: yes
            ```
  - uid: mondoo-linux-security-prelink-is-disabled
    title: Ensure prelink is disabled
    impact: 70
    mql: |
      package("prelink").installed == false
    docs:
      desc: |
        This check verifies that the prelink package is not installed on the system. The prelink utility modifies ELF binaries to optimize program load times by precomputing memory locations for shared libraries. While this can improve performance, it also introduces security risks and interferes with other critical system protections.

        **Why this matters**

        Disabling prelink helps ensure the reliability of security tools and strengthens system integrity protections. When prelink is active:
          - It modifies binaries on disk, which can prevent tools like AIDE from detecting unauthorized tampering because legitimate prelink changes obscure unauthorized ones.
          - It can negate security mechanisms such as Address Space Layout Randomization (ASLR) by fixing memory address locations in advance, undermining this key exploit mitigation technique.
          - It increases the system's attack surface by introducing complexity and modifying binaries in ways that may be exploited or misunderstood by defenders.

        Removing prelink eliminates this unnecessary risk, ensures compatibility with file integrity monitoring tools, and supports consistent enforcement of modern memory protection strategies.
      remediation: |-
        Run these commands to restore binaries to normal and uninstall `prelink`:

        ### RHEL/Fedora/Amazon Linux and derivatives

        ```bash
        prelink -ua
        yum remove prelink
        ```

        ### Debian/Ubuntu and derivatives

        ```bash
        prelink -ua
        apt-get purge prelink
        ```
  - uid: mondoo-linux-security-window-system-is-not-installed
    title: Ensure X Window System is not installed
    impact: 100
    mql: |
      packages.none(name == /^xserver-xorg.*/ || name == /^xorg-x11/ || name == /^xserver/)
    docs:
      desc: |
        This check verifies that the X Window System is not installed on the host. It scans for common packages associated with X, such as xserver-xorg, xorg-x11, and other display server components.

        **Why this matters**

        The X Window System provides a graphical user interface (GUI) that enables users to interact with applications through windows, menus, and graphical controls. While useful for desktop environments, it is generally unnecessary—and potentially risky—on servers or hardened systems that do not require graphical interfaces.

        Keeping the X Window System installed on a server can:
          - Introduce unnecessary software components and services, increasing the system's attack surface.
          - Add network-facing daemons that may not be actively monitored or patched, creating potential entry points for attackers.
          - Consume additional system resources that could otherwise be allocated to critical services.

        On headless or server-class Linux systems, the X Window System should be removed unless explicitly required. Removing it aligns with the principle of least functionality, ensuring only essential software is installed and reducing the opportunity for exploitation.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            Run this command to remove the X Windows System packages:

            ### RHEL/Fedora/Amazon Linux and derivatives

            ```bash
            yum remove xorg-x11*
            ```

            ### Debian/Ubuntu and derivatives

            ```bash
            apt-get purge xserver-xorg
            ```

            ### SLES and openSUSE

            ```bash
            zypper remove xorg-x11-server
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to remove the X Windows System packages:

            ```yaml
            ---
            - name: Remove X Window System packages
              hosts: all
              become: true
              tasks:
                - name: Remove X Window System packages on RHEL/Fedora/Amazon Linux
                  ansible.builtin.yum:
                    name: xorg-x11*
                    state: absent
                  when: ansible_os_family == "RedHat"

                - name: Remove X Window System packages on Debian/Ubuntu
                  ansible.builtin.apt:
                    name: xserver-xorg
                    state: absent
                  when: ansible_os_family == "Debian"

                - name: Remove X Window System packages on SLES/openSUSE
                  ansible.builtin.zypper:
                    name: xorg-x11-server
                    state: absent
                  when: ansible_os_family == "Suse"
            ```
  - uid: mondoo-linux-security-avahi-server-is-not-enabled
    title: Ensure Avahi server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("avahi-daemon").enabled == false
      service("avahi-daemon").running == false
    docs:
      desc: |
        This check verifies that the avahi-daemon service is neither running nor enabled on the system. Avahi is a zeroconf (zero-configuration networking) implementation that supports multicast DNS (mDNS) and DNS Service Discovery (DNS-SD), allowing devices to automatically discover each other on local networks.

        **Why this matters**

        While convenient in desktop or home environments, Avahi is rarely needed on production servers or hardened enterprise systems. When enabled, the Avahi daemon broadcasts services and listens for network announcements, which can:
          - Expose unnecessary information about the system to local network peers.
          - Increase the system's attack surface through unneeded services.
          - Allow unauthorized devices to detect and interact with the host without explicit configuration.

        In secure environments, it is a best practice to disable Avahi unless explicitly required for functionality. Stopping and disabling the avahi-daemon service helps enforce the principle of least functionality and reduces the risk of unintended network exposure.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            Run this command to stop and disable `avahi-daemon`:

            ```bash
            systemctl stop avahi-daemon
            systemctl disable avahi-daemon
            ```

            Note: Since the `avahi-daemon` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

            To make the service `avahi-daemon` invisible to other services run this command:

            ```bash
            systemctl mask avahi-daemon
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to stop and disable `avahi-daemon`:

            ```yaml
            ---
            - name: Stop and disable Avahi daemon
              hosts: all
              become: true

              tasks:
                - name: Ensure Avahi daemon is stopped and disabled
                  ansible.builtin.systemd:
                    name: avahi-daemon
                    state: stopped
                    enabled: no
                    masked: true
            ```
  - uid: mondoo-linux-security-cups-is-not-enabled
    title: Ensure CUPS is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("cups").enabled == false
      service("cups").running == false
    docs:
      desc: |
        This check verifies that the Common Unix Printing System (CUPS) service is neither running nor enabled on the system. CUPS provides printing capabilities for local and network printers and includes web-based administration tools.

        **Why this matters**

        CUPS is typically unnecessary on hardened servers or cloud-hosted Linux systems where printing services are not required. If left running:
          - It may expose the system to remote exploitation, especially if administrative interfaces are accessible over the network.
          - It increases the overall attack surface by introducing a network-accessible daemon.
          - Unused services like CUPS can be leveraged in lateral movement or privilege escalation scenarios, particularly if misconfigured or unpatched.

        Disabling CUPS aligns with the principle of least functionality and helps reduce the number of services available for exploitation. It is recommended to stop and disable the service unless printing capabilities are explicitly required for the system's role.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            Run this command to stop and disable `cups`:

            ```bash
            systemctl stop cups
            systemctl disable cups
            ```

            Note: Since the `cups` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

            To make the service `cups` invisible to other services run this command:

            ```bash
            systemctl mask cups
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to stop and disable `cups`:

            ```yaml
            ---
            - name: Stop and disable CUPS printing service
              hosts: all
              become: true

              tasks:
                - name: Ensure CUPS service is stopped and disabled
                  ansible.builtin.systemd:
                    name: cups
                    state: stopped
                    enabled: no
                    masked: true
            ```
  - uid: mondoo-linux-security-dhcp-server-is-not-enabled
    title: Ensure DHCP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("dhcpd").enabled == false
      service("dhcpd").running == false
    docs:
      desc: |
        This check verifies that the DHCP server service (dhcpd) is neither running nor enabled on the system.

        **Why this matters**

        The Dynamic Host Configuration Protocol (DHCP) allows systems to dynamically assign IP addresses and other network configuration parameters to devices on a network. While essential in network infrastructure roles, DHCP servers are rarely required on general-purpose Linux systems or production servers.

        Running a DHCP server where it is not explicitly needed can:
          - Lead to IP address conflicts and unpredictable network behavior.
          - Allow unauthorized clients to obtain network configuration from an untrusted source.
          - Expose the host to exploitation if the service is vulnerable or misconfigured.

        Disabling unused services like dhcpd reduces the system's attack surface and aligns with the principle of least functionality. On systems that are not intended to serve as DHCP servers, the service should be fully disabled to prevent accidental exposure or misuse.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            1. Run this command to stop and disable `dhcpd`:

            ```bash
            systemctl stop dhcpd
            systemctl disable dhcpd
            ```

            2. To make the service `dhcpd` invisible to other services run this command:

            ```bash
            systemctl mask dhcpd
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to stop and disable `dhcpd`:

            ```yaml
            ---
            - name: Stop and disable DHCP server service
              hosts: all
              become: true

              tasks:
                - name: Ensure DHCP server (dhcpd) is stopped and disabled
                  ansible.builtin.systemd:
                    name: dhcpd
                    state: stopped
                    enabled: no
                    masked: true
            ```
  - uid: mondoo-linux-security-ldap-server-is-not-enabled
    title: Ensure LDAP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("slapd").enabled == false
      service("slapd").running == false
    docs:
      desc: |
        This check verifies that the LDAP server service (slapd) is neither running nor enabled on the system.

        **Why this matters**

        The Lightweight Directory Access Protocol (LDAP) server provides centralized directory services for managing user identities, authentication data, and configuration information across a network. While useful in enterprise environments that require directory-based access management, an LDAP server is rarely needed on general-purpose Linux systems unless explicitly part of the infrastructure design.

        If an unnecessary LDAP server is running:
          - It may expose sensitive directory information to the network.
          - It increases the system's attack surface by introducing a network-accessible service.
          - It can be misused or targeted by attackers to enumerate user accounts, perform unauthorized lookups, or exploit known vulnerabilities.

        To reduce risk and enforce the principle of least functionality, the slapd service should be stopped and disabled on systems that are not intended to serve directory services. This helps limit exposure and strengthens the host's overall security posture.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            Run this command to stop and disable `slapd`:

            ```bash
            systemctl stop slapd
            systemctl disable slapd
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to stop and disable `slapd`:

            ```yaml
            ---
            - name: Stop and disable LDAP server (slapd)
              hosts: all
              become: true

              tasks:
                - name: Ensure LDAP server (slapd) is stopped and disabled
                  ansible.builtin.systemd:
                    name: slapd
                    state: stopped
                    enabled: no
            ```
  - uid: mondoo-linux-security-nfs-and-rpc-are-not-enabled
    title: Ensure NFS and RPC are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("nfs").enabled == false
      service("nfs").running == false
      service("rpcbind").enabled == false
      service("rpcbind").running == false
    docs:
      desc: |
        This check verifies that the NFS (nfs) and RPC (rpcbind) services are not running and are disabled from starting at boot. These services are commonly used to share directories across systems on a network using the Network File System (NFS) protocol.

        **Why this matters**

        NFS and RPC are powerful but legacy components of networked UNIX environments. They introduce significant security risks when enabled unnecessarily, particularly on systems not explicitly configured as file servers or requiring remote filesystem mounts.

        When NFS and RPC are active:
          - They open multiple ports and expose services that can be discovered and potentially exploited.
          - RPC-based services may leak metadata about system configurations or mount points.
          - Misconfigurations or vulnerabilities in these services can be used for privilege escalation, lateral movement, or data exfiltration.

        Disabling NFS and RPC services on systems where they are not required reduces unnecessary network exposure, aligns with the principle of least functionality, and helps harden systems against remote access threats.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI:***

            1. Run this command to stop and disable `nfs` and `rpcbind`:

            ```bash
            systemctl stop nfs
            systemctl stop rpcbind

            systemctl disable nfs
            systemctl disable rpcbind
            ```

            2. To make the service `nfs` and `rpcbind` invisible to other services run this command:

            ```bash
            systemctl mask nfs
            systemctl mask rpcbind
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to stop and disable `nfs` and `rpcbind`:

            ```yaml
            ---
            - name: Stop and disable NFS and RPC services
              hosts: all
              become: true

              tasks:
                - name: Ensure NFS and RPC services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                    masked: true
                  loop:
                    - nfs
                    - rpcbind
            ```
  - uid: mondoo-linux-security-dns-server-is-not-enabled
    title: Ensure DNS server is stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("named").enabled == false
      service("named").running == false
      service("bind9").enabled == false
      service("bind9").running == false
    docs:
      desc: |
        This check verifies that DNS server services such as named (BIND) or bind9 are not running and are disabled on the system.

        **Why this matters**

        DNS servers provide name resolution services by mapping domain names to IP addresses. While essential in network infrastructure roles, running a DNS server on systems that are not explicitly intended to serve DNS requests introduces unnecessary risk.

        If a DNS server is unintentionally left active:
          - It may expose internal network details or zone files to unauthorized users.
          - It can be used in DNS amplification attacks if misconfigured.
          - It increases the system's attack surface through open ports and additional daemon processes.

        Disabling DNS server services on systems that are not authoritative or caching resolvers aligns with the principle of least functionality. This reduces exposure to misconfiguration, limits available network services, and strengthens the host's security posture.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI***

            Run this command to stop and disable `named` and `bind9`:

            ```bash
            systemctl stop named
            systemctl stop bind9

            systemctl disable named
            systemctl disable bind9
            ```
        - id: ansible
          desc: |
            ***Using Ansible:***

            Use this Ansible playbook to stop and disable `named` and `bind9`:

            ```yaml
            ---
            - name: Stop and disable DNS server services
              hosts: all
              become: true

              tasks:
                - name: Ensure DNS server services (named and bind9) are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - named
                    - bind9
            ```
  - uid: mondoo-linux-security-ftp-server-is-not-enabled
    title: Ensure FTP servers are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("vsftpd").enabled == false
      service("vsftpd").running == false
      service("proftpd").enabled == false
      service("proftpd").running == false
      service("pure-ftpd").enabled == false
      service("pure-ftpd").running == false
    docs:
      desc: |
        This check verifies that common FTP server services—vsftpd, proftpd, and pure-ftpd—are not running and are disabled on the system.

        **Why this matters**

        FTP servers enable file transfer over a network but do so using plaintext for both data and credentials, making them inherently insecure. When enabled without encryption or proper controls, FTP services are vulnerable to:
          - Credential theft through packet sniffing
          - Unauthorized file access or modification
          - Abuse in reconnaissance and data exfiltration by attackers

        In most environments, FTP has been replaced by more secure alternatives like SFTP or FTPS, which encrypt both authentication and file transfer traffic. Unless explicitly required, running an FTP server introduces unnecessary risk and increases the system's attack surface.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run this command to stop and disable `vsftpd`, `proftpd`, and `pure-ftpd`:

            ```bash
            systemctl stop vsftpd
            systemctl disable vsftpd

            systemctl stop proftpd
            systemctl disable proftpd

            systemctl stop pure-ftpd
            systemctl disable pure-ftpd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `vsftpd`, `proftpd`, and `pure-ftpd`:

            ```yaml
            ---
            - name: Stop and disable FTP server services
              hosts: all
              become: true

              tasks:
                - name: Ensure FTP server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - vsftpd
                    - proftpd
                    - pure-ftpd
            ```
  - uid: mondoo-linux-security-http-server-is-not-enabled
    title: Ensure HTTP servers are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("httpd").enabled == false
      service("httpd").running == false
      service("apache2").enabled == false
      service("apache2").running == false
      service("nginx").enabled == false
      service("nginx").running == false
    docs:
      desc: |
        This check verifies that common HTTP server services such as httpd, apache2, and nginx are not running and are disabled on the system.

        **Why this matters**

        HTTP servers provide web hosting functionality and are often exposed to the network, making them high-value targets for attackers. Unless the system is explicitly intended to serve web content, running these services introduces unnecessary security risk.

        If left enabled:
          - HTTP servers can expose sensitive files or administrative interfaces.
          - They may contain unpatched vulnerabilities that are remotely exploitable.
          - Misconfigurations can lead to data leakage, privilege escalation, or unauthorized access.

        Disabling web servers like Apache and NGINX on systems where they are not required aligns with the principle of least functionality. This reduces the system's attack surface and helps ensure that only essential services are active and maintained.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run this command to stop and disable `httpd`, `apache2`, and `nginx`:

            ```bash
            systemctl stop httpd
            systemctl disable httpd

            systemctl stop apache2
            systemctl disable apache2

            systemctl stop nginx
            systemctl disable nginx
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `httpd`, `apache2`, and `nginx`:

            ```yaml
            ---
            - name: Stop and disable HTTP server services
              hosts: all
              become: true

              tasks:
                - name: Ensure HTTP server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - httpd
                    - apache2
                    - nginx
            ```
  - uid: mondoo-linux-security-imap-and-pop3-server-is-not-enabled
    title: Ensure IMAP and POP3 servers are stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("dovecot").enabled == false
      service("dovecot").running == false
      service("cyrus-imapd").enabled == false
      service("cyrus-imapd").running == false
    docs:
      desc: |
        This check verifies that common IMAP and POP3 email server services such as dovecot and cyrus-imapd are not running and are disabled from starting at boot.

        **Why this matters**

        IMAP (Internet Message Access Protocol) and POP3 (Post Office Protocol) servers are used to deliver email messages to clients. These services are typically deployed in environments where systems are designated as mail servers. On general-purpose Linux systems or hardened servers, they are rarely required and introduce unnecessary risk if left enabled.

        Running IMAP or POP3 servers where not needed can:
          - Expose authentication services and mail data to the network.
          - Increase the system's attack surface via potentially unpatched or misconfigured mail daemons.
          - Create compliance and privacy issues if email data is improperly stored or transmitted.

        To minimize exposure, systems that do not explicitly require mail delivery services should have dovecot, cyrus-imapd, and similar services disabled. This approach supports the principle of least functionality and reduces the risk of unauthorized access or system compromise.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run this command to stop and disable `dovecot` and `cyrus-imapd`:

            ```bash
            systemctl stop dovecot
            systemctl disable dovecot

            systemctl stop cyrus-imapd
            systemctl disable cyrus-imapd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `dovecot` and `cyrus-imapd`:

            ```yaml
            ---
            - name: Stop and disable IMAP and POP3 server services
              hosts: all
              become: true

              tasks:
                - name: Ensure IMAP and POP3 server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - dovecot
                    - cyrus-imapd
            ```
  - uid: mondoo-linux-security-samba-is-not-enabled
    title: Ensure Samba is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("smb").enabled == false
      service("smbd").enabled == false
      service("smb").running == false
      service("smbd").running == false
    docs:
      desc: |
        This check verifies that the Samba services (smb and smbd) are not running and are disabled on the system.

        **Why this matters**

        Samba provides file and print sharing capabilities for interoperability between Linux and Windows systems using the SMB/CIFS protocol. While useful in mixed OS environments that require shared resources, Samba is unnecessary—and potentially risky—on systems that are not intended to serve files or printers over the network.

        If Samba is enabled where not needed:
          - It introduces network-facing services that can be discovered and targeted by attackers.
          - Misconfigurations or outdated Samba versions may allow unauthorized access or remote code execution.
          - It increases the system's attack surface and may expose internal file systems unintentionally.

        To minimize unnecessary exposure, Samba should be disabled on systems that do not explicitly require Windows-compatible file sharing. This approach supports a least functionality model and helps reduce the risk of data leakage or compromise.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `smb` and `smbd`:

            ```bash
            systemctl stop smb
            systemctl stop smbd

            systemctl disable smb
            systemctl disable smbd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `smb` and `smbd`:

            ```yaml
            ---
            - name: Stop and disable Samba services
              hosts: all
              become: true
              tasks:
                - name: Stop and disable Samba services
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - smb
                    - smbd
            ```
  - uid: mondoo-linux-security-http-proxy-server-is-not-enabled
    title: Ensure HTTP Proxy server is stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("squid").enabled == false
      service("squid").running == false
      service("tinyproxy").enabled == false
      service("tinyproxy").running == false
    docs:
      desc: |
        This check verifies that HTTP proxy services such as squid and tinyproxy are not running and are disabled on the system.

        **Why this matters**

        HTTP proxy servers are used to forward client requests to destination servers, often to enable caching, access control, or anonymization of traffic. While valuable in network perimeter or gateway roles, proxy services are rarely needed on general-purpose Linux systems or hardened servers.

        If an HTTP proxy service is enabled unnecessarily:
          - It may relay traffic without proper filtering or monitoring, exposing the system to misuse or abuse.
          - Misconfigured proxies can be exploited to bypass security controls, leak sensitive information, or allow unauthorized access to internal networks.
          - Proxy daemons increase the system's attack surface through open ports and additional network logic.

        To reduce risk, squid, tinyproxy, and similar services should be stopped and disabled unless the system is explicitly designed to function as a proxy server. This limits unnecessary service exposure and aligns with best practices for host hardening.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `squid` and `tinyproxy`:

            ```bash
            systemctl stop squid
            systemctl stop tinyproxy

            systemctl disable squid
            systemctl disable tinyproxy
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `squid` and `tinyproxy`:

            ```yaml
            ---
            - name: Stop and disable HTTP proxy services
              hosts: all
              become: true

              tasks:
                - name: Ensure HTTP proxy services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - squid
                    - tinyproxy
            ```
  - uid: mondoo-linux-security-snmp-server-is-not-enabled
    title: Ensure SNMP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("snmpd").enabled == false
      service("snmpd").running == false
    docs:
      desc: |
        This check verifies that the SNMP server service (snmpd) is not running and is disabled on the system.

        **Why this matters**

        The Simple Network Management Protocol (SNMP) is used for monitoring and managing network devices. While SNMP can be valuable in infrastructure environments that require centralized device monitoring, it is rarely needed on general-purpose Linux systems or non-networking servers.

        If the SNMP service is enabled unnecessarily:
          - It may expose system and network information to unauthorized users, especially if default community strings are not changed.
          - SNMPv1 and SNMPv2c transmit data in plaintext, making them vulnerable to interception and misuse.
          - Misconfigured or unmonitored SNMP services can be leveraged for network reconnaissance or as part of broader attack campaigns.

        To reduce the risk of information disclosure and limit unnecessary network services, snmpd should be stopped and disabled on systems that are not specifically designated for SNMP-based monitoring. This supports the principle of least functionality and strengthens the system's security posture.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `snmpd`:

            ```bash
            systemctl stop snmpd
            systemctl disable snmpd
            ```

            Note: Since the `snmpd` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

            To make the service `snmpd` invisible to other services run this command:

            ```bash
            systemctl mask snmpd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `snmpd`:

            ```yaml
            ---
            - name: Stop and disable SNMP server
              hosts: all
              become: true

              tasks:
                - name: Ensure SNMP server (snmpd) is stopped and disabled
                  ansible.builtin.systemd:
                    name: snmpd
                    state: stopped
                    masked: true
                    enabled: no
            ```
  - uid: mondoo-linux-security-mail-transfer-agent-is-configured-for-local-only-mode
    title: Ensure mail transfer agent is configured for local-only mode
    impact: 85
    filters: |
      asset.kind != "container-image"
    mql: |
      if( package("postfix").installed && service('postfix').running ) {
        parse.ini("/etc/postfix/main.cf").params["inet_interfaces"] == "localhost" || parse.ini("/etc/postfix/main.cf").params["inet_interfaces"] == "loopback-only"
      }
      if( package("exim4").installed && service('exim4').running ) {
        parse.ini("/etc/exim4/update-exim4.conf.conf").params["dc_local_interfaces"] == "'127.0.0.1 ; ::1'"
      }
      ports.listening.where(address != "127.0.0.1" && address != "[::1]").none(port == 25)
    docs:
      desc: |
        This check verifies that the system's mail transfer agent (MTA), such as Postfix or Exim, is configured to accept and process email only from the local host, rather than listening on external network interfaces.

        **Why this matters**

        Mail transfer agents are used to route and deliver email messages. On most Linux systems, an MTA is installed by default to handle local system notifications, such as cron job outputs or security alerts. However, if the MTA is configured to listen on external interfaces, it may unintentionally expose the system to external email traffic.

        Allowing remote connections to a local MTA can:
          - Turn the system into an open relay if not properly secured.
          - Increase the attack surface by exposing the MTA to brute-force attacks, spoofed messages, or software vulnerabilities.
          - Introduce compliance concerns if email flows are not properly audited or encrypted.

        Configuring the MTA to listen only on the loopback interface (127.0.0.1) ensures it serves only local applications and users. This reduces exposure, limits attack vectors, and aligns with security best practices for systems that are not intended to function as full email servers.
      remediation: |-
        **For Postfix**

        Edit `/etc/postfix/main.cf` and add the following line to the RECEIVING MAIL section. If the line already exists, change it to look like the line below:

        ```
        inet_interfaces = loopback-only
        ```

        Restart postfix:

        ```bash
        systemctl restart postfix
        ```

        **For Exim4 (Debian/Ubuntu)**

        Edit the Exim4 configuration file, typically located at `/etc/exim4/update-exim4.conf.conf``. Find the line that sets `dc_local_interfaces` and modify it to the following:

        ```
        dc_local_interfaces='127.0.0.1 ; ::1'
        ```

        This configuration limits Exim4 to listening only on the loopback IPv4 and IPv6 interfaces.

        After making the change, regenerate the Exim4 runtime configuration and restart the service:

        ```bash
        update-exim4.conf
        systemctl restart exim4
        ```
  - uid: mondoo-linux-security-nis-server-is-not-enabled
    title: Ensure NIS server is stopped and not enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
    mql: |
      service("ypserv").enabled == false
      service("ypserv").running == false
      service("nis").enabled == false
      service("nis").running == false
    docs:
      desc: |
        This check verifies that the Network Information Service (NIS) server services, such as ypserv or nis, are not running and are disabled on the system.

        **Why this matters**

        NIS (formerly known as Yellow Pages) is a legacy directory service protocol used to centrally manage user accounts and configuration data across multiple systems. While once common in UNIX environments, NIS has significant security limitations and has been largely replaced by more secure alternatives like LDAP or Kerberos.

        If the NIS server is enabled unnecessarily:
          - It may transmit sensitive data such as usernames and password hashes in plaintext.
          - NIS lacks modern authentication and encryption mechanisms, making it highly susceptible to eavesdropping and spoofing attacks.
          - Running NIS services can expose the system to unauthorized access or information disclosure, especially in mixed or untrusted networks.

        On systems that are not explicitly designated to serve as NIS servers, ypserv, nis, and related services should be stopped and disabled. This helps enforce the principle of least functionality and significantly reduces the system's vulnerability to legacy protocol risks.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `ypserv` and `nis`:

            ```bash
            systemctl stop ypserv
            systemctl stop nis

            systemctl disable ypserv
            systemctl disable nis
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `ypserv` and `nis`:

            ```yaml
            ---
            - name: Stop and disable NIS server services
              hosts: all
              become: true

              tasks:
                - name: Ensure NIS server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - ypserv
                    - nis
            ```
  - uid: mondoo-linux-security-rsh-server-is-not-enabled
    title: Ensure rsh server is stopped and not enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
    mql: |
      service("rsh.socket").enabled == false
      service("rlogin.socket").enabled == false
      service("rexec.socket").enabled == false
      service("rsh.socket").running == false
      service("rlogin.socket").running == false
      service("rexec.socket").running == false
    docs:
      desc: |
        This check verifies that the Remote Shell (rsh) server services—specifically rsh.socket, rlogin.socket, and rexec.socket—are not running and are disabled on the system.

        **Why this matters**

        The rsh suite (which includes rsh, rlogin, and rexec) provides remote command execution and login capabilities over a network. However, these services transmit data, including credentials, in plaintext and rely on weak authentication mechanisms based on hostname and user trust relationships.

        If rsh services are enabled:
          - They expose sensitive data to interception, making the system vulnerable to credential theft.
          - Host-based trust mechanisms (like .rhosts) can be easily bypassed or misconfigured, allowing unauthorized access.
          - They increase the system's attack surface and may be exploited for lateral movement in a compromised environment.

        Because of these risks, rsh is considered obsolete and should be replaced with secure alternatives such as SSH. Disabling rsh, rlogin, and rexec services helps prevent unauthorized remote access and aligns with modern security best practices for system hardening.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `rsh`, `rlogin`, and `rexec`:

            ```bash
            systemctl stop rsh.socket
            systemctl stop rlogin.socket
            systemctl stop rexec.socket

            systemctl disable rsh.socket
            systemctl disable rlogin.socket
            systemctl disable rexec.socket
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `rsh`, `rlogin`, and `rexec`:

            ```yaml
            ---
            - name: Stop and disable rsh server services
              hosts: all
              become: true

              tasks:
                - name: Ensure rsh-related services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - rsh.socket
                    - rlogin.socket
                    - rexec.socket
            ```
  - uid: mondoo-linux-security-telnet-server-is-not-enabled
    title: Ensure Telnet server is stopped and not enabled
    impact: 90
    filters: |
      asset.kind != "container-image"
    mql: |
      service("telnet.socket").enabled == false
      service("telnet.socket").running == false
    docs:
      desc: |-
        This check verifies that the Telnet server service (telnet.socket) is not running and is disabled on the system.

        **Why this matters**

        Telnet is an older protocol used for remote command-line access over a network. It transmits all data—including usernames and passwords—in plaintext, making it highly insecure for modern environments. Any system using Telnet is vulnerable to eavesdropping, session hijacking, and credential theft.

        If the Telnet server is enabled:
          - It exposes the system to man-in-the-middle attacks due to the lack of encryption.
          - Credentials and session data can be intercepted by any attacker with network access.
          - It creates a significant attack surface that can be exploited by automated tools or targeted threats.

        Modern systems should use secure alternatives such as SSH, which encrypt all communications. Disabling Telnet services on systems where they are not explicitly required strengthens the host's security posture and reduces the risk of unauthorized access.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these command to stop and disable telnet:

            ```bash
            systemctl stop telnet.socket
            systemctl disable telnet.socket
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable telnet:

            ```yaml
            ---
            - name: Stop and disable Telnet server
              hosts: all
              become: true

              tasks:
                - name: Ensure Telnet server is stopped and disabled
                  ansible.builtin.systemd:
                    name: telnet.socket
                    state: stopped
                    enabled: no
            ```
  - uid: mondoo-linux-security-tftp-server-is-not-enabled
    title: Ensure TFTP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("tftp.socket").enabled == false
      service("tftp.socket").running == false
    docs:
      desc: |
        This check verifies that the Trivial File Transfer Protocol (TFTP) server service (tftp.socket) is not running and is disabled on the system.

        **Why this matters**

        TFTP is a simple, lightweight file transfer protocol typically used for tasks such as bootstrapping diskless workstations or network appliances. It lacks authentication, encryption, and access control mechanisms, making it highly insecure for general-purpose or internet-connected systems.

        If the TFTP server is enabled:
          - Files can be read or written without authentication, leading to data leakage or unauthorized modification.
          - Attackers can use TFTP to upload malicious payloads or exfiltrate sensitive files.
          - It may serve as an entry point for lateral movement in network-based attacks, especially in environments with legacy devices.

        Unless TFTP is explicitly required for a specific, isolated use case, the service should be stopped and disabled. Removing unnecessary TFTP services reduces the system's attack surface and aligns with best practices for minimizing unauthenticated network protocols.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable tftp:

            ```bash
            systemctl stop tftp.socket
            systemctl disable tftp.socket
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable tftp:

            ```yaml
            ---
            - name: Stop and disable TFTP server
              hosts: all
              become: true

              tasks:
                - name: Ensure TFTP server is stopped and disabled
                  ansible.builtin.systemd:
                    name: tftp.socket
                    state: stopped
                    enabled: no
            ```
  - uid: mondoo-linux-security-rsync-service-is-not-enabled
    title: Ensure rsync service is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("rsyncd").enabled == false
      service("rsyncd").running == false
    docs:
      desc: |
        This check verifies that the rsyncd service, which enables the rsync daemon for file synchronization over the network, is not running and is disabled on the system.

        **Why this matters**

        The rsync daemon allows systems to synchronize files with remote hosts. While useful in backup and replication workflows, running rsyncd as a service introduces a network-accessible endpoint that may expose files or directories if not properly secured.

        If the rsync service is enabled unnecessarily:
          - It can expose sensitive files to unauthorized access, especially if authentication is misconfigured or absent.
          - It increases the system's attack surface by opening a network port that could be targeted for exploitation.
          - Unrestricted or anonymous rsync configurations can lead to data exfiltration or integrity compromise.

        Unless the system is explicitly configured to serve files via rsyncd, the service should be disabled. This aligns with the principle of least functionality and helps prevent accidental exposure of file data to untrusted networks.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `rsync`:

            ```bash
            systemctl stop rsyncd
            systemctl disable rsyncd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `rsync`:

            ```yaml
            ---
            - name: Stop and disable rsync service
              hosts: all
              become: true

              tasks:
                - name: Ensure rsync service is stopped and disabled
                  ansible.builtin.systemd:
                    name: rsyncd
                    state: stopped
                    enabled: no
            ```
  - uid: mondoo-linux-security-talk-server-is-not-enabled
    title: Ensure talk server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("ntalk").enabled == false
      service("ntalk").running == false
      service("talkd").enabled == false
      service("talkd").running == false
    docs:
      desc: |
        This check verifies that the talk server (talkd or ntalk) is disabled to prevent the use of an outdated and insecure communication protocol.

        **Why this matters**

        The talk protocol enables real-time text-based communication between users on UNIX systems. However, it lacks encryption and strong authentication mechanisms, making it unsuitable for modern environments.

        If the talk server is enabled:
          - It exposes the system to network-based attacks through an unnecessary and insecure service.
          - Messages are transmitted in plaintext, allowing for potential interception and eavesdropping.
          - The service increases the system's attack surface and may be abused for denial-of-service attacks or unauthorized user messaging.

        Disabling the talk server minimizes risk, reduces the system's attack surface, and enforces a minimal, hardened system configuration.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Run these commands to stop and disable `ntalk` and `talkd`:

            ```bash
            systemctl stop ntalk
            systemctl stop talkd

            systemctl disable ntalk
            systemctl disable talkd
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to stop and disable `ntalk` and `talkd`:

            ```yaml
            ---
            - name: Stop and disable talk server services
              hosts: all
              become: true

              tasks:
                - name: Ensure talk server services are stopped and disabled
                  ansible.builtin.systemd:
                    name: "{{ item }}"
                    state: stopped
                    enabled: no
                  loop:
                    - ntalk
                    - talkd
            ```
  - uid: mondoo-linux-security-ip-forwarding-is-disabled
    title: Ensure IP forwarding is disabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.ip_forward'] == 0
        || kernel.parameters['net.ipv4.ip_forward'] == null
      kernel.parameters['net.ipv6.conf.all.forwarding'] == 0
        || kernel.parameters['net.ipv6.conf.all.forwarding'] == null
    docs:
      desc: |
        This check verifies that IP forwarding is disabled by confirming that the kernel parameters net.ipv4.ip_forward and net.ipv6.conf.all.forwarding are set to 0.

        **Why this matters**

        IP forwarding allows a system to route network packets between interfaces, effectively enabling it to act as a router. While necessary for certain network infrastructure roles, IP forwarding is not appropriate for general-purpose servers, workstations, or systems that are not explicitly configured to route traffic.

        If IP forwarding is enabled unnecessarily:
          - The system could be used to redirect or intercept network traffic, intentionally or accidentally.
          - It increases the risk of network misconfiguration, data leakage, or man-in-the-middle attacks.
          - It may violate segmentation and isolation policies in secure environments.

        Disabling IP forwarding ensures the system cannot forward packets between networks, reducing the potential for misuse or compromise. This helps maintain clear boundaries between network zones and supports a more secure and predictable system configuration.
      remediation:
        - id: cli
          desc: |
            **Using CLI**

            Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

            ```
            net.ipv4.ip_forward = 0
            net.ipv6.conf.all.forwarding = 0
            ```

            Run these commands to set the active kernel parameters:

            ```bash
            sysctl -w net.ipv4.ip_forward=0
            sysctl -w net.ipv4.route.flush=1

            sysctl -w net.ipv6.conf.all.forwarding=0
            sysctl -w net.ipv6.route.flush=1
            ```
        - id: ansible
          desc: |
            **Using Ansible**

            Use this Ansible playbook to set the kernel parameters:

            ```yaml
            ---
            - name: Disable IPv4 and IPv6 forwarding
              hosts: all
              become: true

              tasks:
                - name: Ensure IPv4 and IPv6 forwarding is disabled in sysctl configuration
                  ansible.builtin.sysctl:
                    name: "{{ item.name }}"
                    value: "{{ item.value }}"
                    sysctl_file: /etc/sysctl.d/99-disable-ip-forwarding.conf
                    state: present
                    reload: yes
                  loop:
                    - { name: 'net.ipv4.ip_forward', value: '0' }
                    - { name: 'net.ipv6.conf.all.forwarding', value: '0' }
                    - { name: 'net.ipv4.route.flush', value: '1' }
                    - { name: 'net.ipv6.route.flush', value: '1' }
            ```
  - uid: mondoo-linux-security-packet-redirect-sending-is-disabled
    title: Ensure packet redirect sending is disabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.send_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.send_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.send_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.send_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to not send ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.send_redirects` and `net.ipv4.conf.default.send_redirects` are set to `0`.

        **Why this matters**

        ICMP redirect messages are used by routers to inform hosts of a more efficient route for reaching a destination. However, on systems that are not functioning as routers, this feature is unnecessary and can introduce security risks.

        If packet redirect sending is enabled:
          - The system could inadvertently influence the routing behavior of other devices on the network.
          - Malicious actors could exploit redirect functionality to reroute traffic through compromised or untrusted devices.
          - It increases the complexity and unpredictability of network traffic flow, complicating security monitoring and enforcement.

        Disabling the ability to send ICMP redirects on non-router systems prevents unauthorized route manipulation and supports secure, well-defined network behavior. This reduces the risk of traffic interception or redirection by adversaries.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.send_redirects = 0
        net.ipv4.conf.default.send_redirects = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.send_redirects=0
        sysctl -w net.ipv4.conf.default.send_redirects=0
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-source-routed-packets-are-not-accepted
    title: Ensure source routed packets are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.accept_source_route'] == 0
        || kernel.parameters['net.ipv4.conf.all.accept_source_route'] == null
      kernel.parameters['net.ipv4.conf.default.accept_source_route'] == 0
        || kernel.parameters['net.ipv4.conf.default.accept_source_route'] == null
      kernel.parameters['net.ipv6.conf.all.accept_source_route'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_source_route'] == null
      kernel.parameters['net.ipv6.conf.default.accept_source_route'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_source_route'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject source-routed packets by ensuring the kernel parameters `net.ipv4.conf.all.accept_source_route`, `net.ipv4.conf.default.accept_source_route`, `net.ipv6.conf.all.accept_source_route`, and `net.ipv6.conf.default.accept_source_route` are set to `0`.

        **Why this matters**

        Source routing allows the sender of a packet to specify the exact path it should take through the network. While this feature was designed for network troubleshooting, it is rarely used in modern environments and poses significant security risks.

        If source-routed packets are accepted:
          - Attackers can bypass network routing controls and firewall rules by crafting packets with arbitrary paths.
          - It enables traffic spoofing and man-in-the-middle attacks by redirecting data through attacker-controlled systems.
          - It undermines network segmentation and isolation policies.

        Disabling acceptance of source-routed packets ensures that the system only processes packets routed according to the network's standard path selection, reducing the risk of exploitation and reinforcing a secure network posture.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.accept_source_route = 0
        net.ipv4.conf.default.accept_source_route = 0
        net.ipv6.conf.all.accept_source_route = 0
        net.ipv6.conf.default.accept_source_route = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.accept_source_route=0
        sysctl -w net.ipv4.conf.default.accept_source_route=0
        sysctl -w net.ipv4.route.flush=1

        sysctl -w net.ipv6.conf.all.accept_source_route=0
        sysctl -w net.ipv6.conf.default.accept_source_route=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-icmp-redirects-are-not-accepted
    title: Ensure ICMP redirects are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.accept_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.accept_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.accept_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.accept_redirects'] == null
      kernel.parameters['net.ipv6.conf.all.accept_redirects'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_redirects'] == null
      kernel.parameters['net.ipv6.conf.default.accept_redirects'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.accept_redirects`, `net.ipv4.conf.default.accept_redirects`, `net.ipv6.conf.all.accept_redirects`, and `net.ipv6.conf.default.accept_redirects` are set to `0`.

        **Why this matters**

        ICMP redirect messages are used by routers to inform hosts of a better route for reaching a destination. While intended to optimize network traffic, accepting these messages on non-router systems can introduce serious security risks.

        If ICMP redirects are accepted:
          - Attackers can exploit this to alter the routing table of a host, redirecting traffic through malicious devices.
          - It creates opportunities for man-in-the-middle attacks, traffic interception, or denial-of-service.
          - It makes network traffic paths unpredictable and harder to audit or monitor effectively.

        Disabling ICMP redirect acceptance ensures that the system maintains static and trusted routing behavior, helping to preserve network integrity and defend against unauthorized routing changes.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.accept_redirects = 0
        net.ipv4.conf.default.accept_redirects = 0
        net.ipv6.conf.all.accept_redirects = 0
        net.ipv6.conf.default.accept_redirects = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.accept_redirects=0
        sysctl -w net.ipv4.conf.default.accept_redirects=0
        sysctl -w net.ipv4.route.flush=1

        sysctl -w net.ipv6.conf.all.accept_redirects=0
        sysctl -w net.ipv6.conf.default.accept_redirects=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-secure-icmp-redirects-are-not-accepted
    title: Ensure secure ICMP redirects are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.secure_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.secure_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.secure_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.secure_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject secure ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.secure_redirects` and `net.ipv4.conf.default.secure_redirects` are set to `0`.

        **Why this matters**

        Secure ICMP redirects are a variant of ICMP redirect messages that are accepted only from gateways listed in the system's default gateway table. While they are intended to provide safer route optimization, accepting any form of redirect introduces risk by allowing remote influence over local routing decisions.

        If secure ICMP redirects are accepted:
          - An attacker controlling or spoofing a default gateway could influence traffic paths.
          - It increases the likelihood of man-in-the-middle attacks by rerouting data through malicious intermediaries.
          - It undermines the reliability of static routing configurations and may conflict with security controls or monitoring systems.

        Disabling acceptance of secure ICMP redirects ensures that routing updates are not accepted dynamically from potentially compromised gateways. This strengthens network security by enforcing a more predictable and tightly controlled routing posture.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.secure_redirects = 0
        net.ipv4.conf.default.secure_redirects = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.secure_redirects=0
        sysctl -w net.ipv4.conf.default.secure_redirects=0
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-suspicious-packets-are-logged
    title: Ensure suspicious packets are logged
    impact: 60
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.log_martians'] == 1
      kernel.parameters['net.ipv4.conf.default.log_martians'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to log suspicious or malformed packets by ensuring the kernel parameters `net.ipv4.conf.all.log_martians` and `net.ipv4.conf.default.log_martians` are set to `1`.

        **Why this matters**

        Martian packets are packets with impossible or invalid source addresses, such as those that should not appear on the public internet or within specific segments of a private network. Logging these packets helps administrators detect potential misconfigurations or malicious activity, such as spoofed traffic or scanning attempts.

        If logging of suspicious packets is not enabled:
          - Unusual or invalid network traffic may go undetected, reducing visibility into potential reconnaissance or attack attempts.
          - Misconfigured hosts or routing issues may persist without notice, leading to degraded performance or security gaps.
          - Incident response and forensic analysis capabilities are weakened due to lack of log data.

        Enabling logging for martian packets provides valuable insights into unusual traffic patterns and supports early detection of threats or misconfigurations. This improves network observability and supports a proactive security posture.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` or in /etc/ufw/sysctl.conf file:

        ```
        net.ipv4.conf.all.log_martians = 1
        net.ipv4.conf.default.log_martians = 1
        ```

        Hint: If you're using Ubuntu's UFW, please check the for the above configuration in the file /etc/ufw/sysctl.conf in addition, because these settings will overwrite the kernel parameters on UFW startup.

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.log_martians=1
        sysctl -w net.ipv4.conf.default.log_martians=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-broadcast-icmp-requests-are-ignored
    title: Ensure broadcast ICMP requests are ignored
    impact: 60
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.icmp_echo_ignore_broadcasts'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to ignore ICMP echo requests sent to broadcast or multicast addresses by ensuring the kernel parameter `net.ipv4.icmp_echo_ignore_broadcasts` is set to `1`.

        **Why this matters**

        ICMP echo requests sent to broadcast addresses can be used in amplification attacks, such as the Smurf attack, where a single ICMP request can generate a large volume of responses from multiple hosts. This can lead to denial-of-service conditions for targeted systems or network segments.

        If broadcast ICMP requests are not ignored:
          - The system may be exploited as part of a distributed denial-of-service (DDoS) attack.
          - Network resources may be consumed by processing and responding to unnecessary or malicious requests.
          - Attackers can use broadcast ICMP traffic to map networks or identify live hosts.

        Ignoring broadcast ICMP requests reduces the likelihood that the system can be leveraged in amplification attacks and helps maintain the integrity and availability of the network. This is particularly important in environments where network resources are limited or where systems are exposed to untrusted networks.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.icmp_echo_ignore_broadcasts = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-bogus-icmp-responses-are-ignored
    title: Ensure bogus ICMP responses are ignored
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.icmp_ignore_bogus_error_responses'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to ignore bogus ICMP error responses by ensuring the kernel parameter `net.ipv4.icmp_ignore_bogus_error_responses` is set to `1`.

        **Why this matters**

        Bogus ICMP error responses are non-compliant or malformed ICMP messages that do not correspond to any legitimate traffic. These can be generated accidentally by misconfigured devices or intentionally by attackers attempting to disrupt or confuse network communications.

        If bogus ICMP responses are not ignored:
          - The system may log unnecessary or misleading error messages, cluttering logs and making it harder to identify real issues.
          - Attackers may exploit this setting to flood logs or trigger unstable behavior in poorly configured systems.
          - It may lead to resource exhaustion or degradation of network performance in environments with high volumes of invalid traffic.

        By ignoring bogus ICMP error responses, the system avoids reacting to malformed or irrelevant network messages, helping to maintain cleaner logs and more stable network operations.
      remediation: |-
        Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.icmp_ignore_bogus_error_responses = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-reverse-path-filtering-is-enabled
    title: Ensure Reverse Path Filtering is enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.rp_filter'] == 1
      kernel.parameters['net.ipv4.conf.default.rp_filter'] == 1
    docs:
      desc: |
        This check verifies that reverse path filtering is active by ensuring the kernel parameters `net.ipv4.conf.all.rp_filter` and `net.ipv4.conf.default.rp_filter` are set to `1`.

        **Why this matters**

        Reverse Path Filtering is a security mechanism that helps prevent IP spoofing by verifying that the source of a packet has a valid route back to the receiving interface. If a packet arrives on an interface and the system would not use that same interface to reach the source IP, the packet is dropped.

        If reverse path filtering is not enabled:
          - Spoofed packets with forged source addresses may be accepted, allowing attackers to bypass basic network controls.
          - Systems may become vulnerable to reflection and amplification attacks.
          - It undermines the reliability of source-based filtering and complicates network traffic analysis.

        Enabling reverse path filtering ensures the system performs sanity checks on incoming traffic, which helps prevent IP spoofing and enhances the integrity of network communications. It is an important safeguard in both perimeter and internal network environments.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.rp_filter = 1
        net.ipv4.conf.default.rp_filter = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.rp_filter=1
        sysctl -w net.ipv4.conf.default.rp_filter=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-tcp-syn-cookies-is-enabled
    title: Ensure TCP SYN Cookies is enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.tcp_syncookies'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to use TCP SYN cookies by ensuring the kernel parameter `net.ipv4.tcp_syncookies` is set to `1`.

        **Why this matters**

        TCP SYN cookies are a defense mechanism against SYN flood attacks, a type of denial-of-service (DoS) attack where an attacker sends a large number of TCP connection requests without completing the handshake. This consumes server resources and can prevent legitimate users from establishing connections.

        When SYN cookies are enabled:
          - The system avoids allocating memory for incomplete TCP handshakes by encoding connection information into the TCP sequence number.
          - It allows the server to continue responding to new connection requests even when the SYN backlog is full.
          - It helps maintain availability and resilience under high connection request loads or malicious activity.

        Without SYN cookies, systems are more susceptible to resource exhaustion during a SYN flood. Enabling this feature strengthens the host's ability to withstand network-based denial-of-service attempts and helps ensure reliable TCP service availability.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.tcp_syncookies = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.tcp_syncookies=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-ipv6-router-advertisements-are-not-accepted
    title: Ensure IPv6 router advertisements are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv6.conf.all.accept_ra'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_ra'] == null
      kernel.parameters['net.ipv6.conf.default.accept_ra'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_ra'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject IPv6 router advertisements by ensuring the kernel parameters `net.ipv6.conf.all.accept_ra` and `net.ipv6.conf.default.accept_ra` are set to `0`.

        **Why this matters**

        IPv6 router advertisements (RAs) are used by routers to inform hosts about network configuration settings, such as default gateways and prefix information. While useful in dynamic network environments, accepting unsolicited RAs on systems that are not mobile or router-dependent can introduce security risks.

        If IPv6 router advertisements are accepted:
          - Malicious or misconfigured devices on the network could inject rogue RAs, redirecting traffic or altering host routing tables.
          - Attackers could exploit this to perform man-in-the-middle attacks, traffic interception, or denial-of-service.
          - It undermines predictable network configuration and may conflict with security policies that rely on static or managed routing.

        Disabling acceptance of IPv6 router advertisements helps ensure that routing configuration is controlled explicitly, reducing the likelihood of unauthorized or harmful route changes on the host.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv6.conf.all.accept_ra = 0
        net.ipv6.conf.default.accept_ra = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv6.conf.all.accept_ra=0
        sysctl -w net.ipv6.conf.default.accept_ra=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-auditd-is-installed-and-running
    title: Ensure auditd is installed, enabled, and running
    impact: 50
    mql: |
      package("auditd").installed && package("audispd-plugins").installed
      || package("audit").installed || package("audit-libs").installed
      service("auditd").enabled
      service("auditd").running
    docs:
      desc: |
        This check verifies that the auditd package is installed on the system and that the auditd service is both enabled and running.

        **Why this matters**

        auditd is the core component of the Linux Auditing System, responsible for collecting, processing, and writing audit records to disk. These records provide detailed visibility into system-level activities such as user logins, file access, command execution, and permission changes.

        Ensuring that auditd is installed and actively running is essential for:
          - Capturing a reliable audit trail of security-relevant events.
          - Supporting forensic investigations and incident response efforts.
          - Meeting regulatory and organizational compliance requirements that mandate audit logging.
          - Detecting suspicious or unauthorized behavior on the system in near real time.

        If auditd is not installed, or if the service is disabled or inactive:
          - No audit logs will be recorded, creating blind spots in system monitoring.
          - Critical evidence may be lost during or after an attack.
          - The system may fall out of compliance with standards that require audit functionality.

        By installing and enabling auditd, organizations ensure consistent audit logging is in place, improving accountability and strengthening overall system security.
      remediation: |-
        ### Install auditd

        **RHEL/Fedora/Amazon Linux and derivatives**

        ```bash
        dnf install audit audit-libs
        ```

        **Debian/Ubuntu and derivatives**

        ```bash
        apt-get install auditd audispd-plugins
        ```

        **SLES and openSUSE**

        ```bash
        zypper install audit
        ```

        ### Enable auditd

        ```bash
        systemctl --now enable auditd
        ```
  - uid: mondoo-linux-security-auditing-for-processes-that-start-prior-to-auditd-is-enabled
    title: Ensure auditing for processes that start prior to auditd is enabled
    impact: 50
    mql: |
      switch {
        case file("/boot/grub2/grubenv").exists:
          file("/boot/grub2/grubenv").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub2/grub.cfg").exists:
          file("/boot/grub2/grub.cfg").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub/grub.cfg").exists:
          file("/boot/grub/grub.cfg").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub/grub.conf").exists:
          file("/boot/grub/grub.conf").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/etc/secboot/config.json").exists:
          parse.json('/etc/secboot/config.json')
            .params['kernel-params'] == /audit(\s+)?\=(\s+)?1/;
        default: false
      }
    docs:
      desc: |
        This check verifies that the system's GRUB bootloader is configured to pass the audit=1 kernel parameter, which ensures that auditing is enabled from the earliest stages of system initialization—even before the auditd daemon starts.

        **Why this matters**

        By default, some processes may start before auditd is initialized, especially during early boot. Without early auditing enabled, actions taken by these processes can go unrecorded, creating a blind spot in audit logs and weakening the system's ability to track critical events.

        If the audit=1 kernel parameter is not set:
          - Early-boot processes such as init systems, kernel modules, or startup scripts may execute without being logged.
          - Attackers or misconfigurations could exploit this window to perform actions undetected.
          - The system's audit trail may be incomplete, undermining trust in audit data and complicating incident response or compliance reviews.

        Adding audit=1 to the GRUB configuration ensures that the Linux kernel begins generating audit records as soon as it starts, capturing all auditable activity regardless of when auditd is fully initialized. This enhances the completeness and integrity of audit logging across the system lifecycle.
      remediation: |-
        Edit `/etc/default/grub` and add `audit=1` to `GRUB_CMDLINE_LINUX`:

        ```
        GRUB_CMDLINE_LINUX="audit=1"
        ```

        Run this command to update the `grub2` configuration:

        ### RHEL/Fedora/Amazon Linux and derivatives

        For BIOS systems:

        ```bash
        grub2-mkconfig -o /boot/grub2/grub.cfg
        ```

        For UEFI systems:

        ```bash
        grub2-mkconfig -o /boot/efi/EFI/<distribution>/grub.cfg
        ```

        Replace `<distribution>` with your distribution's directory name (e.g., `centos`, `redhat`, `fedora`).

        ### Debian/Ubuntu and derivatives

        ```bash
        update-grub
        ```
  - uid: mondoo-linux-security-audit-log-storage-size-is-configured
    title: Ensure audit log storage size is configured
    impact: 40
    mql: |
      file("/etc/audit/auditd.conf").exists
      auditd.config.params.contains("max_log_file")
      auditd.config.params.max_log_file != 0
    docs:
      desc: |
        This check verifies that the auditd configuration specifies a maximum storage size for audit logs by ensuring the `max_log_file` parameter in `/etc/audit/auditd.conf` is set to a value greater than zero.

        **Why this matters**

        The `max_log_file` setting defines the maximum size (in megabytes) that an audit log file can grow before it is rotated. Without this limit, audit logs can consume excessive disk space, leading to system performance degradation or failures—especially on systems with limited storage or extensive auditing.

        If audit log size is not properly configured:
          - Log files may grow indefinitely and fill the disk, potentially causing services to fail or the system to become unresponsive.
          - Critical audit data may be lost if the system cannot write to a full disk.
          - Administrators may be unaware of abnormal log volume trends, missing opportunities for early detection of suspicious activity.

        Configuring max_log_file helps maintain system stability by preventing uncontrolled log growth. It also supports log management practices such as automated rotation and retention policies, ensuring that audit data remains available without jeopardizing system operations.
      remediation: |-
        Set the following parameter in `/etc/audit/auditd.conf` in accordance with site policy:

        ```
        max_log_file = <MB>
        ```

        Restart the service to load the new configuration values:

        ```bash
        service auditd reload
        ```
  - uid: mondoo-linux-security-audit-logs-are-not-automatically-deleted
    title: Ensure audit logs are not automatically deleted
    impact: 40
    mql: |
      file("/etc/audit/auditd.conf").exists
      auditd.config.params.max_log_file_action == "keep_logs"
    docs:
      desc: |
        This check verifies that the system is configured to retain audit logs by ensuring the `max_log_file_action` parameter in `/etc/audit/auditd.conf`` is set to `keep_logs`.

        **Why this matters**

        The `max_log_file_action` setting controls how auditd behaves when an audit log file reaches its maximum size. Setting it to keep_logs ensures that old logs are preserved rather than deleted or overwritten, supporting long-term retention and forensic traceability.

        If audit logs are automatically deleted:
          - Critical historical data may be lost, undermining the ability to investigate past events or security incidents.
          - Organizations may fall out of compliance with regulatory requirements that mandate audit log retention.
          - Incident response efforts may be hindered by incomplete log records.

        By configuring auditd to preserve logs, the system ensures that valuable audit data is available when needed for security analysis, compliance reviews, or legal investigation. This supports a more robust and accountable auditing strategy.
      remediation: |-
        Set the following parameter in `/etc/audit/auditd.conf`:

        ```
        max_log_file_action = keep_logs
        ```

        Restart the service to load the new configuration values:

        ```bash
        service auditd reload
        ```
  - uid: mondoo-linux-security-system-is-disabled-when-audit-logs-are-full
    title: Ensure system is disabled when audit logs are full
    impact: 40
    filters: |
      asset.kind != "container-image"
    mql: |
      file("/etc/audit/auditd.conf").exists
      auditd.config.params.space_left_action == /email|exec|single|halt/
      auditd.config.params.action_mail_acct == "root"
      auditd.config.params.admin_space_left_action == /halt|single/
    docs:
      desc: |
        This check verifies that the system is configured to disable itself when audit logs are full by ensuring the `space_left_action` and `admin_space_left_action` parameters in `/etc/audit/auditd.conf` are set to appropriate values.

        **Why this matters**

        The `space_left_action` setting determines what action auditd takes when disk space for audit logs is low. The `admin_space_left_action` setting specifies the action when space is critically low. Setting these to halt or single ensures that the system does not continue operating with potentially compromised logging capabilities.

        If the system does not disable itself when audit logs are full:
          - Crucial audit data may be lost, leading to gaps in security monitoring.
          - The system may continue to operate without proper oversight, increasing the risk of undetected malicious activity.
          - Compliance with regulatory requirements for audit logging may be jeopardized.

        Configuring these parameters helps ensure that the system maintains a secure state and that audit logging remains functional, even under adverse conditions.
      remediation: |-
        Set the following parameters in `/etc/audit/auditd.conf`:

        ```
        space_left_action = email
        action_mail_acct = root
        admin_space_left_action = halt
        ```

        Restart the service to load the new configuration values:

        ```bash
        service auditd reload
        ```
  - uid: mondoo-linux-security-changes-to-system-administration-scope-sudoers-is-collected
    title: Ensure changes to system administration scope (sudoers) is collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/sudoers\.d(\/?)\s+\-p\s+wa\s+\-k\s+scope(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/sudoers(\/?)\s+\-p\s+wa\s+\-k\s+scope(\s+)?$/))
    docs:
      desc: |
        This check verifies that auditd is configured to monitor changes to the system administration scope (sudoers). The parameters below track changes to files associated with sudoers.

        - The file `/etc/sudoers` is the main configuration file for sudo.
        - The `/etc/sudoers.d/` directory contains additional configuration files for sudo.

        **Why this matters**

        Monitoring changes to the sudoers file and its associated directory is critical for maintaining system security. Unauthorized modifications can lead to privilege escalation, unauthorized access, or other malicious activities.

        If monitoring is not enabled:
          - Changes to sudo permissions may go undetected, allowing unauthorized users to gain elevated privileges.
          - It becomes difficult to track who made changes and when, complicating incident response efforts.
          - The system may fall out of compliance with security policies or regulatory requirements.

        By ensuring that changes to the sudoers file and directory are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI***

            Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

            Example: `vi /etc/audit/rules.d/50-scope.rules`

            Add the following lines:

            ```
            -w /etc/sudoers -p wa -k scope
            -w /etc/sudoers.d -p wa -k scope
            ```

            To load the newly added rules into the running configuration:

            ```bash
            augenrules --load
            ```

            This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

            Check if a reboot is required, in case the running configuration is set to be immutable:

            ```bash
            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
            ```
  - uid: mondoo-linux-security-login-and-logout-events-are-collected
    title: Ensure login and logout events are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    variants:
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-debian
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-rhel
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-other
    docs:
      desc: |
        This check verifies that auditd is configured to monitor login and logout events. The parameters in this section track changes to the files associated with login and logout events. The file `/var/log/lastlog` tracks the last login of each user. The file `/var/log/tallylog` tracks failed login attempts. The file `/var/run/faillock` is used by the `pam_faillock` module to track failed authentication attempts. All audit records will be tagged with the identifier "logins."

        **Why this matters**

        Monitoring login and logout events is critical for maintaining system security. Unauthorized access attempts or successful logins by malicious actors can lead to data breaches, privilege escalation, or other security incidents.

        If monitoring is not enabled:
          - Unauthorized login attempts may go undetected, allowing attackers to gain access to the system.
          - Legitimate user activity may be obscured, complicating incident response efforts.
          - The system may fall out of compliance with security policies or regulatory requirements.

        By ensuring that login and logout events are monitored, organizations can maintain a secure environment and quickly respond to potential threats. This is particularly important in environments with sensitive data or critical infrastructure.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-logins.rules`

        Add the following lines:

        ```
        -w /var/log/lastlog -p wa -k logins
        -w /var/log/tallylog -p wa -k logins
        ```

        Add the following additional line for Debian/Ubuntu based systems:

        ```
        -w /var/log/faillog -p wa -k logins
        ```

        Add the following additional line for Red Hat/Fedora/Amazon Linux based systems:

        ```
        -w /var/run/faillock -p wa -k logins
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-debian
    filters: asset.family.contains("debian")
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/faillog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/log\/faillog|\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-rhel
    filters: asset.family.contains("redhat") || asset.platform == "amazonlinux"
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/run\/faillock/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/run\/faillock|\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-other
    filters: asset.family.contains(/redhat|debian/) == false && asset.platform != "amazonlinux"
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-session-initiation-information-is-collected
    title: Ensure session initiation information is collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/run\/utmp\s+\-p\s+wa\s+\-k\s+session(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/wtmp\s+\-p\s+wa\s+\-k\s+(logins|session)(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/btmp\s+\-p\s+wa\s+\-k\s+(logins|session)(\s+)?$/))
    docs:
      desc: |
        This check verifies that the system is configured to record session start events in the audit logs, ensuring that audit rules are in place to track successful login sessions using the auditd subsystem.

        **Why this matters**

        Capturing session initiation information—such as user logins and terminal access—is essential for establishing a complete record of user activity. These events mark the beginning of user interactions with the system and provide vital context for analyzing subsequent actions.

        If session initiation is not logged:
          •	User activity cannot be reliably correlated to specific sessions, weakening audit trails.
          •	Security incidents such as unauthorized access or lateral movement may go undetected.
          •	Compliance with security standards and regulatory frameworks that require session logging may be compromised.

        By ensuring session start events are audited, organizations gain visibility into who accessed the system and when, supporting effective monitoring, incident investigation, and user accountability. This forms a foundational element of audit-based security controls.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-session.rules`

        Add the following lines:

        ```
        -w /var/run/utmp -p wa -k session
        -w /var/log/wtmp -p wa -k logins
        -w /var/log/btmp -p wa -k logins
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-date-and-time-information-are-collected
    title: Ensure events that modify date and time information are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /settimeofday/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /clock_settime/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /adjtimex/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /settimeofday|clock_settime|adjtimex/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-F", "key=time-change"])
            || split(" ").containsAll(["-k", "time-change"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(/\/etc\/localtime/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(/\/etc\/localtime/).all(
        split("-").containsAll(["w /etc/localtime ","p wa ",])
          && split(" ").containsAll(["-F", "key=time-change"])
            || split(" ").containsAll(["-k", "time-change"])
      )
    docs:
      desc: |
        This check verifies that the audit system is configured to log all events that change the system’s date and time settings, including modifications to the system clock and timezone.

        **Why this matters**

        Accurate system time is critical for security auditing, log correlation, and incident investigation. If an attacker or unauthorized user alters the system time, it can obscure malicious activity, disrupt monitoring tools, and compromise the integrity of audit logs.

        If changes to date and time settings are not audited:
          •	Malicious modifications may go unnoticed, allowing attackers to hide their tracks.
          •	Log timestamps may become unreliable, complicating forensic analysis.
          •	Compliance with standards that require time synchronization and audit log integrity may be violated.

        By auditing all date and time modifications, administrators can detect tampering attempts, verify system integrity, and maintain a trustworthy timeline of system events. This ensures that audit logs remain a reliable source of truth during security reviews and investigations.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`_

        Example: `vi /etc/audit/rules.d/50-time_change.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
        -a always,exit -F arch=b32 -S clock_settime -k time-change
        -w /etc/localtime -p wa -k time-change
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-time_change.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
        -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
        -a always,exit -F arch=b64 -S clock_settime -k time-change
        -a always,exit -F arch=b32 -S clock_settime -k time-change
        -w /etc/localtime -p wa -k time-change
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-mandatory-access-controls-are-collected
    title: Ensure events that modify the system's Mandatory Access Controls are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      appArmorSys = props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/apparmor(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
        && props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/apparmor.d(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
      seLinuxSys = props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/selinux(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
       && props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/usr\/share\/selinux(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
      appArmorSys || seLinuxSys
    docs:
      desc: |
        This check verifies that the audit system is configured to log changes to the system’s Mandatory Access Control (MAC) configurations, such as modifications to SELinux or AppArmor policies.

        **Why this matters**

        Mandatory Access Controls enforce strict rules about which subjects (users, processes) can access which objects (files, resources) beyond traditional discretionary permissions. Changes to MAC settings directly impact the system’s security posture and can either strengthen or weaken its defenses.

        When modifications to MAC configurations are not audited:
          - Unauthorized or malicious changes may go undetected, potentially disabling key security mechanisms.
          - Administrators may be unaware of policy alterations that expose the system to privilege escalation or data leakage.
          - The system’s compliance with security frameworks requiring MAC enforcement may be compromised.

        Logging events that alter SELinux modes, AppArmor profiles, or related configuration files helps ensure that all security policy changes are tracked and attributable. This supports continuous monitoring, strengthens control over access enforcement, and enhances trust in the system’s security model.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-MAC_policy.rules`

        Add the following lines, for SELinux:

        ```
        -w /etc/selinux/ -p wa -k MAC-policy
        -w /usr/share/selinux/ -p wa -k MAC-policy
        ```

        Add the following lines, for AppArmor:

        ```
        -w /etc/apparmor/ -p wa -k MAC-policy
        -w /etc/apparmor.d/ -p wa -k MAC-policy
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected
    title: Ensure events that modify the system's network environment are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    variants:
    - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-debian-rhel
    - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-other
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-debian-rhel
    filters: asset.family.contains(/redhat|debian/) == true
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /sethostname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setdomainname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /sethostname|setdomainname/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue.net/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/hosts/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/sysconfig\/network/)
        || props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/network/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/etc\/issue|\/etc\/issue.net|\/etc\/hosts|\/etc\/sysconfig\/network|\/etc\/network/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-other
    filters: asset.family.contains(/redhat|debian/) == false
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /sethostname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setdomainname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /sethostname|setdomainname/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue.net/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/hosts/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/etc\/issue|\/etc\/issue.net|\/etc\/hosts/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
    docs:
      desc: |
        This check verifies that the audit system is configured to record changes to key network configuration files and system identity settings by monitoring specific system calls and file paths.

        **Why this matters**

        Changes to the system's hostname, domain name, or core network-related files can alter how the system identifies itself and interacts with other hosts. These modifications may indicate reconfiguration, misconfiguration, or unauthorized tampering.

        If these events are not audited:
          •	Changes to system identity (via sethostname or setdomainname) may go untracked, affecting asset management and security visibility.
          •	Modifications to files like `/etc/hosts`, `/etc/issue`, or `/etc/sysconfig/network` could enable social engineering, redirect network traffic, or disrupt connectivity.
          •	Attackers may exploit these files to mask their activity or persist on the system.

        By auditing the sethostname and setdomainname system calls and monitoring changes to `/etc/issue`, `/etc/issue.net`, `/etc/hosts`, and `/etc/sysconfig/network`, administrators can detect critical network and identity changes. This supports system integrity, operational consistency, and incident investigation efforts.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-system_local.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale
        -w /etc/issue -p wa -k system-locale
        -w /etc/issue.net -p wa -k system-locale
        -w /etc/hosts -p wa -k system-locale
        ```

        Add the following line on Red Hat based systems:

        ```
        -w /etc/sysconfig/network -p wa -k system-locale
        ```

        Add the following line for Debian/Ubuntu based systems:

        ```
        -w /etc/network -p wa -k system-locale
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-system_local.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
        -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale

        -w /etc/issue -p wa -k system-locale
        -w /etc/issue.net -p wa -k system-locale
        -w /etc/hosts -p wa -k system-locale
        ```

        Add the following line for Red Hat based systems:

        ```
        -w /etc/sysconfig/network -p wa -k system-locale
        ```

        Add the following line for Debian/Ubuntu based systems:

        ```
        -w /etc/network -p wa -k system-locale
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-discretionary-access-control-permission-modification-events-are-collected
    title: Ensure discretionary access control permission modification events are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /chmod/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchmod/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchmodat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /chown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchownat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lchown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lsetxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fsetxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /removexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lremovexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fremovexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /chmod|fchmod|fchmodat|chown|fchown|fchownat|lchown|setxattr|lsetxattr|fsetxattr|removexattr|lremovexattr|fremovexattr/).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F key=perm_mod"])
            || split("-").containsAll(["k perm_mod"])
      )
    docs:
      desc: |
        This check verifies that changes to file permissions, attributes, ownership, and group are monitored. It ensures that system calls affecting these properties—such as `chmod`, `fchmod`, `fchmodat` (permissions), `chown`, `fchown`, `fchownat`, `lchown` (ownership), and `setxattr`, `lsetxattr`, `fsetxattr`, `removexattr`, `lremovexattr`, `fremovexattr` (extended attributes)—are audited.

        **Why this matters**

        Monitoring changes to file permissions and attributes is critical for maintaining system security. Unauthorized or accidental modifications can lead to privilege escalation, data leakage, or system compromise.

        If these events are not audited:
          - Changes to critical files may go undetected, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - Compliance with security standards requiring audit logging may be compromised.

        By auditing these system calls, administrators can detect and respond to unauthorized changes, ensuring the integrity of file permissions and attributes.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-perm_mod.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-perm_mod.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-unsuccessful-unauthorized-file-access-attempts-are-collected
    title: Ensure unsuccessful unauthorized file access attempts are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / creat /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / open /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / openat /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / truncate /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / ftruncate /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == / creat | open | openat | truncate | ftruncate /).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F exit=","EPERM "])
            || split("-").containsAll(["F exit=","EACCES "])
          && split("-").containsAll(["F key=access"])
            || split("-").containsAll(["k access"])
            || split("-").containsAll(["F key=perm_mod"])
            || split("-").containsAll(["k perm_mod"])
      )
    docs:
      desc: |
        This check verifies that the system is configured to monitor unsuccessful attempts to access files by auditing system calls such as `creat`, `open`, `openat`, `truncate`, and `ftruncate`. These system calls control the creation, opening, and truncation of files. The audit log will record events where the user is a non-privileged user (auid >= 1000), is not a daemon event (auid=4294967295), and the system call returned EACCES (permission denied) or EPERM (operation not permitted). All audit records will be tagged with the identifier "access."

        **Why this matters**

        Monitoring unsuccessful file access attempts helps detect potential unauthorized access or misconfigurations. It provides visibility into failed attempts to create, open, or modify files, which may indicate malicious activity or user errors.

        If these events are not audited:
          - Unauthorized access attempts may go unnoticed, increasing the risk of data breaches.
          - Misconfigurations or permission issues may persist without detection.
          - The system may fall out of compliance with security standards requiring audit logging.

        By auditing these system calls, administrators can identify and respond to unauthorized access attempts, ensuring the integrity and security of the system.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-access.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-access.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-usergroup-information-are-collected
    title: Ensure events that modify user/group information are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/group\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/passwd\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/gshadow\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/shadow\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/security\/opasswd\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
    docs:
      desc: |
        This check verifies that the system is configured to monitor changes to critical user and group management files, including `/etc/group`, `/etc/passwd`, `/etc/shadow`, `/etc/gshadow`, and `/etc/security/opasswd`. These files store information about user accounts, group memberships, and password policies.

        **Why this matters**

        Monitoring changes to these files is essential for maintaining system security. Unauthorized modifications can lead to privilege escalation, unauthorized access, or other malicious activities.

        If monitoring is not enabled:
          - Changes to user or group configurations may go undetected, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - The system may fall out of compliance with security standards requiring audit logging.

        By ensuring that changes to these critical files are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-identity.rules`

        Add the following lines:

        ```
        -w /etc/group -p wa -k identity
        -w /etc/passwd -p wa -k identity
        -w /etc/gshadow -p wa -k identity
        -w /etc/shadow -p wa -k identity
        -w /etc/security/opasswd -p wa -k identity
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-successful-file-system-mounts-are-collected
    title: Ensure successful file system mounts are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always\,exit\s+\-F\s+arch\=b64\s+\-S\s+mount\s+\-F\s+auid\>\=1000\s+\-F\s+auid\!\=(4294967295|unset|-1)\s+\-k\s+mounts(\s+)?$/)) || props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always\,exit\s+\-F\s+arch\=b32\s+\-S\s+mount\s+\-F\s+auid\>\=1000\s+\-F\s+auid\!\=(4294967295|unset|-1)\s+\-k\s+mounts(\s+)?$/))
    docs:
      desc: |
        This check verifies that the system is configured to monitor successful file system mount events by auditing the `mount` system call. The audit log will record events where the user is a non-privileged user (auid >= 1000) and is not a daemon event (auid=4294967295). All audit records will be tagged with the identifier "mounts."

        **Why this matters**

        Monitoring successful file system mounts is critical for maintaining system security. Unauthorized or unexpected mounts can lead to data leakage, privilege escalation, or other malicious activities.

        If these events are not audited:
          - Unauthorized mounts may go unnoticed, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - The system may fall out of compliance with security standards requiring audit logging.

        By ensuring that successful file system mount events are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-mounts.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-mounts.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
        -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-file-deletion-events-by-users-are-collected
    title: Ensure file deletion events by users are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /unlink/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /rename/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /unlinkat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /renameat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /unlink|rename|unlinkat|renameat/).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F key=delete"])
            || split("-").containsAll(["k delete"])
      )
    docs:
      desc: |
        This check ensures that the system is configured to monitor the use of system calls associated with the deletion or renaming of files and file attributes. It verifies that the `unlink`, `unlinkat`, `rename`, and `renameat` system calls are audited, which helps track file deletions and renames.

        **Why this matters**

        Monitoring file deletion and renaming events is critical for maintaining system security and integrity. If these events are not audited:
          - Unauthorized file deletions or renames may go unnoticed, leading to data loss or tampering.
          - Malicious actors could exploit this lack of visibility to hide their tracks or disrupt system operations.
          - Compliance with security standards requiring audit logging may be compromised.

        Auditing these system calls ensures that all file deletion and renaming activities are logged, providing visibility into potential security incidents and supporting forensic investigations.

        **Note:**
        Systems may have been customized to change the default UID_MIN. To confirm the UID_MIN for your system, run this command:

        ```bash
        awk '/^\s*UID_MIN/{print $2}' /etc/login.defs
        ```

        If your system's UID_MIN is not `1000`, replace `auid>=1000` with `auid>=<UID_MIN for your system>` in the audit and remediation procedures.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-deletion.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-deletion.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
        -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-kernel-module-loading-and-unloading-is-collected
    title: Ensure kernel module loading and unloading is collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/insmod\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/rmmod\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/modprobe\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always,exit\s+\-F\s+arch\=b64\s+\-S\s+init\_module\s+\-S\s+delete\_module\s+\-k\s+modules(\s+)?$/)) || props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always,exit\s+\-F\s+arch\=b32\s+\-S\s+init\_module\s+\-S\s+delete\_module\s+\-k\s+modules(\s+)?$/))
    docs:
      desc: |
        This check verifies that the loading and unloading of kernel modules is monitored by auditing the execution of related programs and system calls, such as `insmod`, `rmmod`, `modprobe`, `init_module`, and `delete_module`.

        **Why this matters**

        Kernel modules extend the functionality of the Linux kernel by adding features such as device drivers or file systems. Monitoring the loading and unloading of kernel modules is critical for maintaining system security and integrity. If these events are not audited:
          - Unauthorized or malicious modules could be loaded, compromising the system's security.
          - Attackers could use kernel modules to hide malicious activities or escalate privileges.
          - System administrators may lack visibility into critical changes to the kernel's behavior.

        By auditing the execution of module-related programs and system calls, organizations can detect and respond to unauthorized changes, ensuring the integrity and security of the kernel.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-modules.rules`

        Add the following lines:

        ```
        -w /sbin/insmod -p x -k modules
        -w /sbin/rmmod -p x -k modules
        -w /sbin/modprobe -p x -k modules
        -a always,exit -F arch=b32 -S init_module -S delete_module -k modules
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-modules.rules`

        Add the following lines:

        ```
        -w /sbin/insmod -p x -k modules
        -w /sbin/rmmod -p x -k modules
        -w /sbin/modprobe -p x -k modules
        -a always,exit -F arch=b64 -S init_module -S delete_module -k modules
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-system-administrator-actions-sudolog-are-collected
    title: Ensure system administrator actions (sudolog) are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/sudo\.log\s+\-p\s+wa\s+\-k\s+actions(\s+)?$/))
    docs:
      desc: |
        This check ensures that the `sudo` log file is monitored to track all privileged commands executed by administrators. Properly configured systems disable the use of the `su` command, requiring administrators to log in and use `sudo` for privileged actions. This setup ensures that all administrator commands are logged to `/var/log/sudo.log`.

        **Why this matters**

        Monitoring the `sudo` log file provides visibility into administrative actions, ensuring accountability and enhancing security. If the `sudo` log file is not monitored:
          - Unauthorized or malicious actions by administrators may go undetected.
          - Critical audit trails may be incomplete, complicating incident response and forensic investigations.
          - Compliance with security policies requiring detailed logging of administrative actions may be compromised.

        By monitoring the `sudo` log file, organizations can ensure that all privileged commands are logged, supporting accountability, security, and compliance efforts.
      remediation: |
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules` and add the following line:

        ```
        -w <Path to sudo log file> -p wa -k actions
        ```

        Example: `vi /etc/audit/rules.d/actions.rules`

        and add the following line:

        ```
        -w /var/log/sudo.log -p wa -k actions
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-the-audit-configuration-is-immutable
    title: Ensure the audit configuration is immutable
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/(\s+)?\-e\s+2(\s+)?$/))
    docs:
      desc: |
        This check ensures that the audit system is configured to operate in immutable mode by setting the `-e 2` flag. Immutable mode prevents any modifications to audit rules using `auditctl`, ensuring that audit configurations remain secure and consistent.

        **Why this matters**

        Immutable mode is a critical security feature for the audit system:
          - It prevents unauthorized or accidental changes to audit rules, maintaining the integrity of audit logs.
          - It ensures that audit configurations cannot be tampered with during runtime, reducing the risk of malicious activity going undetected.
          - It supports compliance with security standards that require robust and unalterable audit logging mechanisms.

        Once the audit system is set to immutable mode, changes to audit rules can only be made by rebooting the system, providing an additional layer of protection against unauthorized modifications.
      remediation: |-
        Edit or create the file `/etc/audit/audit.rules` and add the following line at the end of the file:

        ```
        -e 2
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-sudo-logging-is-enabled
    title: Ensure sudo logging is enabled
    impact: 80
    props:
      - uid: mondooLinuxSecuritySudoersFiles
        title: Return the files from /etc/sudoers.d
        mql: |
          sudoersFiles = files.find(from: "/etc/sudoers.d/", type: 'file').list.map(path) + ["/etc/sudoers"]
          return sudoersFiles.map(file(_).content.lines.where(_ == /^[^#]/)).flat
    mql: |
      props.mondooLinuxSecuritySudoersFiles
        .where(_ == /Defaults/)
        .any(_ == /logfile=\"\/var\/log\/sudo\.log\"/)
    docs:
      desc: |
        This check ensures that sudo logs all events to a dedicated log file instead of the default `/var/log/auth.log` file, which contains all authentication events system-wide. Configuring a dedicated log file for sudo events improves the ability to audit and monitor sudo usage effectively.

        **Why this matters**

        By default, sudo logs are mixed with other authentication events in `/var/log/auth.log`, making it difficult to identify and analyze sudo-specific failures or activities. Without a dedicated log file:
          - Sudo failures may go unnoticed due to the volume of unrelated log entries.
          - Administrators may face challenges in auditing and investigating sudo usage.
          - Critical security events related to sudo may be obscured, increasing the risk of unauthorized access or privilege escalation.

        Configuring sudo to log to a dedicated file enhances visibility into sudo activities, supports effective auditing, and strengthens overall system security.
      remediation: |-
        Using the `visudo` command, add the following line to the `/etc/sudoers` configuration file.

        ```
        Defaults log_host, log_year, logfile="/var/log/sudo.log"
        ```
  - uid: mondoo-linux-security-permissions-on-etcsshsshd-config-are-configured
    title: Ensure secure permissions on /etc/ssh/sshd_config are set
    impact: 100
    mql: |
      file("/etc/ssh/sshd_config") {
        user.name == "root"
        group.name == "root"
        permissions.user_executable == false
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that the `/etc/ssh/sshd_config` file is secured with appropriate ownership and permissions. The file must be owned by the root user and group to prevent unauthorized modifications.

        **Why this matters**

        The `/etc/ssh/sshd_config` file contains critical configuration settings for the SSH daemon. If this file is improperly secured:
          - Unauthorized users could modify SSH settings, potentially compromising system security.
          - Malicious actors could weaken SSH configurations to allow unauthorized access or escalate privileges.
          - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `/etc/ssh/sshd_config` file is owned by the root user and group, organizations can protect critical SSH configurations and maintain a secure system configuration.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI***

            To set the ownership and permissions on `/etc/ssh/sshd_config`, run the following commands:

            ```bash
            chown root:root /etc/ssh/sshd_config
            chmod og-rwx /etc/ssh/sshd_config
            ```
        - id: ansible
          desc: |
            ***Using Ansible***

            To set the ownership and permissions on `/etc/ssh/sshd_config`, use the following Ansible playbook:

            ```yaml
            ---
            - name: Ensure correct ownership and permissions for sshd_config
              hosts: all
              become: yes
              tasks:
                - name: Set ownership of /etc/ssh/sshd_config to root:root
                  ansible.builtin.file:
                    path: /etc/ssh/sshd_config
                    owner: root
                    group: root

                - name: Remove read/write/execute permissions for group and others on sshd_config
                  ansible.builtin.file:
                    path: /etc/ssh/sshd_config
                    mode: '0600'
            ```
  - uid: mondoo-linux-security-rsyslog-is-installed-and-enabled
    title: Ensure rsyslog is installed
    impact: 50
    mql: |
      package("rsyslog").installed
      service("rsyslog").enabled
    docs:
      desc: |
        This check ensures that the `rsyslog` software is installed and enabled as a replacement for the original `syslogd` daemon, providing enhanced logging capabilities and security features.

        **Why this matters**

        `rsyslog` offers several improvements over `syslogd`, including:
          - Connection-oriented (i.e., TCP) transmission of logs, ensuring reliable delivery.
          - Support for logging to database formats, enabling advanced log analysis and storage.
          - Encryption of log data during transmission, protecting sensitive information from interception.

        By using `rsyslog`, organizations can enhance their logging infrastructure, improve log reliability and security, and meet compliance requirements for secure log management.
      remediation:
        - cli:
            desc: |
              ***Using the CLI***

              To install and enable `rsyslog`, run the following commands:

              ### RHEL/Fedora/Amazon Linux and derivatives

              ```bash
              yum install rsyslog
              systemctl --now enable rsyslog
              ```

              ### Debian/Ubuntu and derivatives

              ```bash
              apt-get install rsyslog
              systemctl --now enable rsyslog
              ```

              ### SLES and openSUSE

              ```bash
              zypper install rsyslog
              systemctl --now enable rsyslog
              ```
        - ansible:
            desc: |
              ***Using Ansible***

              To install and enable `rsyslog`, use the following Ansible playbook:

              ```yaml
              ---
              - name: Ensure rsyslog is installed and enabled
                hosts: all
                become: yes
                tasks:
                  - name: Install rsyslog
                    ansible.builtin.package:
                      name: rsyslog
                      state: present

                  - name: Enable and start rsyslog service
                    ansible.builtin.systemd:
                      name: rsyslog
                      enabled: yes
                      state: started
              ```
  - uid: mondoo-linux-security-rsyslog-default-file-permissions-configured
    title: Ensure rsyslog default file permissions configured
    impact: 60
    mql: |
      rsyslog.conf.settings.contains("$FileCreateMode 0640")
    docs:
      desc: |
        This check ensures that `rsyslog` is configured to apply appropriate permissions to newly created log files. This setting controls the default permissions for log files that do not already exist on the system.

        **Why this matters**

        Properly configured file permissions for log files are critical for maintaining system security:
          - Prevents unauthorized access to sensitive log data.
          - Ensures compliance with security policies and regulatory requirements.
          - Protects the integrity and confidentiality of log information.

        By setting appropriate permissions for newly created log files, organizations can safeguard sensitive information, maintain a secure logging environment, and reduce the risk of data exposure.
      remediation:
        - id: cli
          desc: |
            ***Using the CLI***

            To set the default file permissions for `rsyslog`, edit the `/etc/rsyslog.conf` and `/etc/rsyslog.d/*.conf` files and add or modify the following line:

            ```bash
            $FileCreateMode 0640
            ```
            Restart the `rsyslog` service to apply the changes:

            ```bash
            systemctl restart rsyslog
            ```
        - id: ansible
          desc: |
            ***Using Ansible***

            To set the default file permissions for `rsyslog`, use the following Ansible playbook:

            ```yaml
            ---
            - name: Set default file permissions for rsyslog
              hosts: all
              become: yes
              tasks:
                - name: Ensure $FileCreateMode 0640 is set in /etc/rsyslog.conf
                  ansible.builtin.lineinfile:
                    path: /etc/rsyslog.conf
                    regexp: '^\$FileCreateMode'
                    line: '$FileCreateMode 0640'
                    state: present
                    insertafter: EOF
                    create: yes

                - name: Ensure $FileCreateMode 0640 is set in all /etc/rsyslog.d/*.conf files
                  ansible.builtin.find:
                    paths: /etc/rsyslog.d
                    patterns: '*.conf'
                    file_type: file
                  register: rsyslog_conf_files

                - name: Set $FileCreateMode 0640 in each rsyslog.d file
                  ansible.builtin.lineinfile:
                    path: "{{ item.path }}"
                    regexp: '^\$FileCreateMode'
                    line: '$FileCreateMode 0640'
                    create: yes
                    state: present
                    backup: yes
                  loop: "{{ rsyslog_conf_files.files }}"

                - name: Restart rsyslog service
                  ansible.builtin.systemd:
                    name: rsyslog
                    state: restarted
            ```
  - uid: mondoo-linux-security-journald-is-configured-to-send-logs-to-rsyslog
    title: Ensure journald is configured to send logs to rsyslog
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["ForwardToSyslog"].downcase == "yes"
        }
      }
    docs:
      desc: |
        This check ensures that journald is configured to forward logs to rsyslog, providing a consistent and reliable means of log collection and export.

        **Why this matters**

        Forwarding logs from journald to rsyslog offers several benefits:
          - Centralized log management, enabling easier analysis and troubleshooting.
          - Compatibility with existing rsyslog configurations for log forwarding and storage.
          - Enhanced reliability and flexibility in log handling, including support for remote log export.

        By configuring journald to forward logs to rsyslog, organizations can improve log management, ensure consistent log collection, and maintain compliance with security best practices.
      remediation: |-
        Edit the `/etc/systemd/journald.conf` file and add the following line:

        ```
        ForwardToSyslog=yes
        ```

        Restart the service to load the new configuration values:

        ```bash
        systemctl restart systemd-journald
        ```
  - uid: mondoo-linux-security-journald-is-configured-to-compress-large-log-files
    title: Ensure journald is configured to compress large log files
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["Compress"] == "yes"
        }
      }
    docs:
      desc: |
        This check ensures that journald is configured to compress large log files, helping to manage disk space and maintain system performance.

        **Why this matters**

        Journald's compression capability provides several benefits:
          - Prevents log files from consuming excessive disk space, ensuring system stability.
          - Reduces the risk of logs becoming unmanageably large, simplifying log management.
          - Supports efficient storage of log data, enabling better resource utilization.

        By enabling log compression in journald, organizations can maintain a reliable logging system, optimize disk usage, and ensure effective log management.
      remediation: |-
        Edit the `/etc/systemd/journald.conf` file and add the following line:

        ```
        Compress=yes
        ```

        Restart the service to load the new configuration values:

        ```bash
        systemctl restart systemd-journald
        ```
  - uid: mondoo-linux-security-journald-is-configured-to-write-logfiles-to-persistent-disk
    title: Ensure journald is configured to write logfiles to persistent disk
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["Storage"] == "persistent"
        }
      }
    docs:
      desc: |
        This check ensures that journald is configured to write log files to a persistent disk, preventing log loss during system reboots and ensuring reliable log retention.

        **Why this matters**

        Persisting logs to a local disk provides several benefits:
          - Protects logs from being lost during system reboots, ensuring continuity in log data.
          - Enhances the reliability of log retention for troubleshooting and auditing purposes.
          - Supports compliance with security policies and regulatory requirements that mandate log preservation.

        By configuring journald to write logs to a persistent disk, organizations can maintain a robust logging infrastructure, safeguard critical log data, and ensure effective system monitoring.
      remediation: |-
        Edit the `/etc/systemd/journald.conf` file and add the following line:

        ```
        Storage=persistent
        ```

        Restart the service to load the new configuration values:

        ```bash
        systemctl restart systemd-journald
        ```
  - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
    title: Ensure secure permissions on all log files are set
    impact: 80
    mql: |
      files.find(from: "/var/log", type: "file").list {
        path
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that log files stored in `/var/log/` are properly secured to protect sensitive information and maintain system integrity.

        **Why this matters**

        Log files in `/var/log/` contain critical information from various services on the system. If these files are not properly secured:
          - Sensitive data may be exposed, especially on log aggregation servers that collect logs from multiple systems.
          - Unauthorized access to log files could lead to data breaches or compromise system security.
          - Compliance with security policies and regulatory requirements for log protection may be violated.

        By ensuring that log files in `/var/log/` are properly secured, organizations can protect sensitive information, maintain system integrity, and meet compliance requirements.
      remediation: |-
        Run these commands to set permissions on all existing log files:

        ```bash
        find /var/log/ -type f -perm /g+wx,o+rwx -exec chmod g-wx,o-rwx "{}" +
        ```

        _Note: The configuration for your logging software or services may need to also be modified for any logs that had incorrect permissions, otherwise, the permissions may be reverted to the incorrect permissions_

        _rsyslog.conf_

        ```
        vi /etc/rsyslog.conf
        ..
        $FileCreateMode 0640
        $Umask 0077
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary files:

        ```
        vi /etc/tmpfiles.d/var.conf
        ..
        f /var/log/faillog 0640 root root -
        f /var/log/wtmp 0640 root utmp -
        f /var/log/btmp 0640 root utmp -
        f /var/log/lastlog 0640 root utmp -
        ```
  - uid: mondoo-linux-security-permissions-on-ssh-private-host-key-files-are-configured
    title: Ensure secure permissions on SSH private host key files are set
    impact: 100
    mql: |
      files.
        find(from: "/etc/ssh", type: "file").
        where(path == /ssh_host_.*key$/).list {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
    docs:
      desc: |
        This check ensures that SSH private keys are securely stored and handled to prevent unauthorized access and maintain the integrity of SSH public key authentication.

        **Why this matters**

        SSH private keys are critical for authentication in public key cryptography. If private keys are not properly secured:
          - Unauthorized users could gain access to sensitive systems by using compromised private keys.
          - The integrity of the authentication process could be undermined, leading to potential security breaches.
          - Compliance with security policies requiring proper key management may be compromised.

        By ensuring that SSH private keys are securely stored and handled, organizations can protect sensitive systems, maintain secure authentication, and comply with security best practices.
      remediation: |-
        Run these commands to set ownership and permissions on the private SSH host key files

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chown root:ssh_keys {} \;
        ```

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chmod 0600 {} \;
        ```
  - uid: mondoo-linux-security-permissions-on-ssh-public-host-key-files-are-configured
    title: Ensure secure permissions on SSH public host key files are set
    impact: 80
    mql: |
      files.
        find(from: "/etc/ssh", type: "file").
        where(path == /ssh_host_.*key.pub$/).list {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
    docs:
      desc: |
        This check ensures that SSH public keys are properly configured and secured as part of the SSH public key authentication mechanism. Public keys are used to verify digital signatures generated by their corresponding private keys, enabling secure and reliable authentication.

        **Why this matters**

        SSH public key authentication provides several benefits:
          - Enhances security by eliminating the need for password-based authentication, reducing the risk of brute-force attacks.
          - Ensures that only users with the corresponding private key can authenticate successfully.
          - Supports compliance with security policies requiring strong authentication mechanisms.

        By properly configuring and securing SSH public keys, organizations can strengthen their authentication processes, protect sensitive systems, and maintain a secure environment.
      remediation: |-
        Run these commands to set permissions and ownership on the SSH host public key files

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chmod 0644 {} \;
        ```

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chown root:root {} \;
        ```
  - uid: mondoo-linux-security-ssh-protocol-is-set-to-2
    title: Ensure SSH Protocol is set to 2
    impact: 80
    # openssh-server 7.6 and later remove support for protocol v1
    filters: package('openssh-server').version  >= semver("6") && package('openssh-server').version < semver("7.6")
    mql: |
      sshd.config.params["Protocol"] == 2
    docs:
      desc: |
        This check ensures that the SSH protocol is set to version 2, which provides enhanced security and addresses vulnerabilities present in the older SSH1 protocol.

        **Why this matters**

        SSH1 is an outdated protocol with known security issues, including:
          - Weak encryption algorithms that are susceptible to attacks.
          - Vulnerabilities that can be exploited to compromise the confidentiality and integrity of SSH sessions.

        SSH2 is a more advanced and secure protocol, offering:
          - Stronger encryption algorithms to protect data in transit.
          - Improved authentication mechanisms to prevent unauthorized access.
          - Enhanced security features to mitigate modern threats.

        By enforcing the use of SSH2, organizations can ensure secure remote access, protect sensitive data, and maintain compliance with security best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `Protocol`parameter as follows:

        ```
        Protocol 2
        ```
  - uid: mondoo-linux-security-ssh-loglevel-is-appropriate
    title: Ensure SSH LogLevel is appropriate
    impact: 60
    mql: |
      sshd.config.params["LogLevel"] == /INFO|VERBOSE/
    docs:
      desc: |
        This check ensures that the `LogLevel` parameter in the SSH configuration is set to an appropriate level to log user login and logout activity, as well as key fingerprints for SSH key-based logins.

        **Why this matters**

        The `INFO` level logs basic login activity, which is essential for tracking user access to the system. This helps identify when users were active and supports incident response efforts by narrowing down potential suspects during investigations.

        The `VERBOSE` level provides additional details, including the key fingerprint for any SSH key used during login. This is particularly useful for SSH key management, especially in environments with legacy systems or shared keys.

        By configuring the `LogLevel` parameter to `INFO` or `VERBOSE`, organizations can enhance visibility into SSH activity, improve auditability, and strengthen overall security.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `LogLevel` parameter as follows:

        ```
        LogLevel VERBOSE
        ```

        or

        ```
        LogLevel INFO
        ```
  - uid: mondoo-linux-security-ssh-x11-forwarding-is-disabled
    title: Ensure SSH X11 forwarding is disabled
    impact: 50
    mql: |
      sshd.config.params["X11Forwarding"] == "no"
    docs:
      desc: |
        This check ensures that the `X11Forwarding` parameter in the SSH configuration is disabled to prevent tunneling of X11 traffic through the connection, which could expose the system to security risks.

        **Why this matters**

        The `X11Forwarding` parameter allows remote graphical connections by tunneling X11 traffic through the SSH connection. If enabled:
          - It could expose the system to unauthorized access or data leakage through the X11 protocol.
          - Attackers could exploit this feature to capture sensitive information or compromise the system.
          - It increases the attack surface of the SSH server, potentially leading to security vulnerabilities.

        By disabling `X11Forwarding`, organizations can reduce the attack surface, enhance system security, and maintain compliance with security best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `X11Forwarding` parameter as follows:

        ```
        X11Forwarding no
        ```
  - uid: mondoo-linux-security-ssh-maxauthtries-is-set-to-4-or-less
    title: Ensure SSH MaxAuthTries is set to 4 or less
    impact: 75
    mql: |
      sshd.config.params["MaxAuthTries"] <= 4
    docs:
      desc: |
        This check ensures that the `MaxAuthTries` parameter is configured to limit the maximum number of authentication attempts permitted per connection. Properly setting this parameter helps prevent brute-force attacks and enhances system security.

        **Why this matters**

        The `MaxAuthTries` parameter controls the number of authentication attempts allowed before the connection is terminated. If this parameter is not properly configured:

        - Attackers could exploit unlimited or high authentication attempts to perform brute-force attacks.
        - System logs could be flooded with failed login attempts, making it harder to detect legitimate security incidents.
        - The overall security posture of the system could be weakened, increasing the risk of unauthorized access.

        By configuring `MaxAuthTries` to an appropriate value, organizations can mitigate the risk of brute-force attacks, protect sensitive data, and maintain compliance with security best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `MaxAuthTries` parameter as follows:

        ```
        MaxAuthTries 4
        ```
  - uid: mondoo-linux-security-ssh-ignorerhosts-is-enabled
    title: Ensure SSH IgnoreRhosts is enabled
    impact: 60
    mql: |
      sshd.config.params["IgnoreRhosts"] == "yes"
    docs:
      desc: |
        This check ensures that the `IgnoreRhosts` parameter in the SSH configuration is enabled to prevent the use of `.rhosts` and `.shosts` files for authentication. Disabling these files enhances the security of the SSH server by enforcing stricter authentication mechanisms.

        **Why this matters**

        The `IgnoreRhosts` parameter ensures that `.rhosts` and `.shosts` files are not used in `RhostsRSAAuthentication` or `HostbasedAuthentication`. If these files are allowed:

        - Unauthorized users could exploit trusted host relationships to gain access to the system.
        - Malicious actors could use compromised `.rhosts` or `.shosts` files to bypass authentication mechanisms.
        - System integrity and compliance with security policies could be compromised.

        By enabling the `IgnoreRhosts` parameter, organizations can reduce the attack surface and ensure that authentication relies on more secure mechanisms, such as public key or password-based authentication.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `IgnoreRhosts` parameter as follows:

        ```
        IgnoreRhosts yes
        ```
  - uid: mondoo-linux-security-ssh-hostbasedauthentication-is-disabled
    title: Ensure SSH HostbasedAuthentication is disabled
    impact: 70
    mql: |
      sshd.config.params["HostbasedAuthentication"] == "no"
    docs:
      desc: |
        This check ensures that the `HostbasedAuthentication` parameter in the SSH configuration is properly set to prevent authentication through trusted hosts using `.rhosts` or `/etc/hosts.equiv` files, combined with public key client host authentication. This setting applies only to SSH Protocol Version 2.

        **Why this matters**

        Allowing host-based authentication can introduce significant security risks:

        - Unauthorized users could exploit trusted host relationships to gain access to the system.
        - Malicious actors could use compromised `.rhosts` or `/etc/hosts.equiv` files to bypass authentication mechanisms.
        - System integrity and compliance with security policies could be compromised.

        By disabling `HostbasedAuthentication`, organizations can reduce the attack surface and ensure that authentication relies on more secure mechanisms, such as public key or password-based authentication.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `HostbasedAuthentication` parameter as follows:

        ```
        HostbasedAuthentication no
        ```
  - uid: mondoo-linux-security-ssh-root-login-is-disabled
    title: Ensure SSH root login is disabled or set to prohibit-password
    impact: 100
    mql: |
      sshd.config.params["PermitRootLogin"] == "no" || sshd.config.params["PermitRootLogin"] == "prohibit-password" || sshd.config.params["PermitRootLogin"] == "without-password"
    docs:
      desc: |
        This check ensures that the `PermitRootLogin` parameter in the SSH configuration is set to restrict root login access. Disabling root login enhances the security of the SSH server by preventing direct access to the root account.

        **Why this matters**

        Allowing root login via SSH poses significant security risks:

        - Attackers could target the root account with brute-force attacks, increasing the likelihood of unauthorized access.
        - Direct root access bypasses the accountability provided by individual user accounts.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `PermitRootLogin` parameter is disabled or set to `prohibit-password`, organizations can enforce secure authentication practices, reduce the attack surface, and maintain a secure system configuration.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `PermitRootLogin` parameter as follows:

        ```
        PermitRootLogin no
        ```
  - uid: mondoo-linux-security-ssh-permitemptypasswords-is-disabled
    title: Ensure SSH PermitEmptyPasswords is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitEmptyPasswords"] == "no"
    docs:
      desc: |
        This check ensures that the `PermitEmptyPasswords` parameter in the SSH configuration is disabled to prevent accounts with empty password strings from being used for login. Disabling this option enhances the security of the SSH server by enforcing password-based authentication.

        **Why this matters**

        Allowing accounts with empty passwords to log in via SSH poses significant security risks:

        - Unauthorized users could gain access to the system without providing any credentials.
        - Malicious actors could exploit this vulnerability to compromise sensitive data or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `PermitEmptyPasswords` parameter is disabled, organizations can enforce secure authentication practices, reduce the attack surface, and maintain a secure system configuration.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `PermitEmptyPasswords` parameter as follows:

        ```
        PermitEmptyPasswords no
        ```
  - uid: mondoo-linux-security-ssh-permituserenvironment-is-disabled
    title: Ensure SSH PermitUserEnvironment is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitUserEnvironment"] == "no"
    docs:
      desc: |
        This check ensures that the `PermitUserEnvironment` option in the SSH configuration is disabled to prevent users from passing environment variables to the SSH daemon. Disabling this option helps maintain a secure and controlled SSH environment.

        **Why this matters**

        The `PermitUserEnvironment` option allows users to specify environment variables that are passed to the SSH daemon. If enabled:

        - Malicious users could exploit this feature to inject unauthorized environment variables, potentially compromising system security.
        - It increases the risk of privilege escalation or unauthorized access to sensitive resources.
        - System integrity and compliance with security policies could be jeopardized.

        By disabling the `PermitUserEnvironment` option, organizations can reduce the attack surface, maintain a secure SSH configuration, and ensure compliance with security best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `PermitUserEnvironment` parameter as follows:

        ```
        PermitUserEnvironment no
        ```
  - uid: mondoo-linux-security-only-strong-ciphers-are-used
    title: Ensure only strong ciphers are used
    impact: 100
    filters: package('openssh-server').installed
    props:
      - uid: mondooLinuxSecuritySshdCiphers
        title: Define the hardened ciphers for all SSH configurations
        mql: |
          if( package('openssh-server').version >= semver("6") && package('openssh-server').version < semver("7")  ) {
            return ["aes256-ctr", "aes192-ctr", "aes128-ctr"]
          }
          return ["chacha20-poly1305@openssh.com","aes256-gcm@openssh.com","aes128-gcm@openssh.com","aes256-ctr","aes192-ctr","aes128-ctr"]
    mql: |
      sshd.config.ciphers != empty
      sshd.config.ciphers.containsOnly(props.mondooLinuxSecuritySshdCiphers)
    docs:
      desc: |
        This check ensures that the SSH configuration limits the ciphers used during communication to secure and approved algorithms. Restricting the ciphers helps prevent the use of weak or deprecated encryption methods that could compromise the confidentiality and integrity of SSH sessions.

        **Why this matters**

        SSH is a critical protocol for secure remote access and management of systems. If weak or deprecated ciphers are allowed:

        - Attackers could exploit vulnerabilities in outdated encryption methods to intercept or manipulate SSH communications.
        - Sensitive data transmitted during SSH sessions could be exposed to unauthorized parties.
        - The overall security posture of the system could be weakened, increasing the risk of compromise.

        By enforcing the use of strong and approved ciphers, organizations can ensure secure SSH communication, protect sensitive data, and maintain compliance with security best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to add or modify the `Ciphers` parameter so that it contains a comma-separated list of the site approved ciphers

        Example:

        ```
        Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr
        ```
  - uid: mondoo-linux-security-only-strong-mac-algorithms-are-used
    title: Ensure only strong MAC algorithms are used
    impact: 80
    props:
      - uid: mondooLinuxSecurityMacAlgos
        title: Define the accepted MAC algorithms
        mql: |
          return ["umac-128-etm@openssh.com","hmac-sha2-256-etm@openssh.com","hmac-sha2-512-etm@openssh.com",
                  "umac-128@openssh.com","hmac-sha2-256","hmac-sha2-512"]
    mql: |
      sshd.config.macs != empty
      sshd.config.macs.containsOnly(props.mondooLinuxSecurityMacAlgos)
    docs:
      desc: |
        This check ensures that the types of MAC (Message Authentication Code) algorithms used by SSH during communication are restricted to secure and approved options. Limiting the MAC algorithms helps to prevent the use of weak or deprecated algorithms that could compromise the integrity of SSH connections.

        **Why this matters**

        SSH communication relies on MAC algorithms to ensure the integrity and authenticity of transmitted data. If insecure or outdated MAC algorithms are allowed:

        - Attackers could exploit vulnerabilities in weak algorithms to intercept or tamper with SSH communications.
        - The confidentiality and integrity of sensitive data transmitted over SSH could be compromised.
        - Compliance with security standards and best practices could be violated.

        By enforcing the use of secure MAC algorithms, organizations can strengthen the security of SSH connections, protect sensitive data, and maintain compliance with security policies.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to add or modify the `MACs` parameter so that it contains a comma-separated list of the site approved MACs

        Example:

        ```
        MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256
        ```
  - uid: mondoo-linux-security-only-strong-kex-algorithms-are-used
    title: Ensure that strong Key Exchange algorithms are used
    impact: 100
    filters: package('openssh-server').installed
    props:
      - uid: mondooLinuxSecurityKexAlgos
        title: Define the hardened key exchange algorithms for all SSH configurations
        mql: |
          if( package('openssh-server').version  >= semver("6") && package('openssh-server').version  < semver("7") ) {
            return ["curve25519-sha256@libssh.org"]
          }
          if( package('openssh-server').version  >= semver("7") && package('openssh-server').version  < semver("8") ) {
            return ["curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
          }
          if( package('openssh-server').version  >= semver("8") && package('openssh-server').version  < semver("9") ) {
            return ["sntrup4591761x25519-sha512@tinyssh.org","curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
          }
          return ["sntrup761x25519-sha512@openssh.com","curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
    mql: |
      sshd.config.kexs != empty
      sshd.config.kexs.containsOnly(props.mondooLinuxSecurityKexAlgos)
    docs:
      desc: |
        This check ensures that strong key exchange algorithms are used in the SSH configuration to secure the exchange of cryptographic keys between two parties. Key exchange is a critical component of cryptography, enabling secure communication by allowing both parties to establish a shared secret.

        **Why this matters**

        Key exchange algorithms play a vital role in establishing secure communication channels. If weak or outdated algorithms are used:

        - Attackers could exploit vulnerabilities to intercept or manipulate the key exchange process.
        - The confidentiality and integrity of encrypted communications could be compromised.
        - Compliance with security standards requiring strong cryptographic practices may be violated.

        By ensuring that only strong key exchange algorithms are used, organizations can protect sensitive data, maintain secure communications, and comply with cryptographic best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to add or modify the `KexAlgorithms` parameter so that it contains a comma-separated list of the site approved key exchange algorithms

        openssh-server version 6.x

        ```
        KexAlgorithms curve25519-sha256@libssh.org
        ```

        openssh-server version 7.x:

        ```
        KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
        ```

        openssh-server version 8.0 to 8.5:

        ```
        KexAlgorithms sntrup4591761x25519-sha512@tinyssh.org,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
        ```

        openssh-server version 8.6 or later:

        ```
        KexAlgorithms sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
        ```

        NOTE:
        To quickly find out what openssh-server version you are using, run this command:

        ```bash
        cnquery run -c "package('openssh-server').version"
        ```
  - uid: mondoo-linux-security-ssh-idle-timeout-interval-is-configured
    title: Ensure SSH Idle Timeout Interval is configured
    impact: 60
    props:
      - uid: excludedMatchBlocks
        title: A list of match blocks to exclude from checking, add items such as "User ansible"
        mql: |
          return [
            "placeholder-do-not-delete",
          ]
      - uid: checkDefaultMatchBlock
        title: Set to true if you want to check the default "" match block
        mql: |
          return true
    mql: |
      defaultBlock = sshd.config.blocks.where(criteria.in([""]) == props.checkDefaultMatchBlock && criteria == "");

      userBlocks = sshd.config.blocks.where(criteria.contains(props.excludedMatchBlocks) == false && criteria != "");

      userBlocks.all(params.ClientAliveInterval >= 1)
      userBlocks.all(params.ClientAliveInterval <= 900)
      userBlocks.all(params.ClientAliveCountMax > 0)
      userBlocks.all(params.ClientAliveCountMax <= 3)

      defaultBlock.all(params.ClientAliveInterval >= 1)
      defaultBlock.all(params.ClientAliveInterval <= 900)
      defaultBlock.all(params.ClientAliveCountMax > 0)
      defaultBlock.all(params.ClientAliveCountMax <= 3)
    docs:
      desc: |
        This check ensures that the `ClientAliveInterval` and `ClientAliveCountMax` parameters in the SSH configuration are set to control the timeout of SSH sessions. These parameters help terminate idle SSH sessions after a specified period of inactivity.

        **Why this matters**

        The `ClientAliveInterval` parameter specifies the interval (in seconds) at which the SSH server sends keepalive messages to the client. The `ClientAliveCountMax` parameter determines the maximum number of keepalive messages sent without a response before terminating the session. If these parameters are not configured:

        - Idle SSH sessions may remain open indefinitely, increasing the risk of unauthorized access.
        - System resources may be consumed by inactive connections, potentially impacting performance.
        - Compliance with security policies requiring session timeouts may be compromised.

        By configuring `ClientAliveInterval` and `ClientAliveCountMax`, organizations can enforce session timeouts, reduce the risk of unauthorized access, and maintain a secure system configuration.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `ClientAliveInterval` and `ClientAliveCountMax` parameters according to site policy:

        ```
        ClientAliveInterval 300
        ClientAliveCountMax 0
        ```
  - uid: mondoo-linux-security-ssh-logingracetime-is-set-to-one-minute-or-less
    title: Ensure SSH LoginGraceTime is set to one minute or less
    impact: 80
    mql: |
      sshd.config.params["LoginGraceTime"] >= 1
      sshd.config.params["LoginGraceTime"] <= 60
    docs:
      desc: |
        This check ensures that the `LoginGraceTime` parameter in the SSH configuration is set to an appropriate value, limiting the time allowed for successful authentication to the SSH server. This configuration helps reduce the risk of unauthenticated connections lingering on the system.

        **Why this matters**

        The `LoginGraceTime` parameter specifies the time (in seconds) allowed for successful authentication to the SSH server. If this value is set too high:

        - Unauthenticated connections may remain open for extended periods, increasing the risk of unauthorized access.
        - System resources may be consumed by idle connections, potentially impacting performance.
        - Compliance with security policies requiring strict session controls may be compromised.

        By setting the `LoginGraceTime` parameter to a minimal value, organizations can reduce the risk of unauthorized access, maintain system performance, and ensure compliance with security best practices.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `LoginGraceTime` parameter as follows:

        ```
        LoginGraceTime 60
        ```
  - uid: mondoo-linux-security-ssh-access-is-limited
    title: Ensure SSH access is limited
    impact: 60
    mql: |
      sshd.config.params["AllowUsers"] != empty || sshd.config.params["AllowGroups"] != empty || sshd.config.params["DenyUsers"] != empty || sshd.config.params["DenyGroups"] != empty

      if (sshd.config.params["AllowUsers"] != empty) { sshd.config.params["AllowUsers"] != "" }
      if (sshd.config.params["AllowGroups"] != empty) { sshd.config.params["AllowGroups"] != "" }
      if (sshd.config.params["DenyUsers"] != empty) { sshd.config.params["DenyUsers"] != "" }
      if (sshd.config.params["DenyGroups"] != empty) { sshd.config.params["DenyGroups"] != "" }
    docs:
      desc: |
        This check ensures that SSH access is restricted to specific users or groups by configuring the `AllowUsers`, `AllowGroups`, `DenyUsers`, or `DenyGroups` parameters in the `/etc/ssh/sshd_config` file. These options provide granular control over who can access the system via SSH.

        **Why this matters**

        Restricting SSH access to authorized users and groups is critical for maintaining system security. If SSH access is not properly restricted:

        - Unauthorized users could gain access to the system, potentially compromising sensitive data or escalating privileges.
        - Malicious actors could exploit open access to perform brute-force attacks or other unauthorized actions.
        - System integrity and compliance with security policies could be jeopardized.

        By configuring the `AllowUsers`, `AllowGroups`, `DenyUsers`, or `DenyGroups` parameters, organizations can enforce strict access controls, reduce the attack surface, and maintain a secure system configuration.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file and add one or more of these parameters:

        ```
        AllowUsers <userlist>
        AllowGroups <grouplist>

        DenyUsers <userlist>
        DenyGroups <grouplist>
        ```
  - uid: mondoo-linux-security-ssh-warning-banner-is-configured
    title: Ensure SSH warning banner is configured
    impact: 30
    mql: |
      sshd.config.params["Banner"] == "/etc/issue.net"
    docs:
      desc: |
        This check ensures that the `Banner` parameter in the SSH configuration is set to display a warning banner to remote users before authentication. The banner file typically contains legal or security notices to inform users of acceptable use policies.

        **Why this matters**

        Displaying a warning banner before authentication serves several purposes:

        - It informs users of the system's acceptable use policy and legal restrictions.
        - It provides a deterrent to unauthorized access by clearly stating the consequences of misuse.
        - It supports compliance with security standards and regulatory requirements that mandate the use of warning banners.

        By ensuring that the `Banner` parameter is configured, organizations can enhance security awareness, deter unauthorized access, and maintain compliance with security policies.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `Banner` parameter as follows:

        ```
        Banner /etc/issue.net
        ```
  - uid: mondoo-linux-security-permissions-on-etcpasswd-are-configured
    title: Ensure secure permissions on /etc/passwd are set
    impact: 100
    mql: |
      file("/etc/passwd") {
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that the `/etc/passwd` file, which contains user account information, is secured with appropriate permissions. The file must be readable for system utilities to operate correctly, but write access should be restricted to the root user to prevent unauthorized modifications.

        **Why this matters**

        The `/etc/passwd` file is critical for managing user accounts and system operations. If this file is improperly secured:

        - Unauthorized users could modify account information, potentially escalating privileges or disrupting system operations.
        - Malicious actors could exploit this information to compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has write access to the `/etc/passwd` file, organizations can protect critical account data and maintain a secure system configuration.
      remediation: |-
        Run this command to set permissions on `/etc/passwd`:

        ```bash
        chown root:root /etc/passwd
        chmod 644 /etc/passwd
        ```
  - uid: mondoo-linux-security-permissions-on-etcshadow-are-configured
    title: Ensure secure permissions on /etc/shadow are set
    impact: 100
    mql: |
      if (file("/etc/shadow").exists) {
        file("/etc/shadow") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/shadow` file, which stores sensitive information about user accounts, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to critical account data.

        **Why this matters**

        The `/etc/shadow` file contains hashed passwords and other security-related information for user accounts. If this file is improperly secured:

        - Unauthorized users could access sensitive password data.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/shadow` file, organizations can protect critical account data and maintain a secure system configuration.
      remediation: |-
        Run these commands to set permissions on `/etc/shadow`:

        ```bash
        chown root:root /etc/shadow
        chmod 640 /etc/shadow
        ```
  - uid: mondoo-linux-security-permissions-on-etcgroup-are-configured
    title: Ensure secure permissions on /etc/group are set
    impact: 100
    mql: |
      file("/etc/group") {
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: |
        This check ensures that the `/etc/group` file, which contains a list of all valid groups defined in the system, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized modifications to group definitions.

        **Why this matters**

        The `/etc/group` file defines group memberships on the system. If this file is improperly secured:

        - Unauthorized users could modify group definitions, potentially escalating privileges or disrupting access control.
        - Malicious actors could exploit this information to compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/group` file, organizations can protect critical group membership data and maintain a secure system configuration.
      remediation: |-
        Run this command to set permissions on `/etc/group`:

        ```bash
        chown root:root /etc/group
        chmod 644 /etc/group
        ```
  - uid: mondoo-linux-security-permissions-on-etcgshadow-are-configured
    title: Ensure secure permissions on /etc/gshadow are set
    impact: 100
    mql: |
      if (file("/etc/gshadow").exists) {
        file("/etc/gshadow") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |-
        This check ensures that the `/etc/gshadow` file, which stores hashed group passwords, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive group password information.

        **Why this matters**

        The `/etc/gshadow` file serves as a companion to `/etc/group`, listing group memberships while storing sensitive password information. If this file is improperly secured:

        - Unauthorized users could access sensitive group password data.
        - Malicious actors could exploit this information to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/gshadow` file, organizations can protect critical group password data and maintain a secure system configuration.
      remediation: |-
        Run the following chown to set permissions on `/etc/gshadow`:

        ```bash
        chown root:root /etc/gshadow
        chmod 640 /etc/gshadow
        ```
  - uid: mondoo-linux-security-permissions-on-etcpasswd--are-configured
    title: Ensure secure permissions on /etc/passwd- are set
    impact: 100
    mql: |
      if (file("/etc/passwd-").exists) {
        file("/etc/passwd-") {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/passwd-` file, which contains a backup of the `/etc/passwd` file, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive user account information.

        **Why this matters**

        The `/etc/passwd-` file serves as a backup for the `/etc/passwd` file, which stores essential information about system users. If this file is improperly secured:

        - Unauthorized users could access sensitive user account information.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/passwd-` file, organizations can protect critical user account data and maintain a secure system configuration.
      remediation: |-
        Run this command to set permissions on `/etc/passwd-`:

        ```bash
        chown root:root /etc/passwd-
        chmod 600 /etc/passwd-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/passwd- 0600 root root -
        ```
  - uid: mondoo-linux-security-permissions-on-etcshadow--are-configured
    title: Ensure secure permissions on /etc/shadow- are set
    impact: 100
    mql: |
      if (file("/etc/shadow-").exists) {
        file("/etc/shadow-") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/shadow-` file, which contains a backup of the `/etc/shadow` file, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive user account information.

        **Why this matters**

        The `/etc/shadow-` file serves as a backup for the `/etc/shadow` file, which stores hashed passwords and other critical security information about user accounts. If this file is improperly secured:

        - Unauthorized users could access sensitive password data.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/shadow-` file, organizations can protect critical user account data and maintain a secure system configuration.
      remediation: |
        Run these commands to set permissions on `/etc/shadow-`:

        ```bash
        chown root:root /etc/shadow-
        chmod 640 /etc/shadow-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/shadow- 0600 root root -
        ```
  - uid: mondoo-linux-security-permissions-on-etcgroup--are-configured
    title: Ensure secure permissions on /etc/group- are set
    impact: 100
    mql: |
      if (file("/etc/group-").exists) {
        file("/etc/group-") {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/group-` file, which contains a backup of all valid groups defined in the system, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to group names and user membership information.

        **Why this matters**

        The `/etc/group-` file serves as a backup for the `/etc/group` file, which defines group memberships on the system. If this file is improperly secured:

        - Unauthorized users could access sensitive group membership information.
        - Malicious actors could exploit this information to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/group-` file, organizations can protect critical group membership data and maintain a secure system configuration.
      remediation: |-
        Run this command to set permissions on `/etc/group-`:

        ```bash
        chown root:root /etc/group-
        chmod 600 /etc/group-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/group- 0600 root root -
        ```
  - uid: mondoo-linux-security-permissions-on-etcgshadow--are-configured
    title: Ensure secure permissions on /etc/gshadow- are set
    impact: 100
    mql: |
      if (file("/etc/gshadow-").exists) {
        file("/etc/gshadow-") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |
        This check ensures that the `/etc/gshadow-` file, which contains a backup of the `/etc/gshadow` file, is secured with appropriate permissions. Only the root user should have read and write access to this file to prevent unauthorized access to sensitive group password information.

        **Why this matters**

        The `/etc/gshadow-` file serves as a backup for the `/etc/gshadow` file, which stores information about group administrators, group members, and encrypted group passwords. If this file is improperly secured:

        - Unauthorized users could access sensitive group password information.
        - Malicious actors could exploit this information to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the root user has access to the `/etc/gshadow-` file, organizations can protect critical group password data and maintain a secure system configuration.
      remediation: |-
        Run these commands to set permissions on `/etc/gshadow-`:

        ```bash
        chown root:root /etc/gshadow-
        chmod 640 /etc/gshadow-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/gshadow- 0600 root root -
        ```
  - uid: mondoo-linux-security-no-duplicate-uids-exist
    title: Ensure no duplicate UIDs exist
    impact: 80
    mql: |
      users.list.duplicates(uid).none()
    docs:
      desc: |
        This check ensures that each user ID (UID), login name, and group ID (GID) is unique across the system. Duplicate UIDs, user names, or GIDs can lead to security and operational issues, making it critical to maintain uniqueness.

        **Why this matters**

        Unique UIDs, user names, and GIDs are essential for proper system management and security. If duplicates exist:

        - It becomes difficult to track user activity and file ownership, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in user or group identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that UIDs, user names, and GIDs are unique, organizations can maintain a secure and well-functioning system configuration.
      remediation: |
        Based on the results of the query output, establish unique UIDs and review all files owned by the shared UIDs to determine which UID they are supposed to belong to.

        Run this command to set the new UID of a user:

        ```bash
        usermod -u <new uid> <user>
        ```
  - uid: mondoo-linux-security-no-duplicate-user-names-exist
    title: Ensure no duplicate user names exist
    impact: 80
    mql: |
      users.list.duplicates(name).none()
    docs:
      desc: |
        This check ensures that each user name in the system is unique and does not have duplicates in the `/etc/passwd` file. Unique user names are critical for maintaining proper user identification and system security.

        **Why this matters**

        Duplicate user names can lead to confusion and security risks:

        - It becomes difficult to track user activity and file ownership, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in user identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that user names are unique, organizations can maintain a secure and well-functioning system configuration.
      remediation: |
        Based on the results of the query output, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs.

        Run this command to set the new user name:

        ```bash
        usermod -l <new login-name> <old username>
        ```
  - uid: mondoo-linux-security-no-duplicate-gids-exist
    title: Ensure no duplicate GIDs exist
    impact: 80
    mql: |
      groups.list.duplicates(gid).none()
    docs:
      desc: |
        This check ensures that each group ID (GID) in the system is unique and does not have duplicates in the `/etc/group` file. Unique GIDs are critical for maintaining proper group identification and system security.

        **Why this matters**

        Duplicate GIDs can lead to confusion and security risks:

        - It becomes difficult to track group ownership and permissions, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in group identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that GIDs are unique, organizations can maintain a secure and well-functioning system configuration.
      remediation: |
        Based on the results of the query output, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to.
  - uid: mondoo-linux-security-no-duplicate-group-names-exist
    title: Ensure no duplicate group names exist
    impact: 80
    mql: |
      groups.list.duplicates(name).none()
    docs:
      desc: |
        This check ensures that each login name, user ID (UID), and group ID (GID) is unique across the system. It also ensures that every user is a member of at least one group, and that every GID mentioned in the `/etc/passwd` file is defined in the `/etc/group` file.

        **Why this matters**

        Unique UIDs, user names, and GIDs are essential for proper system management and security. If duplicates or inconsistencies exist:

        - It becomes difficult to track user activity and file ownership, leading to potential security gaps.
        - System utilities and applications may behave unpredictably due to conflicts in user or group identification.
        - Networked systems may experience inconsistencies, especially when sharing resources or accessing files across systems.

        By ensuring that UIDs, user names, and GIDs are unique, and that group memberships are properly defined, organizations can maintain a secure and well-functioning system configuration.
      remediation: |
        Based on the results of the query output, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.

        Run this command to set the new group name:

        ```bash
        groupmod -n <new group name> <old groupname>
        ```
  - uid: mondoo-linux-security-default-group-for-the-root-account-is-gid-0
    title: Ensure default group for the root account is GID 0
    impact: 80
    mql: |
      users.where(name == "root").list.all(gid == 0)
    docs:
      desc: |
        This check ensures that the default group for the root account is set to GID 0, which is the standard group for administrative privileges on Linux systems. This configuration ensures proper access control and consistency in file ownership and permissions.

        **Why this matters**

        The root account is the most privileged account on a Linux system. Ensuring that its default group is set to GID 0 is critical for maintaining system security and proper access control. If the root account is assigned to a different group:

        - Files created by the root user may have incorrect group ownership, leading to potential security risks.
        - System utilities and processes that rely on the root group may behave unpredictably.
        - Compliance with security standards and best practices may be compromised.

        By ensuring that the root account's default group is GID 0, organizations can maintain a secure and consistent system configuration.
      remediation: |
        Run this command to set the `root` user default group to GID `0`:

        ```bash
        usermod -g 0 root
        ```
  - uid: mondoo-linux-security-each-user-member-of-a-group
    title: Ensure each user is a member of a group
    impact: 70
    mql: |
      users.list.all(gid != empty)
    docs:
      desc: |
        This check ensures that each user is a member of at least one group, as defined in the `/etc/group` file. Group memberships are essential for managing access control and permissions on Linux systems.

        **Why this matters**

        Group memberships provide a mechanism for assigning permissions and access rights to multiple users. If a user is not a member of any group:

        - The user may lack necessary permissions to access files or resources.
        - System administrators may face challenges in managing access control effectively.
        - Compliance with security policies that require group-based access control may be compromised.

        By ensuring that each user is a member of at least one group, organizations can maintain proper access control, streamline user management, and enhance system security.
      remediation: |
        Based on the results of the query output, add the user to a primary group.

        Run this command to set the primary group of a user:

        ```bash
        usermod -G <primary group>
        ```
  - uid: mondoo-linux-security-gid-in-passwd-exists-in-group
    title: Ensure all GIDs in /etc/passwd exist in /etc/group
    impact: 80
    mql: |
      users.list.all(group != empty)
    docs:
      desc: |
        This check ensures that every GID mentioned in the `/etc/passwd` file is defined in the `/etc/group` file. This ensures consistency and proper mapping of user groups across the system.

        **Why this matters**

        The `/etc/passwd` file associates users with their respective GIDs, while the `/etc/group` file defines the groups and their memberships. If a GID in `/etc/passwd` is not defined in `/etc/group`:

        - Users may encounter issues with group-based permissions and access control.
        - System utilities and applications may behave unpredictably due to missing group definitions.
        - Compliance with security policies requiring proper group management may be compromised.

        By ensuring that all GIDs in `/etc/passwd` exist in `/etc/group`, organizations can maintain a consistent and secure system configuration.
      remediation: |
        Based on the results of the query output, correct the GIDs in `/etc/passwd` and `/etc/group`.
  - uid: mondoo-linux-security-uid-min-is-set-to-1000
    title: Ensure UID_MIN is set to 1000
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      logindefs.params{ _['UID_MIN'] == 1000 }
    docs:
      desc: |
        This check ensures that the `UID_MIN` parameter in the `/etc/login.defs` file is set to 1000, which defines the starting UID for newly created user accounts. This configuration ensures consistency and proper user management on the system.

        **Why this matters**

        The `UID_MIN` parameter determines the range of UIDs assigned to regular user accounts. If this value is not set correctly:

        - User accounts may overlap with system accounts, leading to potential security and operational issues.
        - System utilities and applications may behave unpredictably due to conflicts in UID assignments.
        - Compliance with security policies requiring separation of system and user accounts may be compromised.

        By ensuring that `UID_MIN` is set to 1000, organizations can maintain a secure and consistent user management configuration.
      remediation: |
        Edit the `login.defs` file and set UID_MIN.

        ```
        vim /etc/login.defs


        UID_MIN                  1000
        ```
  - uid: mondoo-linux-security-shadow-group-is-empty
    title: Ensure shadow group is empty
    impact: 80
    mql: |
      groups.where(name == "shadow").all(members.length == 0)
    docs:
      desc: |
        This check ensures that the `shadow` group, which allows access to the `/etc/shadow` file, is empty. No users should be assigned to this group to prevent unauthorized access to sensitive password information.

        **Why this matters**

        The `shadow` group provides access to the `/etc/shadow` file, which contains hashed passwords and other sensitive account information. If users are improperly assigned to this group:

        - Unauthorized users could gain access to sensitive password data.
        - Malicious actors could exploit this information to compromise user accounts or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that the `shadow` group is empty, organizations can protect critical account data and maintain a secure system configuration.
      remediation: |-
        Remove all users from the `shadow` group in `/etc/group`, and change the primary group of any users with `shadow` as their primary group.
  - uid: mondoo-linux-security-root-group-is-empty
    title: Ensure root group is empty
    impact: 100
    mql: |
      groups.where(name == "root").all(members == empty || members.all(name == 'root'))
    docs:
      desc: |
        This check ensures that the `root` group, which allows system programs or defined users the ability to read and write configurations and files on the system, is properly secured by ensuring no users other than the `root` user are assigned to it.

        **Why this matters**

        The `root` group provides elevated privileges that can impact the security and stability of the system. If unauthorized users are assigned to the `root` group:

        - They could gain access to sensitive system configurations and files.
        - Malicious actors could exploit this access to compromise system security or escalate privileges.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that only the `root` user is assigned to the `root` group, organizations can maintain a secure and well-functioning system configuration.
      remediation: |-
        Remove all users from the `root` group in `/etc/group`, and change the primary group of any users with `root` as their primary group, except the `root` user.
  - uid: mondoo-linux-security-system-accounts-are-non-login
    title: Ensure system accounts are non-login
    impact: 70
    mql: |
      users.where( name != "root" && name != "sync" && name != "shutdown" && name != "halt" ).where( uid < 1000 ).list {
        shell == "/usr/bin/nologin" || shell == "/sbin/nologin" || shell == "/usr/sbin/nologin"
      }
    docs:
      desc: |
        This check ensures that system accounts, which are used to manage applications and services, are configured as non-login accounts. These accounts do not require a shell for interactive use.

        **Why this matters**

        System accounts are intended for managing applications and services, not for interactive user access. If these accounts are configured with login shells:

        - Unauthorized users could exploit these accounts to gain access to the system.
        - Malicious actors could use these accounts to escalate privileges or compromise system security.
        - System integrity and compliance with security policies could be jeopardized.

        By ensuring that system accounts are non-login, organizations can reduce the attack surface and maintain a secure system configuration. remediation: |
      remediation: |-
        Set the shell for any accounts returned by the audit script to `/sbin/nologin`:

        ```bash
        usermod -s /sbin/nologin <em><user></em>
        ```

        The following script will automatically set all user shells required to `/sbin/nologin` and lock the `sync`, `shutdown`, and `halt` users:

        ```bash
        #!/bin/bash

        for user in `awk -F: '($3 < 1000) {print $1 }' /etc/passwd`; do
        if [ $user != "root" ]; then
          if [ "$(passwd -S $user| cut -d ' ' -f 2)" = "P" ]; then
            echo "Lock $user account"
            usermod -L $user
          fi
          if [ $user != "sync" ] && [ $user != "shutdown" ] && [ $user != "halt" ]; then
            echo "Set /sbin/nologin shell for user $user"
            usermod -s /sbin/nologin $user
          fi
        fi
        done
        ```

        nologin is a per-user method of disabling interactive logins (usually used for system accounts like http or ftp). nologin uses /etc/nologin.txt as an optional source for a non-default message, the login access is always refused independently of the file.
  - uid: mondoo-linux-security-access-to-the-su-command-is-restricted
    title: Ensure access to the su command is restricted
    impact: 80
    filters: |
      asset.kind != "container-image"
    props:
      - uid: mondooLinuxSecuritySudoGroup
        title: Define the members of the sudo or wheel group
        mql: |
          return /root|ec2-user|centos|ubuntu|admin|mondoo/
    mql: |
      pam.conf.entries["/etc/pam.d/su"].where(pamType == "auth" && module == "pam_wheel.so").any(options.contains("use_uid"))
      groups.any(name == "wheel" || name == "sudo")
      groups.where(name == "wheel" || name == "sudo") {
        members {
          name
          name == props.mondooLinuxSecuritySudoGroup
        }
      }
    docs:
      desc: |
        This check ensures that access to the `su` command is restricted to authorized users by configuring the `pam_wheel.so` module in the `/etc/pam.d/su` file. This configuration limits the use of the `su` command to members of the `wheel` or `sudo` group, enhancing system security.

        **Why this matters**

        The `su` command allows a user to switch to another user account, including the root account, without logging out. If unrestricted:

        - Unauthorized users could gain elevated privileges, potentially compromising system security.
        - Malicious actors could exploit the `su` command to escalate privileges or perform unauthorized actions.
        - System integrity and compliance with security policies could be jeopardized.

        By restricting access to the `su` command, organizations can ensure that only authorized users can perform privileged actions, reducing the risk of unauthorized access and maintaining a secure system configuration.
      audit: |
        Run this command and verify output includes matching line:

        ```
        # grep pam_wheel.so /etc/pam.d/su
        auth required pam_wheel.so use_uid
        ```

        Run this command and verify users in wheel group match site policy:

        ```
        # grep wheel /etc/group
        wheel:x:10:root,<user list>
        ```
      remediation: |
        Add the following line to the `/etc/pam.d/su` file:

        ```
        auth required pam_wheel.so use_uid
        ```

        If users need su access, add their username to the comma-separated list of users in the `wheel` group within the `/etc/group` file:

        ```
        wheel:x:10:root,<user list>
        ```
        NOTE: The users allowed in the wheel group are defined in the properties `props.mondooLinuxSecuritySudoGroup` field of this policy. By default the users "root", "ec2-user", "centos" and "ubuntu" are included. To include custom users you need to manually modify this policy. Otherwise the check will fail.

        If you want to lock down the use of the command `su` entirely instead, you need to create an empty group, for example `sugroup`:

        ```bash
        groupadd sugroup
        ```

        Then add the following line to the `/etc/pam.d/su` file:

        ```
        auth required pam_wheel.so use_uid group=sugroup
        ```
