
# Copyright (c) Mondoo, Inc.
# SPDX-License-Identifier: BUSL-1.1

policies:
  - uid: mondoo-linux-security
    name: Mondoo Linux Security
    version: 2.5.0
    license: BUSL-1.1
    tags:
      mondoo.com/category: security
      mondoo.com/platform: linux
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: |-
        The Mondoo Linux Security policy provides guidance for establishing a secure baseline configuration for Linux systems running on x86 and x64 platforms.

        This policy includes queries to help harden Linux systems by:
          - Identifying problematic services that may be running
          - Identifying loose permissions on sensitive system configuration files
          - Ensuring logging and auditing services are properly configured and running
          - Hardening SSH configurations
          - Ensure users and groups are securely configured
          - Identifying misconfigured Kernel networking configurations

        This policy has been developed for Red Hat (RHEL), Debian, Ubuntu, and SUSE (SLES) derivative distributions running on x86 and x64 architectures.
        Some queries may be skipped depending on your particular distribution, installation type, or underlying infrastructure.
        The overall guidance within this policy broadly assumes that operations are being performed as the root user.
        Operations performed using sudo instead of the root user may produce unexpected results or fail to make the intended changes to the system.
        Non-root users may not be able to access certain areas of the system, especially after remediation has been performed. It is advisable to verify
        root users path integrity and the integrity of any programs being run prior to execution of commands and scripts included in this benchmark.

        ## Local scan

        Local scan refer to scans of files and operating systems where cnspec is installed.

        To scan the `localhost` against this policy:

        ```bash
        cnspec scan local
        ```

        ## Remote scan

        Remote scans use cnspec providers to retrieve on-demand scan results without having to install any agents.

        ### Prerequisites

        Remote scans of Linux hosts requires authentication such as SSH keys.

        ### Scan a remote Linux host (SSH authentication)

        ```bash
        cnspec scan ssh <user>@<IP_ADDRESS> -i /path/to/ssh_key
        ```

        ## Join the community!

        Our goal is to build policies that are simple to deploy, accurate, and actionable.

        If you have any suggestions for how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.
    groups:
      - title: Core
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security--window-system-is-not-installed
          - uid: mondoo-linux-security-address-space-layout-randomization-aslr-is-enabled
          - uid: mondoo-linux-security-aide-is-installed
          - uid: mondoo-linux-security-bogus-icmp-responses-are-ignored
          - uid: mondoo-linux-security-broadcast-icmp-requests-are-ignored
          - uid: mondoo-linux-security-core-dumps-are-restricted
          - uid: mondoo-linux-security-filesystem-integrity-is-regularly-checked
          - uid: mondoo-linux-security-icmp-redirects-are-not-accepted
          - uid: mondoo-linux-security-ip-forwarding-is-disabled
          - uid: mondoo-linux-security-ipv6-router-advertisements-are-not-accepted
          - uid: mondoo-linux-security-mail-transfer-agent-is-configured-for-local-only-mode
          - uid: mondoo-linux-security-packet-redirect-sending-is-disabled
          - uid: mondoo-linux-security-permissions-on-etcgroup--are-configured
          - uid: mondoo-linux-security-permissions-on-etcgroup-are-configured
          - uid: mondoo-linux-security-permissions-on-etcgshadow--are-configured
          - uid: mondoo-linux-security-permissions-on-etcgshadow-are-configured
          - uid: mondoo-linux-security-permissions-on-etcpasswd--are-configured
          - uid: mondoo-linux-security-permissions-on-etcpasswd-are-configured
          - uid: mondoo-linux-security-permissions-on-etcshadow--are-configured
          - uid: mondoo-linux-security-permissions-on-etcshadow-are-configured
          - uid: mondoo-linux-security-prelink-is-disabled
          - uid: mondoo-linux-security-reverse-path-filtering-is-enabled
          - uid: mondoo-linux-security-secure-icmp-redirects-are-not-accepted
          - uid: mondoo-linux-security-source-routed-packets-are-not-accepted
          - uid: mondoo-linux-security-suspicious-packets-are-logged
          - uid: mondoo-linux-security-tcp-syn-cookies-is-enabled
      - title: Sensitive Services
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-avahi-server-is-not-enabled
          - uid: mondoo-linux-security-dhcp-server-is-not-enabled
          - uid: mondoo-linux-security-dns-server-is-not-enabled
          - uid: mondoo-linux-security-ftp-server-is-not-enabled
          - uid: mondoo-linux-security-http-proxy-server-is-not-enabled
          - uid: mondoo-linux-security-http-server-is-not-enabled
          - uid: mondoo-linux-security-imap-and-pop3-server-is-not-enabled
          - uid: mondoo-linux-security-ldap-server-is-not-enabled
          - uid: mondoo-linux-security-nfs-and-rpc-are-not-enabled
          - uid: mondoo-linux-security-nis-server-is-not-enabled
          - uid: mondoo-linux-security-rsh-server-is-not-enabled
          - uid: mondoo-linux-security-rsync-service-is-not-enabled
          - uid: mondoo-linux-security-samba-is-not-enabled
          - uid: mondoo-linux-security-snmp-server-is-not-enabled
          - uid: mondoo-linux-security-talk-server-is-not-enabled
          - uid: mondoo-linux-security-telnet-server-is-not-enabled
          - uid: mondoo-linux-security-tftp-server-is-not-enabled
          - uid: mondoo-linux-security-cups-is-not-enabled
      - title: SSH Server Configuration
        filters: |
          asset.family.contains('linux')
          package('openssh-server').installed
        checks:
          - uid: mondoo-linux-security-only-strong-ciphers-are-used
          - uid: mondoo-linux-security-only-strong-kex-algorithms-are-used
          - uid: mondoo-linux-security-only-strong-mac-algorithms-are-used
          - uid: mondoo-linux-security-permissions-on-etcsshsshd-config-are-configured
          - uid: mondoo-linux-security-permissions-on-ssh-private-host-key-files-are-configured
          - uid: mondoo-linux-security-permissions-on-ssh-public-host-key-files-are-configured
          - uid: mondoo-linux-security-ssh-access-is-limited
          - uid: mondoo-linux-security-ssh-hostbasedauthentication-is-disabled
          - uid: mondoo-linux-security-ssh-idle-timeout-interval-is-configured
          - uid: mondoo-linux-security-ssh-ignorerhosts-is-enabled
          - uid: mondoo-linux-security-ssh-logingracetime-is-set-to-one-minute-or-less
          - uid: mondoo-linux-security-ssh-loglevel-is-appropriate
          - uid: mondoo-linux-security-ssh-maxauthtries-is-set-to-4-or-less
          - uid: mondoo-linux-security-ssh-permitemptypasswords-is-disabled
          - uid: mondoo-linux-security-ssh-permituserenvironment-is-disabled
          - uid: mondoo-linux-security-ssh-protocol-is-set-to-2
          - uid: mondoo-linux-security-ssh-root-login-is-disabled
          - uid: mondoo-linux-security-ssh-warning-banner-is-configured
          - uid: mondoo-linux-security-ssh-x11-forwarding-is-disabled
      - title: Logging
        filters: |
          asset.family.contains('linux')
          asset.kind != "container-image"
        checks:
          - uid: mondoo-linux-security-audit-log-storage-size-is-configured
          - uid: mondoo-linux-security-audit-logs-are-not-automatically-deleted
          - uid: mondoo-linux-security-auditd-is-installed-and-running
          - uid: mondoo-linux-security-auditing-for-processes-that-start-prior-to-auditd-is-enabled
          - uid: mondoo-linux-security-changes-to-system-administration-scope-sudoers-is-collected
          - uid: mondoo-linux-security-discretionary-access-control-permission-modification-events-are-collected
          - uid: mondoo-linux-security-events-that-modify-date-and-time-information-are-collected
          - uid: mondoo-linux-security-events-that-modify-the-systems-mandatory-access-controls-are-collected
          - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected
          - uid: mondoo-linux-security-events-that-modify-usergroup-information-are-collected
          - uid: mondoo-linux-security-file-deletion-events-by-users-are-collected
          - uid: mondoo-linux-security-journald-is-configured-to-compress-large-log-files
          - uid: mondoo-linux-security-journald-is-configured-to-send-logs-to-rsyslog
          - uid: mondoo-linux-security-journald-is-configured-to-write-logfiles-to-persistent-disk
          - uid: mondoo-linux-security-kernel-module-loading-and-unloading-is-collected
          - uid: mondoo-linux-security-login-and-logout-events-are-collected
          - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
          - uid: mondoo-linux-security-rsyslog-default-file-permissions-configured
          - uid: mondoo-linux-security-rsyslog-is-installed
          - uid: mondoo-linux-security-rsyslog-service-is-enabled
          - uid: mondoo-linux-security-session-initiation-information-is-collected
          - uid: mondoo-linux-security-successful-file-system-mounts-are-collected
          - uid: mondoo-linux-security-sudo-logging-is-enabled
          - uid: mondoo-linux-security-system-administrator-actions-sudolog-are-collected
          - uid: mondoo-linux-security-system-is-disabled-when-audit-logs-are-full
          - uid: mondoo-linux-security-the-audit-configuration-is-immutable
          - uid: mondoo-linux-security-unsuccessful-unauthorized-file-access-attempts-are-collected
      - title: Users and groups
        filters: |
          asset.family.contains('linux')
        checks:
          - uid: mondoo-linux-security-access-to-the-su-command-is-restricted
          - uid: mondoo-linux-security-default-group-for-the-root-account-is-gid-0
          - uid: mondoo-linux-security-each-user-member-of-a-group
          - uid: mondoo-linux-security-gid-in-passwd-exists-in-group
          - uid: mondoo-linux-security-no-duplicate-gids-exist
          - uid: mondoo-linux-security-no-duplicate-group-names-exist
          - uid: mondoo-linux-security-no-duplicate-uids-exist
          - uid: mondoo-linux-security-no-duplicate-user-names-exist
          - uid: mondoo-linux-security-root-group-is-empty
          - uid: mondoo-linux-security-shadow-group-is-empty
          - uid: mondoo-linux-security-system-accounts-are-non-login
          - uid: mondoo-linux-security-uid-min-is-set-to-1000
    scoring_system: highest impact
queries:
  - uid: mondoo-linux-security-aide-is-installed
    title: Ensure Advanced Intrusion Detection Environment (AIDE) is installed
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      package("aide").installed
    docs:
      desc: |
        This check verifies that the Advanced Intrusion Detection Environment (AIDE) is installed on a Linux system. AIDE functions as a file integrity checker that helps detect unauthorized changes to critical system files and configurations.

        **Why this matters**

        AIDE creates a database of cryptographic checksums for important system files and directories. Once initialized, AIDE can be used to scan the system and compare the current state of files against the known-good baseline. This process helps detect file tampering, rootkit installation, or configuration drift that may indicate a security breach.

        Without a host-based file integrity monitoring (FIM) solution like AIDE, administrators may not be aware of changes to critical files made by malicious actors or unintended actions by privileged users. This lack of visibility undermines incident response, auditability, and system trustworthiness.

        Installing AIDE contributes to the overall integrity assurance of a Linux system and supports compliance with standards such as:
          - PCI-DSS Requirement 11.5
          - NIST 800-53 (SI-7: Software, Firmware, and Information Integrity)

        Ensuring AIDE is installed lays the foundation for host-based file integrity monitoring, which is a critical part of a defense-in-depth strategy for detecting intrusions and preserving system integrity.
      remediation: |-
        Run this command to install `aide`:

        ### RHEL/Fedora/Amazon Linux and derivatives

        ```bash
        yum install aide
        ```

        ### Debian/Ubuntu and derivatives

        ```bash
        apt-get install aide
        ```

        ### SLES and openSUSE

        ```bash
        zypper install aide
        ```

        Configure AIDE as appropriate for your environment. Consult the AIDE documentation for options.

        Initialize AIDE:

        ```bash
        aideinit
        ```
  - uid: mondoo-linux-security-filesystem-integrity-is-regularly-checked
    title: Ensure filesystem integrity is regularly checked using AIDE
    impact: 50
    filters: |
      asset.kind != "container-image"
    mql: |
      file("/etc/default/aide").exists && ["/etc/default/aide"].where(file(_).exists).all(parse.ini(_).params["CRON_DAILY_RUN"] == "yes") ||
      command("crontab -u root -l | grep aide").stdout.lines.where(/^[^#]/).any(_.contains("aide --check")) ||
      command("crontab -u root -l | grep aide").stdout.lines.where(/^[^#]/).any(_.contains("aide.conf --check")) ||
      service('aidecheck').enabled
    docs:
      desc: |
        This check verifies that AIDE (Advanced Intrusion Detection Environment) is actively used to perform regular integrity scans of the filesystem. It ensures that an AIDE database has been initialized and that periodic checks are scheduled and executed.

        **Why this matters**

        Installing AIDE alone is not sufficient to protect a system from unauthorized changes. To be effective, AIDE must be routinely run to compare the current system state against its known-good baseline. Regular execution of these checks helps detect file tampering, unauthorized modifications, and early signs of compromise—especially in sensitive directories like /etc, /bin, and /sbin.

        If AIDE is not executed on a regular basis:
          - Integrity violations may go undetected, exposing the system to persistent threats such as rootkits or malware.
          - Audit logs and incident response efforts may be incomplete due to a lack of timely data.
          - Organizations may fail to meet compliance requirements that mandate proactive monitoring of system integrity.

        Regular integrity checks serve as a crucial early warning mechanism that strengthens security posture by enabling timely investigation and response.
      remediation: |-
        ### To run aide using cron

        Run this command:

        ```bash
        crontab -u root -e
        ```

        Add the following line to the crontab:

        ```
        0 5 * * * /usr/sbin/aide --check
        ```

        ### To run aide using a systemd timer

        Create or edit the file `/etc/systemd/system/aidecheck.service` and add the following lines:

        ```
        [Unit]
        Description=Aide Check

        [Service]
        Type=simple
        ExecStart=/usr/sbin/aide --check

        [Install]
        WantedBy=multi-user.target
        ```

        Create or edit the file `/etc/systemd/system/aidecheck.timer` and add the following lines:

        ```
        [Unit]
        Description=Aide check every day at 5AM

        [Timer]
        OnCalendar=*-*-* 05:00:00
        Unit=aidecheck.service

        [Install]
        WantedBy=multi-user.target
        ```

        Run these commands:

        ```bash
        chown root:root /etc/systemd/system/aidecheck.*
        chmod 0644 /etc/systemd/system/aidecheck.*

        systemctl daemon-reload

        systemctl enable aidecheck.service
        systemctl --now enable aidecheck.timer
        ```
  - uid: mondoo-linux-security-core-dumps-are-restricted
    title: Ensure core dumps are restricted
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    impact: 75
    mql: |
      file("/etc/security/limits.conf").content.lines.where( _ == /^[^#]/ ).where( _.contains("core") ) {
        _ == /\*\s+hard\s+core\s+0/
      }
      kernel.parameters['fs.suid_dumpable'] == 0
      if(service("coredump").enabled || service("coredump").running) {
        parse.ini("/etc/systemd/coredump.conf").sections['Coredump']['ProcessSizeMax'] == 0
        parse.ini("/etc/systemd/coredump.conf").sections['Coredump']['Storage'] == 'none'
      }
    docs:
      desc: |
        This check verifies that core dumps are restricted on the system by setting appropriate limits in `/etc/security/limits.conf`, configuring the `fs.suid_dumpable` kernel parameter, and ensuring the `coredump` service (if installed) is properly configured. These settings prevent unauthorized or excessive core dump creation, especially for set-user-ID (SUID) programs.

        **Why this matters**

        Core dumps capture the memory contents of a process at the time it crashes. While useful for debugging, core dumps can expose sensitive information such as passwords, cryptographic keys, or proprietary application logic—especially if generated by privileged or network-facing applications.

        By default, systems may allow core dumps for all processes, including those with elevated privileges. If unrestricted:
          - Attackers could exploit this to gain access to in-memory secrets.
          - Users could accidentally or intentionally generate core dumps containing sensitive information.
          - Storage systems could become overwhelmed by large or repeated core files, leading to denial-of-service risks.

        To mitigate this, three key protections should be enforced:
          - A hard limit of 0 core file size in /etc/security/limits.conf to block core dumps for all users by default.
          - Setting the fs.suid_dumpable kernel parameter to 0 to disable core dumps for SUID programs, which typically run with elevated privileges.
          - Properly configuring the coredump service (if installed) with ProcessSizeMax=0 and Storage=none to prevent systemd-based core dump handling from storing crash data.

        Restricting core dumps helps preserve the confidentiality of system memory, prevents unnecessary disk usage, and protects against inadvertent leakage of sensitive data.
      remediation: |-
        Add the following line to `/etc/security/limits.conf` or a `/etc/security/limits.d/` file:

        ```
        * hard core 0
        ```

        Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        fs.suid_dumpable = 0
        ```

        Run this command to set the active kernel parameter:

        ```bash
        sysctl -w fs.suid_dumpable=0
        ```

        If systemd-coredump is installed:

        edit `/etc/systemd/coredump.conf` and add/modify the following lines:

        ```
        Storage=none
        ProcessSizeMax=0
        ```

        Run the command:

        ```bash
        systemctl daemon-reload
        ```
  - uid: mondoo-linux-security-address-space-layout-randomization-aslr-is-enabled
    title: Ensure address space layout randomization (ASLR) is enabled
    impact: 90
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters["kernel.randomize_va_space"] == 2
    docs:
      desc: |
        This check verifies that Address Space Layout Randomization (ASLR) is enabled by confirming that the kernel parameter kernel.randomize_va_space is set to 2, which enforces full randomization of memory regions.

        **Why this matters**

        ASLR is a memory protection technique that randomizes the location of key data areas in a process's address space, such as the stack, heap, and libraries. This unpredictability makes it significantly harder for attackers to exploit memory corruption vulnerabilities, such as buffer overflows, since they cannot reliably guess the locations of critical functions or data structures in memory.

        When ASLR is disabled or misconfigured:
          - Exploits that rely on fixed memory addresses become easier to execute.
          - Attackers may leverage known memory layouts to bypass protections like stack canaries, non-executable memory (NX), and control flow integrity.
          - Systems become more susceptible to privilege escalation, remote code execution, and other forms of memory-based attacks.

        Setting kernel.randomize_va_space to 2 enables full ASLR, providing the strongest level of memory layout unpredictability and helping to enforce modern exploit mitigation strategies on Linux systems.
      remediation: |-
        Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        kernel.randomize_va_space = 2
        ```

        Run this command to set the active kernel parameter:

        ```bash
        sysctl -w kernel.randomize_va_space=2
        ```
  - uid: mondoo-linux-security-prelink-is-disabled
    title: Ensure prelink is disabled
    impact: 70
    mql: |
      package("prelink").installed == false
    docs:
      desc: |
        This check verifies that the prelink package is not installed on the system. The prelink utility modifies ELF binaries to optimize program load times by precomputing memory locations for shared libraries. While this can improve performance, it also introduces security risks and interferes with other critical system protections.

        **Why this matters**

        Disabling prelink helps ensure the reliability of security tools and strengthens system integrity protections. When prelink is active:
          - It modifies binaries on disk, which can prevent tools like AIDE from detecting unauthorized tampering because legitimate prelink changes obscure unauthorized ones.
          - It can negate security mechanisms such as Address Space Layout Randomization (ASLR) by fixing memory address locations in advance, undermining this key exploit mitigation technique.
          - It increases the system's attack surface by introducing complexity and modifying binaries in ways that may be exploited or misunderstood by defenders.

        Removing prelink eliminates this unnecessary risk, ensures compatibility with file integrity monitoring tools, and supports consistent enforcement of modern memory protection strategies.
      remediation: |-
        Run these commands to restore binaries to normal and uninstall `prelink`:

        ### RHEL/Fedora/Amazon Linux and derivatives

        ```bash
        prelink -ua
        yum remove prelink
        ```

        ### Debian/Ubuntu and derivatives

        ```bash
        prelink -ua
        apt-get purge prelink
        ```
  - uid: mondoo-linux-security--window-system-is-not-installed
    title: Ensure X Window System is not installed
    impact: 100
    mql: |
      packages.none(name == /^xserver-xorg.*/ || name == /^xorg-x11/ || name == /^xserver/)
    docs:
      desc: |
        This check verifies that the X Window System is not installed on the host. It scans for common packages associated with X, such as xserver-xorg, xorg-x11, and other display server components.

        **Why this matters**

        The X Window System provides a graphical user interface (GUI) that enables users to interact with applications through windows, menus, and graphical controls. While useful for desktop environments, it is generally unnecessary—and potentially risky—on servers or hardened systems that do not require graphical interfaces.

        Keeping the X Window System installed on a server can:
          - Introduce unnecessary software components and services, increasing the system's attack surface.
          - Add network-facing daemons that may not be actively monitored or patched, creating potential entry points for attackers.
          - Consume additional system resources that could otherwise be allocated to critical services.

        On headless or server-class Linux systems, the X Window System should be removed unless explicitly required. Removing it aligns with the principle of least functionality, ensuring only essential software is installed and reducing the opportunity for exploitation.
      remediation: |-
        Run this command to remove the X Windows System packages:

        ### RHEL/Fedora/Amazon Linux and derivatives

        ```bash
        yum remove xorg-x11*
        ```

        ### Debian/Ubuntu and derivatives

        ```bash
        apt-get purge xserver-xorg
        ```

        ### SLES and openSUSE

        ```bash
        zypper remove xorg-x11-server
        ```
  - uid: mondoo-linux-security-avahi-server-is-not-enabled
    title: Ensure Avahi server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("avahi-daemon").enabled == false
      service("avahi-daemon").running == false
    docs:
      desc: |
        This check verifies that the avahi-daemon service is neither running nor enabled on the system. Avahi is a zeroconf (zero-configuration networking) implementation that supports multicast DNS (mDNS) and DNS Service Discovery (DNS-SD), allowing devices to automatically discover each other on local networks.

        **Why this matters**

        While convenient in desktop or home environments, Avahi is rarely needed on production servers or hardened enterprise systems. When enabled, the Avahi daemon broadcasts services and listens for network announcements, which can:
          - Expose unnecessary information about the system to local network peers.
          - Increase the system's attack surface through unneeded services.
          - Allow unauthorized devices to detect and interact with the host without explicit configuration.

        In secure environments, it is a best practice to disable Avahi unless explicitly required for functionality. Stopping and disabling the avahi-daemon service helps enforce the principle of least functionality and reduces the risk of unintended network exposure.
      remediation: |-
        Run this command to stop and disable `avahi-daemon`:

        ```bash
        systemctl stop avahi-daemon
        systemctl disable avahi-daemon
        ```

        Note: Since the `avahi-daemon` service is often interdependent with other services, it might not be enough to disable the service because other services will likely restart the service automatically.

        To make the service `avahi-daemon` invisible to other services run this command:

        ```bash
        systemctl mask avahi-daemon
        ```
  - uid: mondoo-linux-security-cups-is-not-enabled
    title: Ensure CUPS is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("cups").enabled == false
      service("cups").running == false
    docs:
      desc: |
        This check verifies that the Common Unix Printing System (CUPS) service is neither running nor enabled on the system. CUPS provides printing capabilities for local and network printers and includes web-based administration tools.

        **Why this matters**

        CUPS is typically unnecessary on hardened servers or cloud-hosted Linux systems where printing services are not required. If left running:
          - It may expose the system to remote exploitation, especially if administrative interfaces are accessible over the network.
          - It increases the overall attack surface by introducing a network-accessible daemon.
          - Unused services like CUPS can be leveraged in lateral movement or privilege escalation scenarios, particularly if misconfigured or unpatched.

        Disabling CUPS aligns with the principle of least functionality and helps reduce the number of services available for exploitation. It is recommended to stop and disable the service unless printing capabilities are explicitly required for the system's role.
      remediation: |-
        Run this command to stop and disable `cups`:

        ```bash
        systemctl stop cups
        systemctl disable cups
        ```

        Note: Since the `cups` service is often interdependent with other services, it might not be enough to disable the service because other services such as `cups-browsed` will likely restart the service automatically.

        To make the service `cups` invisible to other services run this command:

        ```bash
        systemctl mask cups
        ```

        **Impact:**

        Disabling CUPS will prevent printing from the system, a common task for workstation systems.
  - uid: mondoo-linux-security-dhcp-server-is-not-enabled
    title: Ensure DHCP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("dhcpd").enabled == false
      service("dhcpd").running == false
    docs:
      desc: |
        This check verifies that the DHCP server service (dhcpd) is neither running nor enabled on the system.

        **Why this matters**

        The Dynamic Host Configuration Protocol (DHCP) allows systems to dynamically assign IP addresses and other network configuration parameters to devices on a network. While essential in network infrastructure roles, DHCP servers are rarely required on general-purpose Linux systems or production servers.

        Running a DHCP server where it is not explicitly needed can:
          - Lead to IP address conflicts and unpredictable network behavior.
          - Allow unauthorized clients to obtain network configuration from an untrusted source.
          - Expose the host to exploitation if the service is vulnerable or misconfigured.

        Disabling unused services like dhcpd reduces the system's attack surface and aligns with the principle of least functionality. On systems that are not intended to serve as DHCP servers, the service should be fully disabled to prevent accidental exposure or misuse.
      remediation: |-
        Run this command to stop and disable `dhcpd`:

        ```bash
        systemctl stop dhcpd
        systemctl disable dhcpd
        ```
  - uid: mondoo-linux-security-ldap-server-is-not-enabled
    title: Ensure LDAP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("slapd").enabled == false
      service("slapd").running == false
    docs:
      desc: |
        This check verifies that the LDAP server service (slapd) is neither running nor enabled on the system.

        **Why this matters**

        The Lightweight Directory Access Protocol (LDAP) server provides centralized directory services for managing user identities, authentication data, and configuration information across a network. While useful in enterprise environments that require directory-based access management, an LDAP server is rarely needed on general-purpose Linux systems unless explicitly part of the infrastructure design.

        If an unnecessary LDAP server is running:
          - It may expose sensitive directory information to the network.
          - It increases the system's attack surface by introducing a network-accessible service.
          - It can be misused or targeted by attackers to enumerate user accounts, perform unauthorized lookups, or exploit known vulnerabilities.

        To reduce risk and enforce the principle of least functionality, the slapd service should be stopped and disabled on systems that are not intended to serve directory services. This helps limit exposure and strengthens the host's overall security posture.
      remediation: |-
        Run this command to stop and disable `slapd`:

        ```bash
        systemctl stop slapd
        systemctl disable slapd
        ```
  - uid: mondoo-linux-security-nfs-and-rpc-are-not-enabled
    title: Ensure NFS and RPC are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("nfs").enabled == false
      service("nfs").running == false
      service("rpcbind").enabled == false
      service("rpcbind").running == false
    docs:
      desc: |
        This check verifies that the NFS (nfs) and RPC (rpcbind) services are not running and are disabled from starting at boot. These services are commonly used to share directories across systems on a network using the Network File System (NFS) protocol.

        **Why this matters**

        NFS and RPC are powerful but legacy components of networked UNIX environments. They introduce significant security risks when enabled unnecessarily, particularly on systems not explicitly configured as file servers or requiring remote filesystem mounts.

        When NFS and RPC are active:
          - They open multiple ports and expose services that can be discovered and potentially exploited.
          - RPC-based services may leak metadata about system configurations or mount points.
          - Misconfigurations or vulnerabilities in these services can be used for privilege escalation, lateral movement, or data exfiltration.

        Disabling NFS and RPC services on systems where they are not required reduces unnecessary network exposure, aligns with the principle of least functionality, and helps harden systems against remote access threats.
      remediation: |-
        Run these commands to stop and disable `nfs` and `rpcbind`:

        ```bash
        systemctl stop nfs
        systemctl stop rpcbind

        systemctl disable nfs
        systemctl disable rpcbind
        ```
  - uid: mondoo-linux-security-dns-server-is-not-enabled
    title: Ensure DNS server is stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("named").enabled == false
      service("named").running == false
      service("bind9").enabled == false
      service("bind9").running == false
    docs:
      desc: |
        This check verifies that DNS server services such as named (BIND) or bind9 are not running and are disabled on the system.

        **Why this matters**

        DNS servers provide name resolution services by mapping domain names to IP addresses. While essential in network infrastructure roles, running a DNS server on systems that are not explicitly intended to serve DNS requests introduces unnecessary risk.

        If a DNS server is unintentionally left active:
          - It may expose internal network details or zone files to unauthorized users.
          - It can be used in DNS amplification attacks if misconfigured.
          - It increases the system's attack surface through open ports and additional daemon processes.

        Disabling DNS server services on systems that are not authoritative or caching resolvers aligns with the principle of least functionality. This reduces exposure to misconfiguration, limits available network services, and strengthens the host's security posture.
      remediation: |-
        Run this command to stop and disable BIND:

        ```bash
        systemctl stop named
        systemctl stop bind9

        systemctl disable named
        systemctl disable bind9
        ```
  - uid: mondoo-linux-security-ftp-server-is-not-enabled
    title: Ensure FTP servers are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("vsftpd").enabled == false
      service("vsftpd").running == false
      service("proftpd").enabled == false
      service("proftpd").running == false
      service("pure-ftpd").enabled == false
      service("pure-ftpd").running == false
    docs:
      desc: |-
        This check verifies that common FTP server services—vsftpd, proftpd, and pure-ftpd—are not running and are disabled on the system.

        **Why this matters**

        FTP servers enable file transfer over a network but do so using plaintext for both data and credentials, making them inherently insecure. When enabled without encryption or proper controls, FTP services are vulnerable to:
          - Credential theft through packet sniffing
          - Unauthorized file access or modification
          - Abuse in reconnaissance and data exfiltration by attackers

        In most environments, FTP has been replaced by more secure alternatives like SFTP or FTPS, which encrypt both authentication and file transfer traffic. Unless explicitly required, running an FTP server introduces unnecessary risk and increases the system's attack surface.

        Disabling vsftpd, proftpd, and pure-ftpd helps enforce the principle of least functionality by ensuring that legacy, insecure services are not inadvertently exposed or abused.
      remediation: |-
        Run this command to stop and disable `vsftpd`, `proftpd`, and `pure-ftpd`:

        ```bash
        systemctl stop vsftpd
        systemctl disable vsftpd

        systemctl stop proftpd
        systemctl disable proftpd

        systemctl stop pure-ftpd
        systemctl disable pure-ftpd
        ```
  - uid: mondoo-linux-security-http-server-is-not-enabled
    title: Ensure HTTP servers are stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("httpd").enabled == false
      service("httpd").running == false
      service("apache2").enabled == false
      service("apache2").running == false
      service("nginx").enabled == false
      service("nginx").running == false
    docs:
      desc: |
        This check verifies that common HTTP server services such as httpd, apache2, and nginx are not running and are disabled on the system.

        **Why this matters**

        HTTP servers provide web hosting functionality and are often exposed to the network, making them high-value targets for attackers. Unless the system is explicitly intended to serve web content, running these services introduces unnecessary security risk.

        If left enabled:
          - HTTP servers can expose sensitive files or administrative interfaces.
          - They may contain unpatched vulnerabilities that are remotely exploitable.
          - Misconfigurations can lead to data leakage, privilege escalation, or unauthorized access.

        Disabling web servers like Apache and NGINX on systems where they are not required aligns with the principle of least functionality. This reduces the system's attack surface and helps ensure that only essential services are active and maintained.
      remediation: |-
        Run these commands to stop and disable web servers:

        ```bash
        systemctl stop httpd
        systemctl disable httpd

        systemctl stop apache2
        systemctl disable apache2

        systemctl stop nginx
        systemctl disable nginx
        ```
  - uid: mondoo-linux-security-imap-and-pop3-server-is-not-enabled
    title: Ensure IMAP and POP3 servers are stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("dovecot").enabled == false
      service("dovecot").running == false
      service("cyrus-imapd").enabled == false
      service("cyrus-imapd").running == false
    docs:
      desc: |
        This check verifies that common IMAP and POP3 email server services such as dovecot and cyrus-imapd are not running and are disabled from starting at boot.

        **Why this matters**

        IMAP (Internet Message Access Protocol) and POP3 (Post Office Protocol) servers are used to deliver email messages to clients. These services are typically deployed in environments where systems are designated as mail servers. On general-purpose Linux systems or hardened servers, they are rarely required and introduce unnecessary risk if left enabled.

        Running IMAP or POP3 servers where not needed can:
          - Expose authentication services and mail data to the network.
          - Increase the system's attack surface via potentially unpatched or misconfigured mail daemons.
          - Create compliance and privacy issues if email data is improperly stored or transmitted.

        To minimize exposure, systems that do not explicitly require mail delivery services should have dovecot, cyrus-imapd, and similar services disabled. This approach supports the principle of least functionality and reduces the risk of unauthorized access or system compromise.
      remediation: |-
        Run this command to stop and disable `dovecot` and `cyrus-imapd`:

        ```bash
        systemctl stop dovecot
        systemctl disable dovecot

        systemctl stop cyrus-imapd
        systemctl disable cyrus-imapd
        ```
  - uid: mondoo-linux-security-samba-is-not-enabled
    title: Ensure Samba is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("smb").enabled == false
      service("smbd").enabled == false
      service("smb").running == false
      service("smbd").running == false
    docs:
      desc: |
        This check verifies that the Samba services (smb and smbd) are not running and are disabled on the system.

        **Why this matters**

        Samba provides file and print sharing capabilities for interoperability between Linux and Windows systems using the SMB/CIFS protocol. While useful in mixed OS environments that require shared resources, Samba is unnecessary—and potentially risky—on systems that are not intended to serve files or printers over the network.

        If Samba is enabled where not needed:
          - It introduces network-facing services that can be discovered and targeted by attackers.
          - Misconfigurations or outdated Samba versions may allow unauthorized access or remote code execution.
          - It increases the system's attack surface and may expose internal file systems unintentionally.

        To minimize unnecessary exposure, Samba should be disabled on systems that do not explicitly require Windows-compatible file sharing. This approach supports a least functionality model and helps reduce the risk of data leakage or compromise.
      remediation: |-
        Run this command to stop and disable `smb` and `smbd` services:

        ```bash
        systemctl stop smb
        systemctl stop smbd

        systemctl disable smb
        systemctl disable smbd
        ```
  - uid: mondoo-linux-security-http-proxy-server-is-not-enabled
    title: Ensure HTTP Proxy server is stopped and not enabled
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      service("squid").enabled == false
      service("squid").running == false
      service("tinyproxy").enabled == false
      service("tinyproxy").running == false
    docs:
      desc: |
        This check verifies that HTTP proxy services such as squid and tinyproxy are not running and are disabled on the system.

        **Why this matters**

        HTTP proxy servers are used to forward client requests to destination servers, often to enable caching, access control, or anonymization of traffic. While valuable in network perimeter or gateway roles, proxy services are rarely needed on general-purpose Linux systems or hardened servers.

        If an HTTP proxy service is enabled unnecessarily:
          - It may relay traffic without proper filtering or monitoring, exposing the system to misuse or abuse.
          - Misconfigured proxies can be exploited to bypass security controls, leak sensitive information, or allow unauthorized access to internal networks.
          - Proxy daemons increase the system's attack surface through open ports and additional network logic.

        To reduce risk, squid, tinyproxy, and similar services should be stopped and disabled unless the system is explicitly designed to function as a proxy server. This limits unnecessary service exposure and aligns with best practices for host hardening.
      remediation: |-
        Run this command to stop and disable `squid` and `tinyproxy`:

        ```bash
        systemctl stop squid
        systemctl stop tinyproxy

        systemctl disable squid
        systemctl disable tinyproxy
        ```
  - uid: mondoo-linux-security-snmp-server-is-not-enabled
    title: Ensure SNMP server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("snmpd").enabled == false
      service("snmpd").running == false
    docs:
      desc: |
        This check verifies that the SNMP server service (snmpd) is not running and is disabled on the system.

        **Why this matters**

        The Simple Network Management Protocol (SNMP) is used for monitoring and managing network devices. While SNMP can be valuable in infrastructure environments that require centralized device monitoring, it is rarely needed on general-purpose Linux systems or non-networking servers.

        If the SNMP service is enabled unnecessarily:
          - It may expose system and network information to unauthorized users, especially if default community strings are not changed.
          - SNMPv1 and SNMPv2c transmit data in plaintext, making them vulnerable to interception and misuse.
          - Misconfigured or unmonitored SNMP services can be leveraged for network reconnaissance or as part of broader attack campaigns.

        To reduce the risk of information disclosure and limit unnecessary network services, snmpd should be stopped and disabled on systems that are not specifically designated for SNMP-based monitoring. This supports the principle of least functionality and strengthens the system's security posture.
      remediation: |-
        Run this command to stop and disable `snmpd`:

        ```bash
        systemctl stop snmpd
        systemctl disable snmpd
        ```
  - uid: mondoo-linux-security-mail-transfer-agent-is-configured-for-local-only-mode
    title: Ensure mail transfer agent is configured for local-only mode
    impact: 85
    filters: |
      asset.kind != "container-image"
    mql: |
      if( package("postfix").installed && service('postfix').running ) {
        parse.ini("/etc/postfix/main.cf").params["inet_interfaces"] == "localhost" || parse.ini("/etc/postfix/main.cf").params["inet_interfaces"] == "loopback-only"
      }
      if( package("exim4").installed && service('exim4').running ) {
        parse.ini("/etc/exim4/update-exim4.conf.conf").params["dc_local_interfaces"] == "'127.0.0.1 ; ::1'"
      }
      ports.listening.where(address != "127.0.0.1" && address != "[::1]").none(port == 25)
    docs:
      desc: |
        This check verifies that the system's mail transfer agent (MTA), such as Postfix or Exim, is configured to accept and process email only from the local host, rather than listening on external network interfaces.

        **Why this matters**

        Mail transfer agents are used to route and deliver email messages. On most Linux systems, an MTA is installed by default to handle local system notifications, such as cron job outputs or security alerts. However, if the MTA is configured to listen on external interfaces, it may unintentionally expose the system to external email traffic.

        Allowing remote connections to a local MTA can:
          - Turn the system into an open relay if not properly secured.
          - Increase the attack surface by exposing the MTA to brute-force attacks, spoofed messages, or software vulnerabilities.
          - Introduce compliance concerns if email flows are not properly audited or encrypted.

        Configuring the MTA to listen only on the loopback interface (127.0.0.1) ensures it serves only local applications and users. This reduces exposure, limits attack vectors, and aligns with security best practices for systems that are not intended to function as full email servers.
      remediation: |-
        **For Postfix**

        Edit `/etc/postfix/main.cf` and add the following line to the RECEIVING MAIL section. If the line already exists, change it to look like the line below:

        ```
        inet_interfaces = loopback-only
        ```

        Restart postfix:

        ```bash
        systemctl restart postfix
        ```

        **For Exim4 (Debian/Ubuntu)**

        Edit the Exim4 configuration file, typically located at `/etc/exim4/update-exim4.conf.conf``. Find the line that sets `dc_local_interfaces` and modify it to the following:

        ```
        dc_local_interfaces='127.0.0.1 ; ::1'
        ```

        This configuration limits Exim4 to listening only on the loopback IPv4 and IPv6 interfaces.

        After making the change, regenerate the Exim4 runtime configuration and restart the service:

        ```bash
        update-exim4.conf
        systemctl restart exim4
        ```
  - uid: mondoo-linux-security-nis-server-is-not-enabled
    title: Ensure NIS server is stopped and not enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
    mql: |
      service("ypserv").enabled == false
      service("ypserv").running == false
      service("nis").enabled == false
      service("nis").running == false
    docs:
      desc: |
        This check verifies that the Network Information Service (NIS) server services, such as ypserv or nis, are not running and are disabled on the system.

        **Why this matters**

        NIS (formerly known as Yellow Pages) is a legacy directory service protocol used to centrally manage user accounts and configuration data across multiple systems. While once common in UNIX environments, NIS has significant security limitations and has been largely replaced by more secure alternatives like LDAP or Kerberos.

        If the NIS server is enabled unnecessarily:
          - It may transmit sensitive data such as usernames and password hashes in plaintext.
          - NIS lacks modern authentication and encryption mechanisms, making it highly susceptible to eavesdropping and spoofing attacks.
          - Running NIS services can expose the system to unauthorized access or information disclosure, especially in mixed or untrusted networks.

        On systems that are not explicitly designated to serve as NIS servers, ypserv, nis, and related services should be stopped and disabled. This helps enforce the principle of least functionality and significantly reduces the system's vulnerability to legacy protocol risks.
      remediation: |-
        Run this command to stop and disable `ypserv` and `nis` services:

        ```bash
        systemctl stop ypserv
        systemctl stop nis

        systemctl disable ypserv
        systemctl disable nis
        ```
  - uid: mondoo-linux-security-rsh-server-is-not-enabled
    title: Ensure rsh server is stopped and not enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
    mql: |
      service("rsh.socket").enabled == false
      service("rlogin.socket").enabled == false
      service("rexec.socket").enabled == false
      service("rsh.socket").running == false
      service("rlogin.socket").running == false
      service("rexec.socket").running == false
    docs:
      desc: |
        This check verifies that the Remote Shell (rsh) server services—specifically rsh.socket, rlogin.socket, and rexec.socket—are not running and are disabled on the system.

        **Why this matters**

        The rsh suite (which includes rsh, rlogin, and rexec) provides remote command execution and login capabilities over a network. However, these services transmit data, including credentials, in plaintext and rely on weak authentication mechanisms based on hostname and user trust relationships.

        If rsh services are enabled:
          - They expose sensitive data to interception, making the system vulnerable to credential theft.
          - Host-based trust mechanisms (like .rhosts) can be easily bypassed or misconfigured, allowing unauthorized access.
          - They increase the system's attack surface and may be exploited for lateral movement in a compromised environment.

        Because of these risks, rsh is considered obsolete and should be replaced with secure alternatives such as SSH. Disabling rsh, rlogin, and rexec services helps prevent unauthorized remote access and aligns with modern security best practices for system hardening.
      remediation: |-
        Run these commands to stop and disable `rsh`, `rlogin`, and `rexec`:

        ```bash
        systemctl stop rsh.socket
        systemctl stop rlogin.socket
        systemctl stop rexec.socket

        systemctl disable rsh.socket
        systemctl disable rlogin.socket
        systemctl disable rexec.socket
        ```
  - uid: mondoo-linux-security-telnet-server-is-not-enabled
    title: Ensure telnet server is stopped and not enabled
    impact: 90
    filters: |
      asset.kind != "container-image"
    mql: |
      service("telnet.socket").enabled == false
      service("telnet.socket").running == false
    docs:
      desc: |-
        This check verifies that the Telnet server service (telnet.socket) is not running and is disabled on the system.

        **Why this matters**

        Telnet is an older protocol used for remote command-line access over a network. It transmits all data—including usernames and passwords—in plaintext, making it highly insecure for modern environments. Any system using Telnet is vulnerable to eavesdropping, session hijacking, and credential theft.

        If the Telnet server is enabled:
          - It exposes the system to man-in-the-middle attacks due to the lack of encryption.
          - Credentials and session data can be intercepted by any attacker with network access.
          - It creates a significant attack surface that can be exploited by automated tools or targeted threats.

        Modern systems should use secure alternatives such as SSH, which encrypt all communications. Disabling Telnet services on systems where they are not explicitly required strengthens the host's security posture and reduces the risk of unauthorized access.
      remediation: |-
        Run this command to stop and disable telnet:

        ```bash
        systemctl stop telnet.socket
        systemctl disable telnet.socket
        ```
  - uid: mondoo-linux-security-tftp-server-is-not-enabled
    title: Ensure tftp server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("tftp.socket").enabled == false
      service("tftp.socket").running == false
    docs:
      desc: |
        This check verifies that the Trivial File Transfer Protocol (TFTP) server service (tftp.socket) is not running and is disabled on the system.

        **Why this matters**

        TFTP is a simple, lightweight file transfer protocol typically used for tasks such as bootstrapping diskless workstations or network appliances. It lacks authentication, encryption, and access control mechanisms, making it highly insecure for general-purpose or internet-connected systems.

        If the TFTP server is enabled:
          - Files can be read or written without authentication, leading to data leakage or unauthorized modification.
          - Attackers can use TFTP to upload malicious payloads or exfiltrate sensitive files.
          - It may serve as an entry point for lateral movement in network-based attacks, especially in environments with legacy devices.

        Unless TFTP is explicitly required for a specific, isolated use case, the service should be stopped and disabled. Removing unnecessary TFTP services reduces the system's attack surface and aligns with best practices for minimizing unauthenticated network protocols.
      remediation: |-
        Run this command to stop and disable tftp:

        ```bash
        systemctl stop tftp.socket
        systemctl disable tftp.socket
        ```
  - uid: mondoo-linux-security-rsync-service-is-not-enabled
    title: Ensure rsync service is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("rsyncd").enabled == false
      service("rsyncd").running == false
    docs:
      desc: |
        This check verifies that the rsyncd service, which enables the rsync daemon for file synchronization over the network, is not running and is disabled on the system.

        **Why this matters**

        The rsync daemon allows systems to synchronize files with remote hosts. While useful in backup and replication workflows, running rsyncd as a service introduces a network-accessible endpoint that may expose files or directories if not properly secured.

        If the rsync service is enabled unnecessarily:
          - It can expose sensitive files to unauthorized access, especially if authentication is misconfigured or absent.
          - It increases the system's attack surface by opening a network port that could be targeted for exploitation.
          - Unrestricted or anonymous rsync configurations can lead to data exfiltration or integrity compromise.

        Unless the system is explicitly configured to serve files via rsyncd, the service should be disabled. This aligns with the principle of least functionality and helps prevent accidental exposure of file data to untrusted networks.
      remediation: |-
        Run this command to stop and disable `rsync`:

        ```bash
        systemctl stop rsyncd
        systemctl disable rsyncd
        ```
  - uid: mondoo-linux-security-talk-server-is-not-enabled
    title: Ensure talk server is stopped and not enabled
    impact: 100
    filters: |
      asset.kind != "container-image"
    mql: |
      service("ntalk").enabled == false
      service("ntalk").running == false
      service("talkd").enabled == false
      service("talkd").running == false
    docs:
      desc: |
        The talk protocol enables real-time text-based communication between users on UNIX systems. The talk server (talkd or ntalk) listens for incoming connection requests and facilitates terminal-to-terminal chat sessions. However, this protocol is outdated and lacks encryption or strong authentication mechanisms.

        If the talk server is enabled:
          - It exposes the system to network-based attacks through an unnecessary and insecure service.
          - Messages are transmitted in plaintext, allowing for potential interception and eavesdropping.
          - The service increases the system's attack surface and may be abused for denial-of-service attacks or unauthorized user messaging.

        Since modern environments use more secure communication tools, talk services should be disabled on systems where they are not explicitly required. This minimizes risk and helps enforce a minimal, hardened system configuration.
      remediation: |-
        Run this command to stop and disable talk:

        ```bash
        systemctl stop ntalk
        systemctl stop talkd

        systemctl disable ntalk
        systemctl disable talkd
        ```
  - uid: mondoo-linux-security-ip-forwarding-is-disabled
    title: Ensure IP forwarding is disabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.ip_forward'] == 0
        || kernel.parameters['net.ipv4.ip_forward'] == null
      kernel.parameters['net.ipv6.conf.all.forwarding'] == 0
        || kernel.parameters['net.ipv6.conf.all.forwarding'] == null
    docs:
      desc: |
        This check verifies that IP forwarding is disabled by confirming that the kernel parameters net.ipv4.ip_forward and net.ipv6.conf.all.forwarding are set to 0.

        **Why this matters**

        IP forwarding allows a system to route network packets between interfaces, effectively enabling it to act as a router. While necessary for certain network infrastructure roles, IP forwarding is not appropriate for general-purpose servers, workstations, or systems that are not explicitly configured to route traffic.

        If IP forwarding is enabled unnecessarily:
          - The system could be used to redirect or intercept network traffic, intentionally or accidentally.
          - It increases the risk of network misconfiguration, data leakage, or man-in-the-middle attacks.
          - It may violate segmentation and isolation policies in secure environments.

        Disabling IP forwarding ensures the system cannot forward packets between networks, reducing the potential for misuse or compromise. This helps maintain clear boundaries between network zones and supports a more secure and predictable system configuration.
      remediation: |-
        Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.ip_forward = 0

        net.ipv6.conf.all.forwarding = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.ip_forward=0
        sysctl -w net.ipv4.route.flush=1

        sysctl -w net.ipv6.conf.all.forwarding=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-packet-redirect-sending-is-disabled
    title: Ensure packet redirect sending is disabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.send_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.send_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.send_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.send_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to not send ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.send_redirects` and `net.ipv4.conf.default.send_redirects` are set to `0`.

        **Why this matters**

        ICMP redirect messages are used by routers to inform hosts of a more efficient route for reaching a destination. However, on systems that are not functioning as routers, this feature is unnecessary and can introduce security risks.

        If packet redirect sending is enabled:
          - The system could inadvertently influence the routing behavior of other devices on the network.
          - Malicious actors could exploit redirect functionality to reroute traffic through compromised or untrusted devices.
          - It increases the complexity and unpredictability of network traffic flow, complicating security monitoring and enforcement.

        Disabling the ability to send ICMP redirects on non-router systems prevents unauthorized route manipulation and supports secure, well-defined network behavior. This reduces the risk of traffic interception or redirection by adversaries.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.send_redirects = 0
        net.ipv4.conf.default.send_redirects = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.send_redirects=0
        sysctl -w net.ipv4.conf.default.send_redirects=0
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-source-routed-packets-are-not-accepted
    title: Ensure source routed packets are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.accept_source_route'] == 0
        || kernel.parameters['net.ipv4.conf.all.accept_source_route'] == null
      kernel.parameters['net.ipv4.conf.default.accept_source_route'] == 0
        || kernel.parameters['net.ipv4.conf.default.accept_source_route'] == null
      kernel.parameters['net.ipv6.conf.all.accept_source_route'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_source_route'] == null
      kernel.parameters['net.ipv6.conf.default.accept_source_route'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_source_route'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject source-routed packets by ensuring the kernel parameters `net.ipv4.conf.all.accept_source_route`, `net.ipv4.conf.default.accept_source_route`, `net.ipv6.conf.all.accept_source_route`, and `net.ipv6.conf.default.accept_source_route` are set to `0`.

        **Why this matters**

        Source routing allows the sender of a packet to specify the exact path it should take through the network. While this feature was designed for network troubleshooting, it is rarely used in modern environments and poses significant security risks.

        If source-routed packets are accepted:
          - Attackers can bypass network routing controls and firewall rules by crafting packets with arbitrary paths.
          - It enables traffic spoofing and man-in-the-middle attacks by redirecting data through attacker-controlled systems.
          - It undermines network segmentation and isolation policies.

        Disabling acceptance of source-routed packets ensures that the system only processes packets routed according to the network's standard path selection, reducing the risk of exploitation and reinforcing a secure network posture.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.accept_source_route = 0
        net.ipv4.conf.default.accept_source_route = 0
        net.ipv6.conf.all.accept_source_route = 0
        net.ipv6.conf.default.accept_source_route = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.accept_source_route=0
        sysctl -w net.ipv4.conf.default.accept_source_route=0
        sysctl -w net.ipv4.route.flush=1

        sysctl -w net.ipv6.conf.all.accept_source_route=0
        sysctl -w net.ipv6.conf.default.accept_source_route=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-icmp-redirects-are-not-accepted
    title: Ensure ICMP redirects are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.accept_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.accept_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.accept_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.accept_redirects'] == null
      kernel.parameters['net.ipv6.conf.all.accept_redirects'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_redirects'] == null
      kernel.parameters['net.ipv6.conf.default.accept_redirects'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.accept_redirects`, `net.ipv4.conf.default.accept_redirects`, `net.ipv6.conf.all.accept_redirects`, and `net.ipv6.conf.default.accept_redirects` are set to `0`.

        **Why this matters**

        ICMP redirect messages are used by routers to inform hosts of a better route for reaching a destination. While intended to optimize network traffic, accepting these messages on non-router systems can introduce serious security risks.

        If ICMP redirects are accepted:
          - Attackers can exploit this to alter the routing table of a host, redirecting traffic through malicious devices.
          - It creates opportunities for man-in-the-middle attacks, traffic interception, or denial-of-service.
          - It makes network traffic paths unpredictable and harder to audit or monitor effectively.

        Disabling ICMP redirect acceptance ensures that the system maintains static and trusted routing behavior, helping to preserve network integrity and defend against unauthorized routing changes.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.accept_redirects = 0
        net.ipv4.conf.default.accept_redirects = 0
        net.ipv6.conf.all.accept_redirects = 0
        net.ipv6.conf.default.accept_redirects = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.accept_redirects=0
        sysctl -w net.ipv4.conf.default.accept_redirects=0
        sysctl -w net.ipv4.route.flush=1

        sysctl -w net.ipv6.conf.all.accept_redirects=0
        sysctl -w net.ipv6.conf.default.accept_redirects=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-secure-icmp-redirects-are-not-accepted
    title: Ensure secure ICMP redirects are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.secure_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.all.secure_redirects'] == null
      kernel.parameters['net.ipv4.conf.default.secure_redirects'] == 0
        || kernel.parameters['net.ipv4.conf.default.secure_redirects'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject secure ICMP redirect messages by ensuring the kernel parameters `net.ipv4.conf.all.secure_redirects` and `net.ipv4.conf.default.secure_redirects` are set to `0`.

        **Why this matters**

        Secure ICMP redirects are a variant of ICMP redirect messages that are accepted only from gateways listed in the system's default gateway table. While they are intended to provide safer route optimization, accepting any form of redirect introduces risk by allowing remote influence over local routing decisions.

        If secure ICMP redirects are accepted:
          - An attacker controlling or spoofing a default gateway could influence traffic paths.
          - It increases the likelihood of man-in-the-middle attacks by rerouting data through malicious intermediaries.
          - It undermines the reliability of static routing configurations and may conflict with security controls or monitoring systems.

        Disabling acceptance of secure ICMP redirects ensures that routing updates are not accepted dynamically from potentially compromised gateways. This strengthens network security by enforcing a more predictable and tightly controlled routing posture.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.secure_redirects = 0
        net.ipv4.conf.default.secure_redirects = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.secure_redirects=0
        sysctl -w net.ipv4.conf.default.secure_redirects=0
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-suspicious-packets-are-logged
    title: Ensure suspicious packets are logged
    impact: 60
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.log_martians'] == 1
      kernel.parameters['net.ipv4.conf.default.log_martians'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to log suspicious or malformed packets by ensuring the kernel parameters `net.ipv4.conf.all.log_martians` and `net.ipv4.conf.default.log_martians` are set to `1`.

        **Why this matters**

        Martian packets are packets with impossible or invalid source addresses, such as those that should not appear on the public internet or within specific segments of a private network. Logging these packets helps administrators detect potential misconfigurations or malicious activity, such as spoofed traffic or scanning attempts.

        If logging of suspicious packets is not enabled:
          - Unusual or invalid network traffic may go undetected, reducing visibility into potential reconnaissance or attack attempts.
          - Misconfigured hosts or routing issues may persist without notice, leading to degraded performance or security gaps.
          - Incident response and forensic analysis capabilities are weakened due to lack of log data.

        Enabling logging for martian packets provides valuable insights into unusual traffic patterns and supports early detection of threats or misconfigurations. This improves network observability and supports a proactive security posture.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` or in /etc/ufw/sysctl.conf file:

        ```
        net.ipv4.conf.all.log_martians = 1
        net.ipv4.conf.default.log_martians = 1
        ```

        Hint: If you're using Ubuntu's UFW, please check the for the above configuration in the file /etc/ufw/sysctl.conf in addition, because these settings will overwrite the kernel parameters on UFW startup.

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.log_martians=1
        sysctl -w net.ipv4.conf.default.log_martians=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-broadcast-icmp-requests-are-ignored
    title: Ensure broadcast ICMP requests are ignored
    impact: 60
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.icmp_echo_ignore_broadcasts'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to ignore ICMP echo requests sent to broadcast or multicast addresses by ensuring the kernel parameter `net.ipv4.icmp_echo_ignore_broadcasts` is set to `1`.

        **Why this matters**

        ICMP echo requests sent to broadcast addresses can be used in amplification attacks, such as the Smurf attack, where a single ICMP request can generate a large volume of responses from multiple hosts. This can lead to denial-of-service conditions for targeted systems or network segments.

        If broadcast ICMP requests are not ignored:
          - The system may be exploited as part of a distributed denial-of-service (DDoS) attack.
          - Network resources may be consumed by processing and responding to unnecessary or malicious requests.
          - Attackers can use broadcast ICMP traffic to map networks or identify live hosts.

        Ignoring broadcast ICMP requests reduces the likelihood that the system can be leveraged in amplification attacks and helps maintain the integrity and availability of the network. This is particularly important in environments where network resources are limited or where systems are exposed to untrusted networks.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.icmp_echo_ignore_broadcasts = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-bogus-icmp-responses-are-ignored
    title: Ensure bogus ICMP responses are ignored
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.icmp_ignore_bogus_error_responses'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to ignore bogus ICMP error responses by ensuring the kernel parameter `net.ipv4.icmp_ignore_bogus_error_responses` is set to `1`.

        **Why this matters**

        Bogus ICMP error responses are non-compliant or malformed ICMP messages that do not correspond to any legitimate traffic. These can be generated accidentally by misconfigured devices or intentionally by attackers attempting to disrupt or confuse network communications.

        If bogus ICMP responses are not ignored:
          - The system may log unnecessary or misleading error messages, cluttering logs and making it harder to identify real issues.
          - Attackers may exploit this setting to flood logs or trigger unstable behavior in poorly configured systems.
          - It may lead to resource exhaustion or degradation of network performance in environments with high volumes of invalid traffic.

        By ignoring bogus ICMP error responses, the system avoids reacting to malformed or irrelevant network messages, helping to maintain cleaner logs and more stable network operations.
      remediation: |-
        Set the following parameter in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.icmp_ignore_bogus_error_responses = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-reverse-path-filtering-is-enabled
    title: Ensure Reverse Path Filtering is enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.conf.all.rp_filter'] == 1
      kernel.parameters['net.ipv4.conf.default.rp_filter'] == 1
    docs:
      desc: |
        This check verifies that reverse path filtering is active by ensuring the kernel parameters `net.ipv4.conf.all.rp_filter` and `net.ipv4.conf.default.rp_filter` are set to `1`.

        **Why this matters**

        Reverse Path Filtering is a security mechanism that helps prevent IP spoofing by verifying that the source of a packet has a valid route back to the receiving interface. If a packet arrives on an interface and the system would not use that same interface to reach the source IP, the packet is dropped.

        If reverse path filtering is not enabled:
          - Spoofed packets with forged source addresses may be accepted, allowing attackers to bypass basic network controls.
          - Systems may become vulnerable to reflection and amplification attacks.
          - It undermines the reliability of source-based filtering and complicates network traffic analysis.

        Enabling reverse path filtering ensures the system performs sanity checks on incoming traffic, which helps prevent IP spoofing and enhances the integrity of network communications. It is an important safeguard in both perimeter and internal network environments.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.conf.all.rp_filter = 1
        net.ipv4.conf.default.rp_filter = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.conf.all.rp_filter=1
        sysctl -w net.ipv4.conf.default.rp_filter=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-tcp-syn-cookies-is-enabled
    title: Ensure TCP SYN Cookies is enabled
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv4.tcp_syncookies'] == 1
    docs:
      desc: |
        This check verifies that the system is configured to use TCP SYN cookies by ensuring the kernel parameter `net.ipv4.tcp_syncookies` is set to `1`.

        **Why this matters**

        TCP SYN cookies are a defense mechanism against SYN flood attacks, a type of denial-of-service (DoS) attack where an attacker sends a large number of TCP connection requests without completing the handshake. This consumes server resources and can prevent legitimate users from establishing connections.

        When SYN cookies are enabled:
          - The system avoids allocating memory for incomplete TCP handshakes by encoding connection information into the TCP sequence number.
          - It allows the server to continue responding to new connection requests even when the SYN backlog is full.
          - It helps maintain availability and resilience under high connection request loads or malicious activity.

        Without SYN cookies, systems are more susceptible to resource exhaustion during a SYN flood. Enabling this feature strengthens the host's ability to withstand network-based denial-of-service attempts and helps ensure reliable TCP service availability.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv4.tcp_syncookies = 1
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv4.tcp_syncookies=1
        sysctl -w net.ipv4.route.flush=1
        ```
  - uid: mondoo-linux-security-ipv6-router-advertisements-are-not-accepted
    title: Ensure IPv6 router advertisements are not accepted
    impact: 75
    filters: |
      asset.kind != "container-image"
      asset.runtime != "docker-container"
    mql: |
      kernel.parameters['net.ipv6.conf.all.accept_ra'] == 0
        || kernel.parameters['net.ipv6.conf.all.accept_ra'] == null
      kernel.parameters['net.ipv6.conf.default.accept_ra'] == 0
        || kernel.parameters['net.ipv6.conf.default.accept_ra'] == null
    docs:
      desc: |
        This check verifies that the system is configured to reject IPv6 router advertisements by ensuring the kernel parameters `net.ipv6.conf.all.accept_ra` and `net.ipv6.conf.default.accept_ra` are set to `0`.

        **Why this matters**

        IPv6 router advertisements (RAs) are used by routers to inform hosts about network configuration settings, such as default gateways and prefix information. While useful in dynamic network environments, accepting unsolicited RAs on systems that are not mobile or router-dependent can introduce security risks.

        If IPv6 router advertisements are accepted:
          - Malicious or misconfigured devices on the network could inject rogue RAs, redirecting traffic or altering host routing tables.
          - Attackers could exploit this to perform man-in-the-middle attacks, traffic interception, or denial-of-service.
          - It undermines predictable network configuration and may conflict with security policies that rely on static or managed routing.

        Disabling acceptance of IPv6 router advertisements helps ensure that routing configuration is controlled explicitly, reducing the likelihood of unauthorized or harmful route changes on the host.
      remediation: |-
        Set the following parameters in `/etc/sysctl.conf` or a `/etc/sysctl.d/` file:

        ```
        net.ipv6.conf.all.accept_ra = 0
        net.ipv6.conf.default.accept_ra = 0
        ```

        Run these commands to set the active kernel parameters:

        ```bash
        sysctl -w net.ipv6.conf.all.accept_ra=0
        sysctl -w net.ipv6.conf.default.accept_ra=0
        sysctl -w net.ipv6.route.flush=1
        ```
  - uid: mondoo-linux-security-auditd-is-installed-and-running
    title: Ensure auditd is installed, enabled, and running
    impact: 50
    mql: |
      package("auditd").installed && package("audispd-plugins").installed
      || package("audit").installed || package("audit-libs").installed
      service("auditd").enabled
      service("auditd").running
    docs:
      desc: |
        This check verifies that the auditd package is installed on the system and that the auditd service is both enabled and running.

        **Why this matters**

        auditd is the core component of the Linux Auditing System, responsible for collecting, processing, and writing audit records to disk. These records provide detailed visibility into system-level activities such as user logins, file access, command execution, and permission changes.

        Ensuring that auditd is installed and actively running is essential for:
          - Capturing a reliable audit trail of security-relevant events.
          - Supporting forensic investigations and incident response efforts.
          - Meeting regulatory and organizational compliance requirements that mandate audit logging.
          - Detecting suspicious or unauthorized behavior on the system in near real time.

        If auditd is not installed, or if the service is disabled or inactive:
          - No audit logs will be recorded, creating blind spots in system monitoring.
          - Critical evidence may be lost during or after an attack.
          - The system may fall out of compliance with standards that require audit functionality.

        By installing and enabling auditd, organizations ensure consistent audit logging is in place, improving accountability and strengthening overall system security.
      remediation: |-
        ### Install auditd

        **RHEL/Fedora/Amazon Linux and derivatives**

        ```bash
        dnf install audit audit-libs
        ```

        **Debian/Ubuntu and derivatives**

        ```bash
        apt-get install auditd audispd-plugins
        ```

        **SLES and openSUSE**

        ```bash
        zypper install audit
        ```

        ### Enable auditd

        ```bash
        systemctl --now enable auditd
        ```
  - uid: mondoo-linux-security-auditing-for-processes-that-start-prior-to-auditd-is-enabled
    title: Ensure auditing for processes that start prior to auditd is enabled
    impact: 50
    mql: |
      switch {
        case file("/boot/grub2/grubenv").exists:
          file("/boot/grub2/grubenv").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub2/grub.cfg").exists:
          file("/boot/grub2/grub.cfg").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub/grub.cfg").exists:
          file("/boot/grub/grub.cfg").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/boot/grub/grub.conf").exists:
          file("/boot/grub/grub.conf").content.lines.where( _ == /^[^#]/ )
            .any(_ == /audit(\s+)?\=(\s+)?1/);
        case file("/etc/secboot/config.json").exists:
          parse.json('/etc/secboot/config.json')
            .params['kernel-params'] == /audit(\s+)?\=(\s+)?1/;
        default: false
      }
    docs:
      desc: |
        This check verifies that the system's GRUB bootloader is configured to pass the audit=1 kernel parameter, which ensures that auditing is enabled from the earliest stages of system initialization—even before the auditd daemon starts.

        **Why this matters**

        By default, some processes may start before auditd is initialized, especially during early boot. Without early auditing enabled, actions taken by these processes can go unrecorded, creating a blind spot in audit logs and weakening the system's ability to track critical events.

        If the audit=1 kernel parameter is not set:
          - Early-boot processes such as init systems, kernel modules, or startup scripts may execute without being logged.
          - Attackers or misconfigurations could exploit this window to perform actions undetected.
          - The system's audit trail may be incomplete, undermining trust in audit data and complicating incident response or compliance reviews.

        Adding audit=1 to the GRUB configuration ensures that the Linux kernel begins generating audit records as soon as it starts, capturing all auditable activity regardless of when auditd is fully initialized. This enhances the completeness and integrity of audit logging across the system lifecycle.
      remediation: |-
        Edit `/etc/default/grub` and add `audit=1` to `GRUB_CMDLINE_LINUX`:

        ```
        GRUB_CMDLINE_LINUX="audit=1"
        ```

        Run this command to update the `grub2` configuration:

        ### RHEL/Fedora/Amazon Linux and derivatives

        For BIOS systems:

        ```bash
        grub2-mkconfig -o /boot/grub2/grub.cfg
        ```

        For UEFI systems:

        ```bash
        grub2-mkconfig -o /boot/efi/EFI/<distribution>/grub.cfg
        ```

        Replace `<distribution>` with your distribution's directory name (e.g., `centos`, `redhat`, `fedora`).

        ### Debian/Ubuntu and derivatives

        ```bash
        update-grub
        ```
  - uid: mondoo-linux-security-audit-log-storage-size-is-configured
    title: Ensure audit log storage size is configured
    impact: 40
    mql: |
      file("/etc/audit/auditd.conf").exists;
      ["/etc/audit/auditd.conf"].where(file(_).exists) {
        parse.ini(_).params["max_log_file"] > 0
      }
    docs:
      desc: |
        This check verifies that the auditd configuration specifies a maximum storage size for audit logs by ensuring the `max_log_file` parameter in `/etc/audit/auditd.conf` is set to a value greater than zero.

        **Why this matters**

        The `max_log_file` setting defines the maximum size (in megabytes) that an audit log file can grow before it is rotated. Without this limit, audit logs can consume excessive disk space, leading to system performance degradation or failures—especially on systems with limited storage or extensive auditing.

        If audit log size is not properly configured:
          - Log files may grow indefinitely and fill the disk, potentially causing services to fail or the system to become unresponsive.
          - Critical audit data may be lost if the system cannot write to a full disk.
          - Administrators may be unaware of abnormal log volume trends, missing opportunities for early detection of suspicious activity.

        Configuring max_log_file helps maintain system stability by preventing uncontrolled log growth. It also supports log management practices such as automated rotation and retention policies, ensuring that audit data remains available without jeopardizing system operations.
      remediation: |-
        Set the following parameter in `/etc/audit/auditd.conf` in accordance with site policy:

        ```
        max_log_file = <MB>
        ```

        Restart the service to load the new configuration values:

        ```bash
        service auditd reload
        ```
  - uid: mondoo-linux-security-audit-logs-are-not-automatically-deleted
    title: Ensure audit logs are not automatically deleted
    impact: 40
    mql: |
      file("/etc/audit/auditd.conf").exists;
      ["/etc/audit/auditd.conf"].where(file(_).exists) {
        parse.ini(_).params["max_log_file_action"].downcase == "keep_logs"
      }
    docs:
      desc: |
        This check verifies that the system is configured to retain audit logs by ensuring the `max_log_file_action` parameter in `/etc/audit/auditd.conf`` is set to `keep_logs`.

        **Why this matters**

        The `max_log_file_action` setting controls how auditd behaves when an audit log file reaches its maximum size. Setting it to keep_logs ensures that old logs are preserved rather than deleted or overwritten, supporting long-term retention and forensic traceability.

        If audit logs are automatically deleted:
          - Critical historical data may be lost, undermining the ability to investigate past events or security incidents.
          - Organizations may fall out of compliance with regulatory requirements that mandate audit log retention.
          - Incident response efforts may be hindered by incomplete log records.

        By configuring auditd to preserve logs, the system ensures that valuable audit data is available when needed for security analysis, compliance reviews, or legal investigation. This supports a more robust and accountable auditing strategy.
      remediation: |-
        Set the following parameter in `/etc/audit/auditd.conf`:

        ```
        max_log_file_action = keep_logs
        ```

        Restart the service to load the new configuration values:

        ```bash
        service auditd reload
        ```
  - uid: mondoo-linux-security-system-is-disabled-when-audit-logs-are-full
    title: Ensure system is disabled when audit logs are full
    impact: 40
    filters: |
      asset.kind != "container-image"
    mql: |
      file("/etc/audit/auditd.conf").exists;
      ["/etc/audit/auditd.conf"].where(file(_).exists) {
        parse.ini(_) {
          params["space_left_action"].downcase == /email|exec|single|halt/
          params["action_mail_acct"].downcase == "root"
          params["admin_space_left_action"].downcase == /halt|single/
        }
      }
    docs:
      desc: |-
        This check verifies that the system is configured to disable itself when audit logs are full by ensuring the `space_left_action` and `admin_space_left_action` parameters in `/etc/audit/auditd.conf` are set to appropriate values.

        **Why this matters**

        The `space_left_action` setting determines what action auditd takes when disk space for audit logs is low. The `admin_space_left_action` setting specifies the action when space is critically low. Setting these to halt or single ensures that the system does not continue operating with potentially compromised logging capabilities.

        If the system does not disable itself when audit logs are full:
          - Crucial audit data may be lost, leading to gaps in security monitoring.
          - The system may continue to operate without proper oversight, increasing the risk of undetected malicious activity.
          - Compliance with regulatory requirements for audit logging may be jeopardized.

        Configuring these parameters helps ensure that the system maintains a secure state and that audit logging remains functional, even under adverse conditions.
      remediation: |-
        Set the following parameters in `/etc/audit/auditd.conf`:

        ```
        space_left_action = email
        action_mail_acct = root
        admin_space_left_action = halt
        ```

        Restart the service to load the new configuration values:

        ```bash
        service auditd reload
        ```
  - uid: mondoo-linux-security-changes-to-system-administration-scope-sudoers-is-collected
    title: Ensure changes to system administration scope (sudoers) is collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/sudoers\.d(\/?)\s+\-p\s+wa\s+\-k\s+scope(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/sudoers(\/?)\s+\-p\s+wa\s+\-k\s+scope(\s+)?$/))
    docs:
      desc: |
        This check verifies that auditd is configured to monitor changes to the system administration scope (sudoers). The parameters below track changes to files associated with sudoers.

        - The file `/etc/sudoers` is the main configuration file for sudo.
        - The `/etc/sudoers.d/` directory contains additional configuration files for sudo.

        **Why this matters**

        Monitoring changes to the sudoers file and its associated directory is critical for maintaining system security. Unauthorized modifications can lead to privilege escalation, unauthorized access, or other malicious activities.

        If monitoring is not enabled:
          - Changes to sudo permissions may go undetected, allowing unauthorized users to gain elevated privileges.
          - It becomes difficult to track who made changes and when, complicating incident response efforts.
          - The system may fall out of compliance with security policies or regulatory requirements.

        By ensuring that changes to the sudoers file and directory are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-scope.rules`

        Add the following lines:

        ```
        -w /etc/sudoers -p wa -k scope
        -w /etc/sudoers.d -p wa -k scope
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-login-and-logout-events-are-collected
    title: Ensure login and logout events are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    variants:
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-debian
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-rhel
      - uid: mondoo-linux-security-login-and-logout-events-are-collected-other
    docs:
      desc: |
        This check verifies that auditd is configured to monitor login and logout events. The parameters in this section track changes to the files associated with login and logout events. The file `/var/log/lastlog` tracks the last login of each user. The file `/var/log/tallylog` tracks failed login attempts. The file `/var/run/faillock` is used by the `pam_faillock` module to track failed authentication attempts. All audit records will be tagged with the identifier "logins."

        **Why this matters**

        Monitoring login and logout events is critical for maintaining system security. Unauthorized access attempts or successful logins by malicious actors can lead to data breaches, privilege escalation, or other security incidents.

        If monitoring is not enabled:
          - Unauthorized login attempts may go undetected, allowing attackers to gain access to the system.
          - Legitimate user activity may be obscured, complicating incident response efforts.
          - The system may fall out of compliance with security policies or regulatory requirements.

        By ensuring that login and logout events are monitored, organizations can maintain a secure environment and quickly respond to potential threats. This is particularly important in environments with sensitive data or critical infrastructure.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-logins.rules`

        Add the following lines:

        ```
        -w /var/log/lastlog -p wa -k logins
        -w /var/log/tallylog -p wa -k logins
        ```

        Add the following additional line for Debian/Ubuntu based systems:

        ```
        -w /var/log/faillog -p wa -k logins
        ```

        Add the following additional line for Red Hat/Fedora/Amazon Linux based systems:

        ```
        -w /var/run/faillock -p wa -k logins
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-debian
    filters: asset.family.contains("debian")
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/faillog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/log\/faillog|\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-rhel
    filters: asset.family.contains("redhat") || asset.platform == "amazonlinux"
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/run\/faillock/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/run\/faillock|\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-login-and-logout-events-are-collected-other
    filters: asset.family.contains(/redhat|debian/) == false && asset.platform != "amazonlinux"
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/lastlog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/var\/log\/tallylog/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/var\/log\/lastlog|\/var\/log\/tallylog/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","logins"])
            || split(" ").containsAll(["-F","key=logins"])
      )
  - uid: mondoo-linux-security-session-initiation-information-is-collected
    title: Ensure session initiation information is collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/run\/utmp\s+\-p\s+wa\s+\-k\s+session(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/wtmp\s+\-p\s+wa\s+\-k\s+(logins|session)(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/btmp\s+\-p\s+wa\s+\-k\s+(logins|session)(\s+)?$/))
    docs:
      desc: |-
        This check verifies that the system is configured to record session start events in the audit logs, ensuring that audit rules are in place to track successful login sessions using the auditd subsystem.

        **Why this matters**

        Capturing session initiation information—such as user logins and terminal access—is essential for establishing a complete record of user activity. These events mark the beginning of user interactions with the system and provide vital context for analyzing subsequent actions.

        If session initiation is not logged:
          •	User activity cannot be reliably correlated to specific sessions, weakening audit trails.
          •	Security incidents such as unauthorized access or lateral movement may go undetected.
          •	Compliance with security standards and regulatory frameworks that require session logging may be compromised.

        By ensuring session start events are audited, organizations gain visibility into who accessed the system and when, supporting effective monitoring, incident investigation, and user accountability. This forms a foundational element of audit-based security controls.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-session.rules`

        Add the following lines:

        ```
        -w /var/run/utmp -p wa -k session
        -w /var/log/wtmp -p wa -k logins
        -w /var/log/btmp -p wa -k logins
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-date-and-time-information-are-collected
    title: Ensure events that modify date and time information are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /settimeofday/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /clock_settime/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /adjtimex/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /settimeofday|clock_settime|adjtimex/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-F", "key=time-change"])
            || split(" ").containsAll(["-k", "time-change"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(/\/etc\/localtime/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(/\/etc\/localtime/).all(
        split("-").containsAll(["w /etc/localtime ","p wa ",])
          && split(" ").containsAll(["-F", "key=time-change"])
            || split(" ").containsAll(["-k", "time-change"])
      )
    docs:
      desc: |-
        This check verifies that the audit system is configured to log all events that change the system’s date and time settings, including modifications to the system clock and timezone.

        **Why this matters**

        Accurate system time is critical for security auditing, log correlation, and incident investigation. If an attacker or unauthorized user alters the system time, it can obscure malicious activity, disrupt monitoring tools, and compromise the integrity of audit logs.

        If changes to date and time settings are not audited:
          •	Malicious modifications may go unnoticed, allowing attackers to hide their tracks.
          •	Log timestamps may become unreliable, complicating forensic analysis.
          •	Compliance with standards that require time synchronization and audit log integrity may be violated.

        By auditing all date and time modifications, administrators can detect tampering attempts, verify system integrity, and maintain a trustworthy timeline of system events. This ensures that audit logs remain a reliable source of truth during security reviews and investigations.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`_

        Example: `vi /etc/audit/rules.d/50-time_change.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
        -a always,exit -F arch=b32 -S clock_settime -k time-change
        -w /etc/localtime -p wa -k time-change
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-time_change.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
        -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
        -a always,exit -F arch=b64 -S clock_settime -k time-change
        -a always,exit -F arch=b32 -S clock_settime -k time-change
        -w /etc/localtime -p wa -k time-change
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-mandatory-access-controls-are-collected
    title: Ensure events that modify the system's Mandatory Access Controls are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      appArmorSys = props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/apparmor(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
        && props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/apparmor.d(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
      seLinuxSys = props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/selinux(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
       && props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/usr\/share\/selinux(\/?)\s+\-p\s+wa\s+\-k\s+MAC-policy(\s+)?$/))
      appArmorSys || seLinuxSys
    docs:
      desc: |-
        This check verifies that the audit system is configured to log changes to the system’s Mandatory Access Control (MAC) configurations, such as modifications to SELinux or AppArmor policies.

        Why this matters

        Mandatory Access Controls enforce strict rules about which subjects (users, processes) can access which objects (files, resources) beyond traditional discretionary permissions. Changes to MAC settings directly impact the system’s security posture and can either strengthen or weaken its defenses.

        If modifications to MAC configurations are not audited:
          •	Unauthorized or malicious changes may go undetected, potentially disabling key security mechanisms.
          •	Administrators may be unaware of policy alterations that expose the system to privilege escalation or data leakage.
          •	The system’s compliance with security frameworks requiring MAC enforcement may be compromised.

        Logging events that alter SELinux modes, AppArmor profiles, or related configuration files helps ensure that all security policy changes are tracked and attributable. This supports continuous monitoring, strengthens control over access enforcement, and enhances trust in the system’s security model.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-MAC_policy.rules`

        Add the following lines, for SELinux:

        ```
        -w /etc/selinux/ -p wa -k MAC-policy
        -w /usr/share/selinux/ -p wa -k MAC-policy
        ```

        Add the following lines, for AppArmor:

        ```
        -w /etc/apparmor/ -p wa -k MAC-policy
        -w /etc/apparmor.d/ -p wa -k MAC-policy
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected
    title: Ensure events that modify the system's network environment are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    variants:
    - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-debian-rhel
    - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-other
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-debian-rhel
    filters: asset.family.contains(/redhat|debian/) == true
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /sethostname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setdomainname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /sethostname|setdomainname/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue.net/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/hosts/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/sysconfig\/network/)
        || props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/network/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/etc\/issue|\/etc\/issue.net|\/etc\/hosts|\/etc\/sysconfig\/network|\/etc\/network/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
  - uid: mondoo-linux-security-events-that-modify-the-systems-network-environment-are-collected-other
    filters: asset.family.contains(/redhat|debian/) == false
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /sethostname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setdomainname/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /sethostname|setdomainname/).all(
        split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/issue.net/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /\/etc\/hosts/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /\/etc\/issue|\/etc\/issue.net|\/etc\/hosts/).all(
        split("-").contains(/p wa/)
          && split(" ").containsAll(["-k","system-locale"])
            || split(" ").containsAll(["-F","key=system-locale"])
      )
    docs:
      desc: |
        This check verifies that the audit system is configured to record changes to key network configuration files and system identity settings by monitoring specific system calls and file paths.

        **Why this matters**

        Changes to the system's hostname, domain name, or core network-related files can alter how the system identifies itself and interacts with other hosts. These modifications may indicate reconfiguration, misconfiguration, or unauthorized tampering.

        If these events are not audited:
          •	Changes to system identity (via sethostname or setdomainname) may go untracked, affecting asset management and security visibility.
          •	Modifications to files like `/etc/hosts`, `/etc/issue`, or `/etc/sysconfig/network` could enable social engineering, redirect network traffic, or disrupt connectivity.
          •	Attackers may exploit these files to mask their activity or persist on the system.

        By auditing the sethostname and setdomainname system calls and monitoring changes to `/etc/issue`, `/etc/issue.net`, `/etc/hosts`, and `/etc/sysconfig/network`, administrators can detect critical network and identity changes. This supports system integrity, operational consistency, and incident investigation efforts.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-system_local.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale
        -w /etc/issue -p wa -k system-locale
        -w /etc/issue.net -p wa -k system-locale
        -w /etc/hosts -p wa -k system-locale
        ```

        Add the following line on Red Hat based systems:

        ```
        -w /etc/sysconfig/network -p wa -k system-locale
        ```

        Add the following line for Debian/Ubuntu based systems:

        ```
        -w /etc/network -p wa -k system-locale
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-system_local.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
        -a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale

        -w /etc/issue -p wa -k system-locale
        -w /etc/issue.net -p wa -k system-locale
        -w /etc/hosts -p wa -k system-locale
        ```

        Add the following line for Red Hat based systems:

        ```
        -w /etc/sysconfig/network -p wa -k system-locale
        ```

        Add the following line for Debian/Ubuntu based systems:

        ```
        -w /etc/network -p wa -k system-locale
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-discretionary-access-control-permission-modification-events-are-collected
    title: Ensure discretionary access control permission modification events are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /chmod/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchmod/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchmodat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /chown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fchownat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lchown/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /setxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lsetxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fsetxattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /removexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /lremovexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /fremovexattr/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /chmod|fchmod|fchmodat|chown|fchown|fchownat|lchown|setxattr|lsetxattr|fsetxattr|removexattr|lremovexattr|fremovexattr/).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F key=perm_mod"])
            || split("-").containsAll(["k perm_mod"])
      )
    docs:
      desc: |-
        This check verifies that changes to file permissions, attributes, ownership, and group are monitored. It ensures that system calls affecting these properties—such as `chmod`, `fchmod`, `fchmodat` (permissions), `chown`, `fchown`, `fchownat`, `lchown` (ownership), and `setxattr`, `lsetxattr`, `fsetxattr`, `removexattr`, `lremovexattr`, `fremovexattr` (extended attributes)—are audited.

        **Why this matters**

        Monitoring changes to file permissions and attributes is critical for maintaining system security. Unauthorized or accidental modifications can lead to privilege escalation, data leakage, or system compromise.

        If these events are not audited:
          - Changes to critical files may go undetected, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - Compliance with security standards requiring audit logging may be compromised.

        By auditing these system calls, administrators can detect and respond to unauthorized changes, ensuring the integrity of file permissions and attributes.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-perm_mod.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-perm_mod.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
        -a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.


        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-unsuccessful-unauthorized-file-access-attempts-are-collected
    title: Ensure unsuccessful unauthorized file access attempts are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / creat /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / open /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / openat /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / truncate /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == / ftruncate /)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == / creat | open | openat | truncate | ftruncate /).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F exit=","EPERM "])
            || split("-").containsAll(["F exit=","EACCES "])
          && split("-").containsAll(["F key=access"])
            || split("-").containsAll(["k access"])
            || split("-").containsAll(["F key=perm_mod"])
            || split("-").containsAll(["k perm_mod"])
      )
    docs:
      desc: |
        This check verifies that the system is configured to monitor unsuccessful attempts to access files by auditing system calls such as `creat`, `open`, `openat`, `truncate`, and `ftruncate`. These system calls control the creation, opening, and truncation of files. The audit log will record events where the user is a non-privileged user (auid >= 1000), is not a daemon event (auid=4294967295), and the system call returned EACCES (permission denied) or EPERM (operation not permitted). All audit records will be tagged with the identifier "access."

        **Why this matters**

        Monitoring unsuccessful file access attempts helps detect potential unauthorized access or misconfigurations. It provides visibility into failed attempts to create, open, or modify files, which may indicate malicious activity or user errors.

        If these events are not audited:
          - Unauthorized access attempts may go unnoticed, increasing the risk of data breaches.
          - Misconfigurations or permission issues may persist without detection.
          - The system may fall out of compliance with security standards requiring audit logging.

        By auditing these system calls, administrators can identify and respond to unauthorized access attempts, ensuring the integrity and security of the system.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-access.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-access.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
        -a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-events-that-modify-usergroup-information-are-collected
    title: Ensure events that modify user/group information are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/group\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/passwd\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/gshadow\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/shadow\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/etc\/security\/opasswd\s+\-p\s+wa\s+\-k\s+identity(\s+)?$/))
    docs:
      desc: |-
        This check verifies that the system is configured to monitor changes to critical user and group management files, including `/etc/group`, `/etc/passwd`, `/etc/shadow`, `/etc/gshadow`, and `/etc/security/opasswd`. These files store information about user accounts, group memberships, and password policies.

        **Why this matters**

        Monitoring changes to these files is essential for maintaining system security. Unauthorized modifications can lead to privilege escalation, unauthorized access, or other malicious activities.

        If monitoring is not enabled:
          - Changes to user or group configurations may go undetected, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - The system may fall out of compliance with security standards requiring audit logging.

        By ensuring that changes to these critical files are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation: |-
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-identity.rules`

        Add the following lines:

        ```
        -w /etc/group -p wa -k identity
        -w /etc/passwd -p wa -k identity
        -w /etc/gshadow -p wa -k identity
        -w /etc/shadow -p wa -k identity
        -w /etc/security/opasswd -p wa -k identity
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-successful-file-system-mounts-are-collected
    title: Ensure successful file system mounts are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always\,exit\s+\-F\s+arch\=b64\s+\-S\s+mount\s+\-F\s+auid\>\=1000\s+\-F\s+auid\!\=(4294967295|unset|-1)\s+\-k\s+mounts(\s+)?$/)) || props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always\,exit\s+\-F\s+arch\=b32\s+\-S\s+mount\s+\-F\s+auid\>\=1000\s+\-F\s+auid\!\=(4294967295|unset|-1)\s+\-k\s+mounts(\s+)?$/))
    docs:
      desc: |-
        This check verifies that the system is configured to monitor successful file system mount events by auditing the `mount` system call. The audit log will record events where the user is a non-privileged user (auid >= 1000) and is not a daemon event (auid=4294967295). All audit records will be tagged with the identifier "mounts."

        **Why this matters**

        Monitoring successful file system mounts is critical for maintaining system security. Unauthorized or unexpected mounts can lead to data leakage, privilege escalation, or other malicious activities.

        If these events are not audited:
          - Unauthorized mounts may go unnoticed, exposing the system to potential threats.
          - It becomes difficult to trace unauthorized actions or identify the source of configuration drift.
          - The system may fall out of compliance with security standards requiring audit logging.

        By ensuring that successful file system mount events are monitored, organizations can maintain a secure environment and quickly respond to potential threats.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-mounts.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-mounts.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
        -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-file-deletion-events-by-users-are-collected
    title: Ensure file deletion events by users are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /unlink/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /rename/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /unlinkat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.any(_ == /renameat/)
      props.mondooLinuxSecurityAuditFiles.flat.unique.where(_ == /unlink|rename|unlinkat|renameat/).all(
        split("=").any(split(" ").any(_ == logindefs.params.UID_MIN))
          && split("-").containsAll(["a always,exit ",])
          && split("-").containsAll(["F auid!=","1 "])
            || split("-").containsAll(["F auid!=unset "])
            || split("-").containsAll(["F auid!=4294967295 "])
          && split("-").containsAll(["F arch=b64 "])
            || split("-").containsAll(["F arch=b32 "])
          && split("-").containsAll(["F key=delete"])
            || split("-").containsAll(["k delete"])
      )
    docs:
      desc: |-
        Monitor the use of system calls associated with the deletion or renaming of files and file attributes. This configuration statement sets up monitoring for the `unlink` (remove a file), `unlinkat` (remove a file attribute), `rename` (rename a file) and `renameat` (rename a file attribute) system calls and tags them with the identifier "delete".

        **Note:**
        Systems may have been customized to change the default UID_MIN. To confirm the UID_MIN for your system, run this command:

        ```
        awk '/^\s*UID_MIN/{print $2}' /etc/login.defs
        ```

        If your systems' UID_MIN is not `1000`, replace `audit>=1000` with `audit>=<UID_MIN for your system>` in the Audit and Remediation procedures.
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-deletion.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-deletion.rules`

        Add the following lines:

        ```
        -a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
        -a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-kernel-module-loading-and-unloading-is-collected
    title: Ensure kernel module loading and unloading is collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/insmod\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/rmmod\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/sbin\/modprobe\s+\-p\s+x\s+\-k\s+modules(\s+)?$/))
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always,exit\s+\-F\s+arch\=b64\s+\-S\s+init\_module\s+\-S\s+delete\_module\s+\-k\s+modules(\s+)?$/)) || props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-a\s+always,exit\s+\-F\s+arch\=b32\s+\-S\s+init\_module\s+\-S\s+delete\_module\s+\-k\s+modules(\s+)?$/))
    docs:
      desc: |-
        Monitor the loading and unloading of kernel modules. The programs `insmod` (install a kernel module), `rmmod` (remove a kernel module), and `modprobe` (a more sophisticated program to load and unload modules, as well as some other features) control loading and unloading of modules. The `init_module` (load a module) and `delete_module` (delete a module) system calls control loading and unloading of modules. Any execution of the loading and unloading module programs and system calls will trigger an audit record with an identifier of "modules".
      remediation: |-
        For 32-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-modules.rules`

        Add the following lines:

        ```
        -w /sbin/insmod -p x -k modules
        -w /sbin/rmmod -p x -k modules
        -w /sbin/modprobe -p x -k modules
        -a always,exit -F arch=b32 -S init_module -S delete_module -k modules
        ```

        For 64-bit systems edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules`

        Example: `vi /etc/audit/rules.d/50-modules.rules`

        Add the following lines:

        ```
        -w /sbin/insmod -p x -k modules
        -w /sbin/rmmod -p x -k modules
        -w /sbin/modprobe -p x -k modules
        -a always,exit -F arch=b64 -S init_module -S delete_module -k modules
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-system-administrator-actions-sudolog-are-collected
    title: Ensure system administrator actions (sudolog) are collected
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/^(\s+)?\-w\s+\/var\/log\/sudo\.log\s+\-p\s+wa\s+\-k\s+actions(\s+)?$/))
    docs:
      desc: |-
        Monitor the `sudo` log file. If the system has been properly configured to disable the use of the `su` command and force all administrators to have to log in first and then use `sudo` to execute privileged commands, then all administrator commands will be logged to `/var/log/sudo.log`. Any time a command is executed, an audit event will be triggered as the `/var/log/sudo.log` file will be opened for write and the executed administration command will be written to the log.
      remediation: |
        Edit or create a file in the `/etc/audit/rules.d/` directory ending in `.rules` and add the following line:

        ```
        -w <Path to sudo log file> -p wa -k actions
        ```

        Example: `vi /etc/audit/rules.d/actions.rules`

        and add the following line:

        ```
        -w /var/log/sudo.log -p wa -k actions
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-the-audit-configuration-is-immutable
    title: Ensure the audit configuration is immutable
    impact: 50
    props:
      - uid: mondooLinuxSecurityAuditFiles
        title: Return the content from all /etc/audit/rules.d and /etc/audit/audit.rules
        mql: |
          mondooLinuxSecurityAuditFiles = files.find(from: "/etc/audit/rules.d",regex:'.*\.rules$', type: "file").list.map(path) + ["/etc/audit/audit.rules"]
          return mondooLinuxSecurityAuditFiles.map(file(_).content.lines.where( _ == /^[^#]/ ))
    mql: |
      props.mondooLinuxSecurityAuditFiles.any(_.contains(/(\s+)?\-e\s+2(\s+)?$/))
    docs:
      desc: |-
        Set system audit so that audit rules cannot be modified with `auditctl`. Setting the flag `-e 2` forces audit to be put in immutable mode. Audit changes can only be made on system reboot.
      remediation: |-
        Edit or create the file `/etc/audit/audit.rules` and add the following line at the end of the file:

        ```
        -e 2
        ```

        To load the newly added rules into the running configuration:

        ```bash
        augenrules --load
        ```

        This command will generate a new `/etc/audit/audit.rules` file containing the newly added rules.

        Check if a reboot is required, in case the running configuration is set to be immutable:

        ```bash
        if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        ```
  - uid: mondoo-linux-security-sudo-logging-is-enabled
    title: Ensure sudo logging is enabled
    impact: 80
    props:
      - uid: mondooLinuxSecuritySudoersFiles
        title: Return the files from /etc/sudoers.d
        mql: |
          sudoersFiles = files.find(from: "/etc/sudoers.d/", type: 'file').list.map(path) + ["/etc/sudoers"]
          return sudoersFiles.map(file(_).content.lines.where(_ == /^[^#]/)).flat
    mql: |
      props.mondooLinuxSecuritySudoersFiles
        .where(_ == /Defaults/)
        .any(_ == /logfile=\"\/var\/log\/sudo\.log\"/)
    docs:
      desc: By default, sudo logs all events in the /var/log/auth.log file. This log file contains all authentication events system-wide, making it difficult to audit sudo failures. To reduce the chances of sudo failures going unnoticed, administrations should configure sudo to log to a dedicated log file location.
      remediation: |-
        Using the `visudo` command, add the following line to the `/etc/sudoers` configuration file.

        ```
        Defaults log_host, log_year, logfile="/var/log/sudo.log"
        ```
  - uid: mondoo-linux-security-permissions-on-etcsshsshd-config-are-configured
    title: Ensure secure permissions on /etc/ssh/sshd_config are set
    impact: 100
    mql: |
      file("/etc/ssh/sshd_config") {
        user.name == "root"
        group.name == "root"
        permissions.user_executable == false
        permissions.group_readable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: The `/etc/ssh/sshd_config` file contains configuration specifications for `sshd`. The command below sets the owner and group of the file to root.
      remediation: |-
        Run these commands to set ownership and permissions on `/etc/ssh/sshd_config`:

        ```bash
        chown root:root /etc/ssh/sshd_config
        chmod og-rwx /etc/ssh/sshd_config
        ```
  - uid: mondoo-linux-security-rsyslog-is-installed
    title: Ensure rsyslog is installed
    impact: 50
    mql: |
      package("rsyslog").installed
    docs:
      desc: |-
        The `rsyslog` software is a recommended replacement to the original `syslogd` daemon which provide improvements over `syslogd`, such as connection-oriented (i.e. TCP) transmission of logs, the option to log to database formats, and the encryption of log data en route to a central logging server.
      remediation: |-
        Run this command to install rsyslog:

        ### RHEL/Fedora/Amazon Linux and derivatives

        ```bash
        yum install rsyslog
        ```

        ### Debian/Ubuntu and derivatives

        ```bash
        apt-get install rsyslog
        ```

        ### SLES and openSUSE

        ```bash
        zypper install rsyslog
        ```
  - uid: mondoo-linux-security-rsyslog-service-is-enabled
    title: Ensure rsyslog Service is enabled
    impact: 50
    mql: |
      service("rsyslog").enabled
    docs:
      desc: Once the `rsyslog` package is installed it needs to be enabled.
      remediation: |-
        Run this command to enable `rsyslog`:

        ```bash
        systemctl --now enable rsyslog
        ```
  - uid: mondoo-linux-security-rsyslog-default-file-permissions-configured
    title: Ensure rsyslog default file permissions configured
    impact: 60
    mql: |
      rsyslog.conf.settings.contains("$FileCreateMode 0640")
    docs:
      desc: rsyslog will create log files that do not already exist on the system. This setting controls what permissions will be applied to these newly created files.
      remediation: |-
        Edit the `/etc/rsyslog.conf` and `/etc/rsyslog.d/*.conf` files and set `$FileCreateMode` to `0640` or more restrictive:

        ```
        $FileCreateMode 0640
        ```
  - uid: mondoo-linux-security-journald-is-configured-to-send-logs-to-rsyslog
    title: Ensure journald is configured to send logs to rsyslog
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["ForwardToSyslog"].downcase == "yes"
        }
      }
    docs:
      desc: |-
        Data from journald may be stored in volatile memory or persisted locally on the server. Utilities exist to accept remote export of journald logs, however, use of the rsyslog service provides a consistent means of log collection and export.
      remediation: |-
        Edit the `/etc/systemd/journald.conf` file and add the following line:

        ```
        ForwardToSyslog=yes
        ```

        Restart the service to load the new configuration values:

        ```bash
        systemctl restart systemd-journald
        ```
  - uid: mondoo-linux-security-journald-is-configured-to-compress-large-log-files
    title: Ensure journald is configured to compress large log files
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["Compress"] == "yes"
        }
      }
    docs:
      desc: The journald system includes the capability of compressing overly large files to avoid filling up the system with logs or making the logs unmanageably large.
      remediation: |-
        Edit the `/etc/systemd/journald.conf` file and add the following line:

        ```
        Compress=yes
        ```

        Restart the service to load the new configuration values:

        ```bash
        systemctl restart systemd-journald
        ```
  - uid: mondoo-linux-security-journald-is-configured-to-write-logfiles-to-persistent-disk
    title: Ensure journald is configured to write logfiles to persistent disk
    impact: 50
    mql: |
      ["/etc/systemd/journald.conf"].where(file(_).exists) {
        file(_) {
          parse.ini("/etc/systemd/journald.conf").sections["Journal"]["Storage"] == "persistent"
        }
      }
    docs:
      desc: Data from journald may be stored in volatile memory or persisted locally on the server. Logs in memory will be lost upon a system reboot. Persisting logs to a local disk on the server protects logs loss.
      remediation: |-
        Edit the `/etc/systemd/journald.conf` file and add the following line:

        ```
        Storage=persistent
        ```

        Restart the service to load the new configuration values:

        ```bash
        systemctl restart systemd-journald
        ```
  - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
    title: Ensure secure permissions on all log files are set
    impact: 80
    mql: |
      files.find(from: "/var/log", type: "file").list {
        path
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: Log files stored in /var/log/ contain logged information from many services on the system. If the host is a log aggregation server, these logs may collect sensitive data from large numbers of systems in your environment.
      remediation: |-
        Run these commands to set permissions on all existing log files:

        ```bash
        find /var/log/ -type f -perm /g+wx,o+rwx -exec chmod g-wx,o-rwx "{}" +
        ```

        _Note: The configuration for your logging software or services may need to also be modified for any logs that had incorrect permissions, otherwise, the permissions may be reverted to the incorrect permissions_

        _rsyslog.conf_

        ```
        vi /etc/rsyslog.conf
        ..
        $FileCreateMode 0640
        $Umask 0077
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary files:

        ```
        vi /etc/tmpfiles.d/var.conf
        ..
        f /var/log/faillog 0640 root root -
        f /var/log/wtmp 0640 root utmp -
        f /var/log/btmp 0640 root utmp -
        f /var/log/lastlog 0640 root utmp -
        ```
  - uid: mondoo-linux-security-permissions-on-ssh-private-host-key-files-are-configured
    title: Ensure secure permissions on SSH private host key files are set
    impact: 100
    mql: |
      files.
        find(from: "/etc/ssh", type: "file").
        where(path == /ssh_host_.*key$/).list {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
    docs:
      desc: An SSH private key is one of two files used in SSH public key authentication. In this authentication method, The possession of the private key is proof of identity. Only a private key corresponding to a public key can authenticate successfully. The private keys need to be stored and handled carefully, and no copies of the private key should be distributed.
      remediation: |-
        Run these commands to set ownership and permissions on the private SSH host key files

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chown root:ssh_keys {} \;
        ```

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key' -exec chmod 0600 {} \;
        ```
  - uid: mondoo-linux-security-permissions-on-ssh-public-host-key-files-are-configured
    title: Ensure secure permissions on SSH public host key files are set
    impact: 80
    mql: |
      files.
        find(from: "/etc/ssh", type: "file").
        where(path == /ssh_host_.*key.pub$/).list {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
    docs:
      desc: An SSH public key is one of two files used in SSH public key authentication. In this authentication method, a public key is a key that can be used for verifying digital signatures generated using a corresponding private key. Only a public key corresponding to a private key can authenticate successfully.
      remediation: |-
        Run these commands to set permissions and ownership on the SSH host public key files

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chmod 0644 {} \;
        ```

        ```bash
        find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -exec chown root:root {} \;
        ```
  - uid: mondoo-linux-security-ssh-protocol-is-set-to-2
    title: Ensure SSH Protocol is set to 2
    impact: 80
    # openssh-server 7.6 and later remove support for protocol v1
    filters: package('openssh-server').version  >= semver("6") && package('openssh-server').version  < semver("7.6")
    mql: |
      sshd.config.params["Protocol"] == 2
    docs:
      desc: 'SSH supports two different and incompatible protocols: SSH1 and SSH2. SSH1 was the original protocol and was subject to security issues. SSH2 is more advanced and secure.'
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `Protocol`parameter as follows:

        ```
        Protocol 2
        ```
  - uid: mondoo-linux-security-ssh-loglevel-is-appropriate
    title: Ensure SSH LogLevel is appropriate
    impact: 60
    mql: |
      sshd.config.params["LogLevel"] == /INFO|VERBOSE/
    docs:
      desc: |-
        `INFO` level is the basic level that only records the login activity of SSH users. In many situations, such as incident response, it is important to determine when a particular user was active on a system. The logout record can eliminate those users who disconnected, which helps narrow the field.

        `VERBOSE` level specifies that login and logout activity as well as the key fingerprint for any SSH key used for login will be logged. This information is important for SSH key management, especially in legacy environments.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `LogLevel` parameter as follows:

        ```
        LogLevel VERBOSE
        ```

        or

        ```
        LogLevel INFO
        ```
  - uid: mondoo-linux-security-ssh-x11-forwarding-is-disabled
    title: Ensure SSH X11 forwarding is disabled
    impact: 50
    mql: |
      sshd.config.params["X11Forwarding"] == "no"
    docs:
      desc: The X11Forwarding parameter allows tunneling X11 traffic through the connection to enable remote graphic connections.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `X11Forwarding` parameter as follows:

        ```
        X11Forwarding no
        ```
  - uid: mondoo-linux-security-ssh-maxauthtries-is-set-to-4-or-less
    title: Ensure SSH MaxAuthTries is set to 4 or less
    impact: 75
    mql: |
      sshd.config.params["MaxAuthTries"] <= 4
    docs:
      desc: The `MaxAuthTries` parameter specifies the maximum number of authentication attempts permitted per connection. When the login failure count reaches half this maximum value, error messages will be written to the `syslog` file detailing the login failure.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `MaxAuthTries` parameter as follows:

        ```
        MaxAuthTries 4
        ```
  - uid: mondoo-linux-security-ssh-ignorerhosts-is-enabled
    title: Ensure SSH IgnoreRhosts is enabled
    impact: 60
    mql: |
      sshd.config.params["IgnoreRhosts"] == "yes"
    docs:
      desc: The `IgnoreRhosts` parameter specifies that `.rhosts` and `.shosts` files will not be used in `RhostsRSAAuthentication` or `HostbasedAuthentication` .
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `IgnoreRhosts` parameter as follows:

        ```
        IgnoreRhosts yes
        ```
  - uid: mondoo-linux-security-ssh-hostbasedauthentication-is-disabled
    title: Ensure SSH HostbasedAuthentication is disabled
    impact: 70
    mql: |
      sshd.config.params["HostbasedAuthentication"] == "no"
    docs:
      desc: The `HostbasedAuthentication` parameter specifies if authentication is allowed through trusted hosts via the user of `.rhosts`, or `/etc/hosts.equiv`, along with successful public key client host authentication. This option only applies to SSH Protocol Version 2.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `HostbasedAuthentication` parameter as follows:

        ```
        HostbasedAuthentication no
        ```
  - uid: mondoo-linux-security-ssh-root-login-is-disabled
    title: Ensure SSH root login is disabled or set to prohibit-password
    impact: 100
    mql: |
      sshd.config.params["PermitRootLogin"] == "no" || sshd.config.params["PermitRootLogin"] == "prohibit-password" || sshd.config.params["PermitRootLogin"] == "without-password"
    docs:
      desc: The `PermitRootLogin` parameter specifies if the root user can log in using ssh(1). The default is no.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `PermitRootLogin` parameter as follows:

        ```
        PermitRootLogin no
        ```
  - uid: mondoo-linux-security-ssh-permitemptypasswords-is-disabled
    title: Ensure SSH PermitEmptyPasswords is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitEmptyPasswords"] == "no"
    docs:
      desc: The `PermitEmptyPasswords` parameter specifies if the SSH server allows login to accounts with empty password strings.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `PermitEmptyPasswords` parameter as follows:

        ```
        PermitEmptyPasswords no
        ```
  - uid: mondoo-linux-security-ssh-permituserenvironment-is-disabled
    title: Ensure SSH PermitUserEnvironment is disabled
    impact: 70
    mql: |
      sshd.config.params["PermitUserEnvironment"] == "no"
    docs:
      desc: The `PermitUserEnvironment` option allows users to present environment options to the `ssh` daemon.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `PermitUserEnvironment` parameter as follows:

        ```
        PermitUserEnvironment no
        ```
  - uid: mondoo-linux-security-only-strong-ciphers-are-used
    title: Ensure only strong ciphers are used
    impact: 100
    filters: package('openssh-server').installed
    props:
      - uid: mondooLinuxSecuritySshdCiphers
        title: Define the hardened ciphers for all SSH configurations
        mql: |
          if( package('openssh-server').version >= semver("6") && package('openssh-server').version < semver("7")  ) {
            return ["aes256-ctr", "aes192-ctr", "aes128-ctr"]
          }
          return ["chacha20-poly1305@openssh.com","aes256-gcm@openssh.com","aes128-gcm@openssh.com","aes256-ctr","aes192-ctr","aes128-ctr"]
    mql: |
      sshd.config.ciphers != empty
      sshd.config.ciphers.containsOnly(props.mondooLinuxSecuritySshdCiphers)
    docs:
      desc: This variable limits the ciphers that SSH can use during communication.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to add or modify the `Ciphers` parameter so that it contains a comma-separated list of the site approved ciphers

        Example:

        ```
        Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr
        ```
  - uid: mondoo-linux-security-only-strong-mac-algorithms-are-used
    title: Ensure only strong MAC algorithms are used
    impact: 80
    props:
      - uid: mondooLinuxSecurityMacAlgos
        title: Define the accepted MAC algorithms
        mql: |
          return ["umac-128-etm@openssh.com","hmac-sha2-256-etm@openssh.com","hmac-sha2-512-etm@openssh.com",
                  "umac-128@openssh.com","hmac-sha2-256","hmac-sha2-512"]
    mql: |
      sshd.config.macs != empty
      sshd.config.macs.containsOnly(props.mondooLinuxSecurityMacAlgos)
    docs:
      desc: This variable limits the types of MAC algorithms that SSH can use during communication.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to add or modify the `MACs` parameter so that it contains a comma-separated list of the site approved MACs

        Example:

        ```
        MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256
        ```
  - uid: mondoo-linux-security-only-strong-kex-algorithms-are-used
    title: Ensure that strong Key Exchange algorithms are used
    impact: 100
    filters: package('openssh-server').installed
    props:
      - uid: mondooLinuxSecurityKexAlgos
        title: Define the hardened key exchange algorithms for all SSH configurations
        mql: |
          if( package('openssh-server').version  >= semver("6") && package('openssh-server').version  < semver("7") ) {
            return ["curve25519-sha256@libssh.org"]
          }
          if( package('openssh-server').version  >= semver("7") && package('openssh-server').version  < semver("8") ) {
            return ["curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
          }
          if( package('openssh-server').version  >= semver("8") && package('openssh-server').version  < semver("9") ) {
            return ["sntrup4591761x25519-sha512@tinyssh.org","curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
          }
          return ["sntrup761x25519-sha512@openssh.com","curve25519-sha256@libssh.org","diffie-hellman-group18-sha512"]
    mql: |
      sshd.config.kexs != empty
      sshd.config.kexs.containsOnly(props.mondooLinuxSecurityKexAlgos)
    docs:
      desc: Key exchange is any method in cryptography by which cryptographic keys are exchanged between two parties, allowing use of a cryptographic algorithm. If the sender and receiver wish to exchange encrypted messages, each must be equipped to encrypt messages to be sent and decrypt messages received
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to add or modify the `KexAlgorithms` parameter so that it contains a comma-separated list of the site approved key exchange algorithms

        openssh-server version 6.x

        ```
        KexAlgorithms curve25519-sha256@libssh.org
        ```

        openssh-server version 7.x:

        ```
        KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
        ```

        openssh-server version 8.0 to 8.5:

        ```
        KexAlgorithms sntrup4591761x25519-sha512@tinyssh.org,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
        ```

        openssh-server version 8.6 or later:

        ```
        KexAlgorithms sntrup761x25519-sha512@openssh.com,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512
        ```

        NOTE:
        To quickly find out what openssh-server version you are using, run this command:

        ```bash
        cnquery run -c "package('openssh-server').version"
        ```
  - uid: mondoo-linux-security-ssh-idle-timeout-interval-is-configured
    title: Ensure SSH Idle Timeout Interval is configured
    impact: 60
    props:
      - uid: excludedMatchBlocks
        title: A list of match blocks to exclude from checking, add items such as "User ansible"
        mql: |
          return [
            "placeholder-do-not-delete",
          ]
      - uid: checkDefaultMatchBlock
        title: Set to true if you want to check the default "" match block
        mql: |
          return true
    mql: |
      defaultBlock = sshd.config.blocks.where(criteria.in([""]) == props.checkDefaultMatchBlock && criteria == "");

      userBlocks = sshd.config.blocks.where(criteria.contains(props.excludedMatchBlocks) == false && criteria != "");

      userBlocks.all(params.ClientAliveInterval >= 1)
      userBlocks.all(params.ClientAliveInterval <= 900)
      userBlocks.all(params.ClientAliveCountMax > 0)
      userBlocks.all(params.ClientAliveCountMax <= 3)

      defaultBlock.all(params.ClientAliveInterval >= 1)
      defaultBlock.all(params.ClientAliveInterval <= 900)
      defaultBlock.all(params.ClientAliveCountMax > 0)
      defaultBlock.all(params.ClientAliveCountMax <= 3)
    docs:
      desc: The two options `ClientAliveInterval` and `ClientAliveCountMax` control the timeout of ssh sessions. When the `ClientAliveInterval` variable is set, ssh sessions that have no activity for the specified length of time are terminated. When the `ClientAliveCountMax` variable is set, `sshd` will send client alive messages at every `ClientAliveInterval` interval. When the number of consecutive client alive messages are sent with no response from the client, the `ssh` session is terminated. For example, if the `ClientAliveInterval` is set to 15 seconds and the `ClientAliveCountMax` is set to 3, the client `ssh` session will be terminated after 45 seconds of idle time.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `ClientAliveInterval` and `ClientAliveCountMax` parameters according to site policy:

        ```
        ClientAliveInterval 300
        ClientAliveCountMax 0
        ```
  - uid: mondoo-linux-security-ssh-logingracetime-is-set-to-one-minute-or-less
    title: Ensure SSH LoginGraceTime is set to one minute or less
    impact: 80
    mql: |
      sshd.config.params["LoginGraceTime"] >= 1
      sshd.config.params["LoginGraceTime"] <= 60
    docs:
      desc: The `LoginGraceTime` parameter specifies the time (in seconds) allowed for successful authentication to the SSH server. The longer the grace period is, the more open unauthenticated connections can exist. Like other session controls, the grace period should be limited to appropriate organizational limits to ensure the service is available for needed access.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `LoginGraceTime` parameter as follows:

        ```
        LoginGraceTime 60
        ```
  - uid: mondoo-linux-security-ssh-access-is-limited
    title: Ensure SSH access is limited
    impact: 60
    mql: |
      sshd.config.params["AllowUsers"] != empty || sshd.config.params["AllowGroups"] != empty || sshd.config.params["DenyUsers"] != empty || sshd.config.params["DenyGroups"] != empty

      if (sshd.config.params["AllowUsers"] != empty) { sshd.config.params["AllowUsers"] != "" }
      if (sshd.config.params["AllowGroups"] != empty) { sshd.config.params["AllowGroups"] != "" }
      if (sshd.config.params["DenyUsers"] != empty) { sshd.config.params["DenyUsers"] != "" }
      if (sshd.config.params["DenyGroups"] != empty) { sshd.config.params["DenyGroups"] != "" }
    docs:
      desc: |-
        There are several options available to limit which users and groups can access the system via SSH. It is recommended that at least one of the following options be leveraged: `AllowUsers`

        The `AllowUsers` variable gives the system administrator the option of allowing specific users to `ssh` into the system. The list consists of space-separated user names. Numeric user IDs are not recognized with this variable. If a system administrator wants to restrict user access further by only allowing the allowed users to log in from a particular host, the entry can be specified in the form of user@host. `AllowGroups`

        The `AllowGroups` variable gives the system administrator the option of allowing specific groups of users to `ssh` into the system. The list consists of space-separated group names. Numeric group IDs are not recognized with this variable. `DenyUsers`

        The `DenyUsers` variable gives the system administrator the option of denying specific users to `ssh` into the system. The list consists of space-separated user names. Numeric user IDs are not recognized with this variable. If a system administrator wants to restrict user access further by specifically denying user access from a particular host, the entry can be specified in the form of user@host. `DenyGroups`

        The `DenyGroups` variable gives the system administrator the option of denying specific groups of users to `ssh` into the system. The list consists of space-separated group names. Numeric group IDs are not recognized with this variable.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file and add one or more of these parameters:

        ```
        AllowUsers <userlist>
        AllowGroups <grouplist>

        DenyUsers <userlist>
        DenyGroups <grouplist>
        ```
  - uid: mondoo-linux-security-ssh-warning-banner-is-configured
    title: Ensure SSH warning banner is configured
    impact: 30
    mql: |
      sshd.config.params["Banner"] == "/etc/issue.net"
    docs:
      desc: The `Banner` parameter specifies a file whose contents must be sent to the remote user before authentication is permitted. By default, no banner is displayed.
      remediation: |-
        Edit the `/etc/ssh/sshd_config` file to set the `Banner` parameter as follows:

        ```
        Banner /etc/issue.net
        ```
  - uid: mondoo-linux-security-permissions-on-etcpasswd-are-configured
    title: Ensure secure permissions on /etc/passwd are set
    impact: 100
    mql: |
      file("/etc/passwd") {
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: The `/etc/passwd` file contains user account information used by many system utilities and therefore must be readable for these utilities to operate.
      remediation: |-
        Run this command to set permissions on `/etc/passwd`:

        ```bash
        chown root:root /etc/passwd
        chmod 644 /etc/passwd
        ```
  - uid: mondoo-linux-security-permissions-on-etcshadow-are-configured
    title: Ensure secure permissions on /etc/shadow are set
    impact: 100
    mql: |
      if (file("/etc/shadow").exists) {
        file("/etc/shadow") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: The `/etc/shadow` file is used to store the information about user accounts that is critical to the security of those accounts, such as the hashed password and other security information.
      remediation: |-
        Run these commands to set permissions on `/etc/shadow`:

        ```bash
        chown root:root /etc/shadow
        chmod 640 /etc/shadow
        ```
  - uid: mondoo-linux-security-permissions-on-etcgroup-are-configured
    title: Ensure secure permissions on /etc/group are set
    impact: 100
    mql: |
      file("/etc/group") {
        permissions.user_executable == false
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
    docs:
      desc: The `/etc/group` file contains a list of all the valid groups defined in the system. This file should have read/write access for root and read access for all other users to prevent non-administrative users from modifying groups.
      remediation: |-
        Run this command to set permissions on `/etc/group`:

        ```bash
        chown root:root /etc/group
        chmod 644 /etc/group
        ```
  - uid: mondoo-linux-security-permissions-on-etcgshadow-are-configured
    title: Ensure secure permissions on /etc/gshadow are set
    impact: 100
    mql: |
      if (file("/etc/gshadow").exists) {
        file("/etc/gshadow") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |-
        The `/etc/gshadow` file stores hashed group passwords. It serves as a companion to `/etc/group`, which lists groups and membership, but not sensitive password information.

        If an attacker gains access to `/etc/gshadow` file, they could potentially crack the group passwords to gain elevated access across the system.
      remediation: |-
        Run the following chown to set permissions on `/etc/gshadow`:

        ```bash
        chown root:root /etc/gshadow
        chmod 640 /etc/gshadow
        ```
  - uid: mondoo-linux-security-permissions-on-etcpasswd--are-configured
    title: Ensure secure permissions on /etc/passwd- are set
    impact: 100
    mql: |
      if (file("/etc/passwd-").exists) {
        file("/etc/passwd-") {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |-
        The `/etc/passwd-`` file in Linux is a backup copy of the main `/etc/passwd` file, which contains essential information about system users. The `-` suffix signifies that this file is a backup and is created automatically by the system when there are changes made to the /etc/passwd file, such as adding or deleting a user.
      remediation: |-
        Run this command to set permissions on `/etc/passwd-`:

        ```bash
        chown root:root /etc/passwd-
        chmod 600 /etc/passwd-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/passwd- 0600 root root -
        ```
  - uid: mondoo-linux-security-permissions-on-etcshadow--are-configured
    title: Ensure secure permissions on /etc/shadow- are set
    impact: 100
    mql: |
      if (file("/etc/shadow-").exists) {
        file("/etc/shadow-") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: The `/etc/shadow-` file is used to store backup information about user accounts, such as the hashed password and other security information. Only the root user should have read and write permissions on this file so that sensitive user information is not available to non-administrative users on the system.
      remediation: |-
        Run these commands to set permissions on `/etc/shadow-`:

        ```bash
        chown root:root /etc/shadow-
        chmod 640 /etc/shadow-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/shadow- 0600 root root -
        ```
  - uid: mondoo-linux-security-permissions-on-etcgroup--are-configured
    title: Ensure secure permissions on /etc/group- are set
    impact: 100
    mql: |
      if (file("/etc/group-").exists) {
        file("/etc/group-") {
          permissions.user_executable == false
          permissions.group_readable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: The `/etc/group-` file contains a backup list of all the valid groups defined in the system. Only the root user should have read and write permissions on this file so that group names an user membership is not available to non-administrative users on the system.
      remediation: |-
        Run this command to set permissions on `/etc/group-`:

        ```bash
        chown root:root /etc/group-
        chmod 600 /etc/group-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/group- 0600 root root -
        ```
  - uid: mondoo-linux-security-permissions-on-etcgshadow--are-configured
    title: Ensure secure permissions on /etc/gshadow- are set
    impact: 100
    mql: |
      if (file("/etc/gshadow-").exists) {
        file("/etc/gshadow-") {
          permissions.user_executable == false
          permissions.group_writeable == false
          permissions.group_executable == false
          permissions.other_readable == false
          permissions.other_writeable == false
          permissions.other_executable == false
        }
      }
    docs:
      desc: |-
        The `/etc/gshadow-` file in is a backup of `/etc/gshadow` file, which contains group password information. This file stores information about group administrators, group members, and encrypted group passwords.

        If an attacker gains access to `/etc/gshadow-`, they could potentially crack the group passwords to gain elevated access across the system.
      remediation: |-
        Run these commands to set permissions on `/etc/gshadow-`:

        ```bash
        chown root:root /etc/gshadow-
        chmod 640 /etc/gshadow-
        ```

        Configuration for creation, deletion and cleaning of volatile and temporary `/etc/tmpfiles.d/etc.conf`:

        ```
        f /etc/gshadow- 0600 root root -
        ```
  - uid: mondoo-linux-security-no-duplicate-uids-exist
    title: Ensure no duplicate UIDs exist
    impact: 80
    mql: |
      users.list.duplicates(uid).none()
    docs:
      desc: |
        Each login name, each user ID (UID), and each group ID (GID) MUST ONLY be used once. Every user MUST be a member of at least one group. Every GID mentioned in the /etc/passwd file MUST be defined in the /etc/group file. Every group SHOULD only contain the users that are absolutely necessary. In networked systems, care MUST also be taken to ensure that user and group names (UIDs and GIDs) are assigned consistently in the system network if there is a possibility that the same UIDs or GIDs could be assigned to different user or group names on the systems during cross-system access.

        The `useradd` program does not let you create duplicate user IDs (UID), but for an administrator it is possible to manually edit the `/etc/passwd` and create a duplicate UID entry.
      remediation: |
        Based on the results of the query output, establish unique UIDs and review all files owned by the shared UIDs to determine which UID they are supposed to belong to.

        Run this command to set the new UID of a user:

        ```bash
        usermod -u <new uid> <user>
        ```
  - uid: mondoo-linux-security-no-duplicate-user-names-exist
    title: Ensure no duplicate user names exist
    impact: 80
    mql: |
      users.list.duplicates(name).none()
    docs:
      desc: |
        Each login name, each user ID (UID), and each group ID (GID) MUST ONLY be used once. Every user MUST be a member of at least one group. Every GID mentioned in the /etc/passwd file MUST be defined in the /etc/group file. Every group SHOULD only contain the users that are absolutely necessary. In networked systems, care MUST also be taken to ensure that user and group names (UIDs and GIDs) are assigned consistently in the system network if there is a possibility that the same UIDs or GIDs could be assigned to different user or group names on the systems during cross-system access.

        The `useradd` program does not let you create a duplicate user name, but for an administrator it is possible to manually edit the `/etc/passwd` file and create a duplicated username entry.
      remediation: |
        Based on the results of the query output, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs.

        Run this command to set the new user name:

        ```bash
        usermod -l <new login-name> <old username>
        ```
  - uid: mondoo-linux-security-no-duplicate-gids-exist
    title: Ensure no duplicate GIDs exist
    impact: 80
    mql: |
      groups.list.duplicates(gid).none()
    docs:
      desc: |
        Each login name, each user ID (UID), and each group ID (GID) MUST ONLY be used once. Every user MUST be a member of at least one group. Every GID mentioned in the /etc/passwd file MUST be defined in the /etc/group file. Every group SHOULD only contain the users that are absolutely necessary. In networked systems, care MUST also be taken to ensure that user and group names (UIDs and GIDs) are assigned consistently in the system network if there is a possibility that the same UIDs or GIDs could be assigned to different user or group names on the systems during cross-system access.

        The `groupadd` program does not let you create a duplicate group ID (GID), but for an administrator it is possible to manually edit the `/etc/group` file and create a duplicated GID entry.
      remediation: |
        Based on the results of the query output, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to.
  - uid: mondoo-linux-security-no-duplicate-group-names-exist
    title: Ensure no duplicate group names exist
    impact: 80
    mql: |
      groups.list.duplicates(name).none()
    docs:
      desc: |
        Each login name, each user ID (UID), and each group ID (GID) MUST ONLY be used once. Every user MUST be a member of at least one group. Every GID mentioned in the /etc/passwd file MUST be defined in the /etc/group file. Every group SHOULD only contain the users that are absolutely necessary. In networked systems, care MUST also be taken to ensure that user and group names (UIDs and GIDs) are assigned consistently in the system network if there is a possibility that the same UIDs or GIDs could be assigned to different user or group names on the systems during cross-system access.

        The `groupadd` program does not let you create a duplicate group name, but for an administrator it is possible to manually edit the `/etc/group` file and create a duplicated group name entry.
      remediation: |
        Based on the results of the query output, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.

        Run this command to set the new group name:

        ```bash
        groupmod -n <new group name> <old groupname>
        ```
  - uid: mondoo-linux-security-default-group-for-the-root-account-is-gid-0
    title: Ensure default group for the root account is GID 0
    impact: 80
    mql: |
      users.where(name == "root").list.all(gid == 0)
    docs:
      desc: |
        The `usermod` command can be used to specify which group the root user belongs to. This affects permissions of files that are created by the root user.
      remediation: |
        Run this command to set the `root` user default group to GID `0`:

        ```bash
        usermod -g 0 root
        ```
  - uid: mondoo-linux-security-each-user-member-of-a-group
    title: Ensure each user is a member of a group
    impact: 70
    mql: |
      users.list.all(gid != empty)
    docs:
      desc: |
        Each user MUST be a member of at least one group.
      remediation: |
        Based on the results of the query output, add the user to a primary group.

        Run this command to set the primary group of a user:

        ```bash
        usermod -G <primary group>
        ```
  - uid: mondoo-linux-security-gid-in-passwd-exists-in-group
    title: Ensure all GIDs in /etc/passwd exist in /etc/group
    impact: 80
    mql: |
      users.list.all(group != empty)
    docs:
      desc: |
        Every GID mentioned in the /etc/passwd file must be defined in the /etc/group file.
      remediation: |
        Based on the results of the query output, correct the GIDs in `/etc/passwd` and `/etc/group`.
  - uid: mondoo-linux-security-uid-min-is-set-to-1000
    title: Ensure UID_MIN is set to 1000
    impact: 60
    filters: |
      asset.kind != "container-image"
    mql: |
      logindefs.params{ _['UID_MIN'] == 1000 }
    docs:
      desc: |
        User ID or UID is used to identify a Linux user with an ID or number. The start number for newly created users can be set with this configuration.
      remediation: |
        Edit the `login.defs` file and set UID_MIN.

        ```
        vim /etc/login.defs


        UID_MIN                  1000
        ```
  - uid: mondoo-linux-security-shadow-group-is-empty
    title: Ensure shadow group is empty
    impact: 80
    mql: |
      groups.where(name == "shadow").all(members.length == 0)
    docs:
      desc: The shadow group allows system programs or defined users the ability to read the `/etc/shadow` file. No users should be assigned to the shadow group.
      remediation: Remove all users from the shadow group in `/etc/group`, and change the primary group of any users with shadow as their primary group.
  - uid: mondoo-linux-security-root-group-is-empty
    title: Ensure root group is empty
    impact: 100
    mql: |
      groups.where(name == "root").all(members == empty || members.all(name == 'root'))
    docs:
      desc: The root group allows system programs or defined users the ability to read and write configurations and files on the system. No users should be assigned to the root group.
      remediation: Remove all users from the shadow group in `/etc/group`, and change the primary group of any users with root as their primary group, except the root user.
  - uid: mondoo-linux-security-system-accounts-are-non-login
    title: Ensure system accounts are non-login
    impact: 70
    mql: |
      users.where( name != "root" && name != "sync" && name != "shutdown" && name != "halt" ).where( uid < 1000 ).list {
        shell == "/usr/bin/nologin" || shell == "/sbin/nologin" || shell == "/usr/sbin/nologin"
      }
    docs:
      desc: |
        There are a number of accounts on Linux systems that are used to manage applications and services. These accounts are not intended for interactive use and do not require a shell.
      remediation: |
        Set the shell for any accounts returned by the audit script to `/sbin/nologin`:

        ```bash
        usermod -s /sbin/nologin <em><user></em>
        ```

        The following script will automatically set all user shells required to `/sbin/nologin` and lock the `sync`, `shutdown`, and `halt` users:

        ```bash
        #!/bin/bash

        for user in `awk -F: '($3 < 1000) {print $1 }' /etc/passwd`; do
        if [ $user != "root" ]; then
          if [ "$(passwd -S $user| cut -d ' ' -f 2)" = "P" ]; then
            echo "Lock $user account"
            usermod -L $user
          fi
          if [ $user != "sync" ] && [ $user != "shutdown" ] && [ $user != "halt" ]; then
            echo "Set /sbin/nologin shell for user $user"
            usermod -s /sbin/nologin $user
          fi
        fi
        done
        ```

        nologin is a per-user method of disabling interactive logins (usually used for system accounts like http or ftp). nologin uses /etc/nologin.txt as an optional source for a non-default message, the login access is always refused independently of the file.
  - uid: mondoo-linux-security-access-to-the-su-command-is-restricted
    title: Ensure access to the su command is restricted
    impact: 80
    filters: |
      asset.kind != "container-image"
    props:
      - uid: mondooLinuxSecuritySudoGroup
        title: Define the members of the sudo or wheel group
        mql: |
          return /root|ec2-user|centos|ubuntu|admin|mondoo/
    mql: |
      pam.conf.entries["/etc/pam.d/su"].where(pamType == "auth" && module == "pam_wheel.so").any(options.contains("use_uid"))
      groups.any(name == "wheel" || name == "sudo")
      groups.where(name == "wheel" || name == "sudo") {
        members {
          name
          name == props.mondooLinuxSecuritySudoGroup
        }
      }
    docs:
      desc: |
        The `su` command allows a user to run a command or shell as another user. Typically, the `su` command can be executed by any user, which is a security concern. Users should instead rely on the`sudo` command, which allows for more granular control over privileged access.
      audit: |
        Run this command and verify output includes matching line:

        ```
        # grep pam_wheel.so /etc/pam.d/su
        auth required pam_wheel.so use_uid
        ```

        Run this command and verify users in wheel group match site policy:

        ```
        # grep wheel /etc/group
        wheel:x:10:root,<user list>
        ```
      remediation: |
        Add the following line to the `/etc/pam.d/su` file:

        ```
        auth required pam_wheel.so use_uid
        ```

        If users need su access, add their username to the comma-separated list of users in the `wheel` group within the `/etc/group` file:

        ```
        wheel:x:10:root,<user list>
        ```
        NOTE: The users allowed in the wheel group are defined in the properties `props.mondooLinuxSecuritySudoGroup` field of this policy. By default the users "root", "ec2-user", "centos" and "ubuntu" are included. To include custom users you need to manually modify this policy. Otherwise the check will fail.

        If you want to lock down the use of the command `su` entirely instead, you need to create an empty group, for example `sugroup`:

        ```bash
        groupadd sugroup
        ```

        Then add the following line to the `/etc/pam.d/su` file:

        ```
        auth required pam_wheel.so use_uid group=sugroup
        ```
