// Code generated by protoc-gen-rangerrpc version DO NOT EDIT.
// source: policy.proto

package policy

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strings"

	ranger "go.mondoo.com/ranger-rpc"
	"go.mondoo.com/ranger-rpc/metadata"
	jsonpb "google.golang.org/protobuf/encoding/protojson"
	pb "google.golang.org/protobuf/proto"
)

// service interface definition

type Hub interface {
	SetBundle(context.Context, *Bundle) (*Empty, error)
	DeletePolicy(context.Context, *Mrn) (*Empty, error)
	ValidateBundle(context.Context, *Bundle) (*Empty, error)
	GetPolicy(context.Context, *Mrn) (*Policy, error)
	GetBundle(context.Context, *Mrn) (*Bundle, error)
	GetPolicyFilters(context.Context, *Mrn) (*Mqueries, error)
	List(context.Context, *PolicySearchFilter) (*Policies, error)
}

// client implementation

type HubClient struct {
	ranger.Client
	httpclient ranger.HTTPClient
	prefix     string
}

func NewHubClient(addr string, client ranger.HTTPClient, plugins ...ranger.ClientPlugin) (*HubClient, error) {
	base, err := url.Parse(ranger.SanitizeUrl(addr))
	if err != nil {
		return nil, err
	}

	u, err := url.Parse("./Hub")
	if err != nil {
		return nil, err
	}

	serviceClient := &HubClient{
		httpclient: client,
		prefix:     base.ResolveReference(u).String(),
	}
	serviceClient.AddPlugins(plugins...)
	return serviceClient, nil
}
func (c *HubClient) SetBundle(ctx context.Context, in *Bundle) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/SetBundle"}, ""), in, out)
	return out, err
}
func (c *HubClient) DeletePolicy(ctx context.Context, in *Mrn) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/DeletePolicy"}, ""), in, out)
	return out, err
}
func (c *HubClient) ValidateBundle(ctx context.Context, in *Bundle) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/ValidateBundle"}, ""), in, out)
	return out, err
}
func (c *HubClient) GetPolicy(ctx context.Context, in *Mrn) (*Policy, error) {
	out := new(Policy)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetPolicy"}, ""), in, out)
	return out, err
}
func (c *HubClient) GetBundle(ctx context.Context, in *Mrn) (*Bundle, error) {
	out := new(Bundle)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetBundle"}, ""), in, out)
	return out, err
}
func (c *HubClient) GetPolicyFilters(ctx context.Context, in *Mrn) (*Mqueries, error) {
	out := new(Mqueries)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetPolicyFilters"}, ""), in, out)
	return out, err
}
func (c *HubClient) List(ctx context.Context, in *PolicySearchFilter) (*Policies, error) {
	out := new(Policies)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/List"}, ""), in, out)
	return out, err
}

// server implementation

type HubServerOption func(s *HubServer)

func WithUnknownFieldsForHubServer() HubServerOption {
	return func(s *HubServer) {
		s.allowUnknownFields = true
	}
}

func NewHubServer(handler Hub, opts ...HubServerOption) http.Handler {
	srv := &HubServer{
		handler: handler,
	}

	for i := range opts {
		opts[i](srv)
	}

	service := ranger.Service{
		Name: "Hub",
		Methods: map[string]ranger.Method{
			"SetBundle":        srv.SetBundle,
			"DeletePolicy":     srv.DeletePolicy,
			"ValidateBundle":   srv.ValidateBundle,
			"GetPolicy":        srv.GetPolicy,
			"GetBundle":        srv.GetBundle,
			"GetPolicyFilters": srv.GetPolicyFilters,
			"List":             srv.List,
		},
	}
	return ranger.NewRPCServer(&service)
}

type HubServer struct {
	handler            Hub
	allowUnknownFields bool
}

func (p *HubServer) SetBundle(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Bundle
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.SetBundle(ctx, &req)
}
func (p *HubServer) DeletePolicy(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.DeletePolicy(ctx, &req)
}
func (p *HubServer) ValidateBundle(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Bundle
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.ValidateBundle(ctx, &req)
}
func (p *HubServer) GetPolicy(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetPolicy(ctx, &req)
}
func (p *HubServer) GetBundle(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetBundle(ctx, &req)
}
func (p *HubServer) GetPolicyFilters(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetPolicyFilters(ctx, &req)
}
func (p *HubServer) List(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req PolicySearchFilter
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.List(ctx, &req)
}

// service interface definition

type QueryRunner interface {
	GetExecutionJob(context.Context, *Mrn) (*ExecutionJob, error)
}

// client implementation

type QueryRunnerClient struct {
	ranger.Client
	httpclient ranger.HTTPClient
	prefix     string
}

func NewQueryRunnerClient(addr string, client ranger.HTTPClient, plugins ...ranger.ClientPlugin) (*QueryRunnerClient, error) {
	base, err := url.Parse(ranger.SanitizeUrl(addr))
	if err != nil {
		return nil, err
	}

	u, err := url.Parse("./QueryRunner")
	if err != nil {
		return nil, err
	}

	serviceClient := &QueryRunnerClient{
		httpclient: client,
		prefix:     base.ResolveReference(u).String(),
	}
	serviceClient.AddPlugins(plugins...)
	return serviceClient, nil
}
func (c *QueryRunnerClient) GetExecutionJob(ctx context.Context, in *Mrn) (*ExecutionJob, error) {
	out := new(ExecutionJob)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetExecutionJob"}, ""), in, out)
	return out, err
}

// server implementation

type QueryRunnerServerOption func(s *QueryRunnerServer)

func WithUnknownFieldsForQueryRunnerServer() QueryRunnerServerOption {
	return func(s *QueryRunnerServer) {
		s.allowUnknownFields = true
	}
}

func NewQueryRunnerServer(handler QueryRunner, opts ...QueryRunnerServerOption) http.Handler {
	srv := &QueryRunnerServer{
		handler: handler,
	}

	for i := range opts {
		opts[i](srv)
	}

	service := ranger.Service{
		Name: "QueryRunner",
		Methods: map[string]ranger.Method{
			"GetExecutionJob": srv.GetExecutionJob,
		},
	}
	return ranger.NewRPCServer(&service)
}

type QueryRunnerServer struct {
	handler            QueryRunner
	allowUnknownFields bool
}

func (p *QueryRunnerServer) GetExecutionJob(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetExecutionJob(ctx, &req)
}

// service interface definition

type Resolver interface {
	Assign(context.Context, *PolicyAssignment) (*Empty, error)
	Unassign(context.Context, *PolicyAssignment) (*Empty, error)
	Resolve(context.Context, *ResolveReq) (*ResolvedPolicy, error)
	UpdateAssetJobs(context.Context, *UpdateAssetJobsReq) (*Empty, error)
	ResolveAndUpdateJobs(context.Context, *UpdateAssetJobsReq) (*ResolvedPolicy, error)
	StoreResults(context.Context, *StoreResultsReq) (*Empty, error)
	GetReport(context.Context, *EntityScoreRequest) (*Report, error)
	GetScore(context.Context, *EntityScoreRequest) (*Report, error)
}

// client implementation

type ResolverClient struct {
	ranger.Client
	httpclient ranger.HTTPClient
	prefix     string
}

func NewResolverClient(addr string, client ranger.HTTPClient, plugins ...ranger.ClientPlugin) (*ResolverClient, error) {
	base, err := url.Parse(ranger.SanitizeUrl(addr))
	if err != nil {
		return nil, err
	}

	u, err := url.Parse("./Resolver")
	if err != nil {
		return nil, err
	}

	serviceClient := &ResolverClient{
		httpclient: client,
		prefix:     base.ResolveReference(u).String(),
	}
	serviceClient.AddPlugins(plugins...)
	return serviceClient, nil
}
func (c *ResolverClient) Assign(ctx context.Context, in *PolicyAssignment) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Assign"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) Unassign(ctx context.Context, in *PolicyAssignment) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Unassign"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) Resolve(ctx context.Context, in *ResolveReq) (*ResolvedPolicy, error) {
	out := new(ResolvedPolicy)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Resolve"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) UpdateAssetJobs(ctx context.Context, in *UpdateAssetJobsReq) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/UpdateAssetJobs"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) ResolveAndUpdateJobs(ctx context.Context, in *UpdateAssetJobsReq) (*ResolvedPolicy, error) {
	out := new(ResolvedPolicy)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/ResolveAndUpdateJobs"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) StoreResults(ctx context.Context, in *StoreResultsReq) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/StoreResults"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) GetReport(ctx context.Context, in *EntityScoreRequest) (*Report, error) {
	out := new(Report)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetReport"}, ""), in, out)
	return out, err
}
func (c *ResolverClient) GetScore(ctx context.Context, in *EntityScoreRequest) (*Report, error) {
	out := new(Report)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetScore"}, ""), in, out)
	return out, err
}

// server implementation

type ResolverServerOption func(s *ResolverServer)

func WithUnknownFieldsForResolverServer() ResolverServerOption {
	return func(s *ResolverServer) {
		s.allowUnknownFields = true
	}
}

func NewResolverServer(handler Resolver, opts ...ResolverServerOption) http.Handler {
	srv := &ResolverServer{
		handler: handler,
	}

	for i := range opts {
		opts[i](srv)
	}

	service := ranger.Service{
		Name: "Resolver",
		Methods: map[string]ranger.Method{
			"Assign":               srv.Assign,
			"Unassign":             srv.Unassign,
			"Resolve":              srv.Resolve,
			"UpdateAssetJobs":      srv.UpdateAssetJobs,
			"ResolveAndUpdateJobs": srv.ResolveAndUpdateJobs,
			"StoreResults":         srv.StoreResults,
			"GetReport":            srv.GetReport,
			"GetScore":             srv.GetScore,
		},
	}
	return ranger.NewRPCServer(&service)
}

type ResolverServer struct {
	handler            Resolver
	allowUnknownFields bool
}

func (p *ResolverServer) Assign(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req PolicyAssignment
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Assign(ctx, &req)
}
func (p *ResolverServer) Unassign(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req PolicyAssignment
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Unassign(ctx, &req)
}
func (p *ResolverServer) Resolve(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req ResolveReq
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Resolve(ctx, &req)
}
func (p *ResolverServer) UpdateAssetJobs(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req UpdateAssetJobsReq
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.UpdateAssetJobs(ctx, &req)
}
func (p *ResolverServer) ResolveAndUpdateJobs(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req UpdateAssetJobsReq
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.ResolveAndUpdateJobs(ctx, &req)
}
func (p *ResolverServer) StoreResults(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req StoreResultsReq
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.StoreResults(ctx, &req)
}
func (p *ResolverServer) GetReport(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req EntityScoreRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetReport(ctx, &req)
}
func (p *ResolverServer) GetScore(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req EntityScoreRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetScore(ctx, &req)
}
